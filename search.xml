<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>抓包</title>
      <link href="/2024/04/26/%E6%8A%93%E5%8C%85/"/>
      <url>/2024/04/26/%E6%8A%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><p>如果说对于网络编程，有什么工具是必会的，我觉得抓包肯定是其中之一了。</p><h2 id="抓包工具的选择"><a href="#抓包工具的选择" class="headerlink" title="抓包工具的选择"></a>抓包工具的选择</h2><h3 id="1-Wireshark"><a href="#1-Wireshark" class="headerlink" title="1. Wireshark"></a>1. Wireshark</h3><p>在具备图形界面的系统上，比如windows，linux发行版ubuntu，opensuse等，我一般直接使用Wireshark直接进行抓包，也方便进行内容的查看。</p><h3 id="2-Tcpdump"><a href="#2-Tcpdump" class="headerlink" title="2. Tcpdump"></a>2. Tcpdump</h3><p>在使用命令行的系统，比如linux服务器，我一般使用Tcpdump进行抓包，无需额外安装，系统一般自带，抓包的到的文件，可以使用Wireshark打开，在图形界面下方便查看内容。</p><h2 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h2><h3 id="Wireshark的安装"><a href="#Wireshark的安装" class="headerlink" title="Wireshark的安装"></a>Wireshark的安装</h3><pre><code class="shell"># 1. 添加wireshark用户组sudo groupadd wireshark# 2. 将dumpcap更改为wireshark用户组sudo chgrp wireshark /usr/bin/dumpcap# 3. 让wireshark用户组有root权限使用dumpcapsudo chmod 4755 /usr/bin/dumpcap# 4. 将需要使用的用户名加入wireshark用户组sudo gpasswd -a $USER wireshark</code></pre><h3 id="tcpdump-的安装"><a href="#tcpdump-的安装" class="headerlink" title="tcpdump 的安装"></a>tcpdump 的安装</h3><p>tcpdump 一般linux都是自带，无需安装，可以这样验证;显示版本信息即是已安装</p><pre><code class="shell">tcpdump --version</code></pre><h2 id="开始抓包"><a href="#开始抓包" class="headerlink" title="开始抓包"></a>开始抓包</h2><h3 id="使用Wireshark"><a href="#使用Wireshark" class="headerlink" title="使用Wireshark"></a>使用Wireshark</h3><p>在28181中我一般只关注sip包和rtp包，所以我一般是直接过滤sip和rtp，可以输入框输入 <code>sip or rtp</code>这样即可，如果设备来源比较多还可以加上ip和端口号的过滤<code>(sip or rtp )and ip.addr==192.168.1.3 and udp.port==5060</code><br>详细的过滤规则可以自行百度，我可以提供一些常用的给大家参考<br><img src="/2024/04/26/%E6%8A%93%E5%8C%85/dump1.png"><br><strong>只过滤SIP：</strong></p><pre><code class="shell">sip</code></pre><p><strong>只获取rtp数据：</strong></p><pre><code class="shell">rtp</code></pre><p><strong>默认方式：</strong></p><pre><code class="shell">sip or rtp</code></pre><p><strong>过滤IP：</strong></p><pre><code class="shell"> sip and ip.addr==192.168.1.3</code></pre><p><strong>过滤端口：</strong></p><pre><code class="shell"> sip and udp.port==5060</code></pre><p>输入命令开启抓包后，此时可以进行音视频播放操作，比如点播，录像回访等，操作完成回到Wireshark点击红色的停止即可，需要保存文件可以点击<code>文件-&gt;导出特定分组</code>导出过滤后的数据，也可以直接<code>文件-&gt;另存为</code>保存未过滤的数据。</p><h3 id="使用tcpdump"><a href="#使用tcpdump" class="headerlink" title="使用tcpdump"></a>使用tcpdump</h3><p>对于服务器抓包，为了得到足够完整的数据，我一般会要求直接抓取网卡数据而不过滤，如下：<br>抓取网卡首先需要获取网卡名，在linux我一般使用<code>ip addr</code>获取网卡信息，如下所示：<br><img src="/2024/04/26/%E6%8A%93%E5%8C%85/dump2.png"></p><pre><code class="shell">sudo tcpdump -i wlp3s0 -w demo.pcap</code></pre><p><img src="/2024/04/26/%E6%8A%93%E5%8C%85/dump3.png"><br>命令行会停留在这个位置，此时可以进行操作，比如点播，录像回放等，操作完成回到命令行使用<code>Ctrl+C</code>结束命令行，在当前目录下得到demo.pcap，将这个文件下载到图形界面操作系统里，即可使用Wireshark查看了<br>更多的操作可以参考： <a href="https://www.cnblogs.com/jiujuan/p/9017495.html">https://www.cnblogs.com/jiujuan/p/9017495.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音视频传输协议</title>
      <link href="/2024/04/25/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/04/25/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="传统音视频传输协议"><a href="#传统音视频传输协议" class="headerlink" title="传统音视频传输协议"></a>传统音视频传输协议</h1><h2 id="RTP-Real-time-Transport-Protocol"><a href="#RTP-Real-time-Transport-Protocol" class="headerlink" title="RTP(Real-time Transport Protocol)"></a>RTP(Real-time Transport Protocol)</h2><p>RTP（Real-time Transport Protocol，实时传输协议）是一种在实时应用程序中传输多媒体数据的网络协议。</p><h3 id="协议类型"><a href="#协议类型" class="headerlink" title="协议类型"></a>协议类型</h3><p>传输层协议</p><p>RTP、TCP、UDP都属于<code>传输层</code>协议; RTP也可以认为是<code>介于应用层与传输层之间</code>（5层模型）。<br><img src="/2024/04/25/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/rtp_1.png"></p><p>从图中可以看出，RTP被划分在<code>传输层</code>，它建立在UDP上。同UDP协议一样，为了实现其实时传输功能，RTP也有固定的封装形式。RTP用来为端到端的实时传输提供时间信息和流同步，但并不保证服务质量。服务质量由RTCP来提供。</p><p>不少人也把RTP归为<code>应用层</code>的一部分，这是从应用开发者的角度来说的。操作系统中的TCP&#x2F;IP等协议栈所提供的是我们最常用的服务，而RTP的实现还是要靠开发者自己。因此从开发的角度来说，RTP的实现和应用层协议的实现没不同，所以可将RTP看成应用层协议。</p><h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p><img src="/2024/04/25/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/rtp_2.png"></p><table><thead><tr><th>字段</th><th>位数</th><th>说明</th></tr></thead><tbody><tr><td>Version (V)</td><td>2</td><td>表示RTP的版本。当前版本是2。</td></tr><tr><td>Padding (P)</td><td>1</td><td>如果需要填充，则设置此位。</td></tr><tr><td>Extension (X)</td><td>1</td><td>如果使用了扩展头，则设置此位。</td></tr><tr><td>CSRC Count (CC)</td><td>4</td><td>表示后续CSRC标识符的数量。</td></tr><tr><td>Marker (M)</td><td>1</td><td>通常用于标记帧的边界。</td></tr><tr><td>Payload Type (PT)</td><td>7</td><td>指示负载的类型（例如，音频或视频编码）。</td></tr><tr><td>Sequence Number</td><td>16</td><td>用于检测丢包和排序。</td></tr><tr><td>Timestamp</td><td>32</td><td>表示数据生成的时间戳。</td></tr><tr><td>SSRC</td><td>32</td><td>标识同步源的唯一标识符。</td></tr><tr><td>CSRC</td><td>0-15</td><td>0到15个32位字段，用于标识贡献源。</td></tr><tr><td>Header Extension (可选)</td><td>可变</td><td>如果X位被设置，可能包含额外的头部扩展。</td></tr><tr><td>Payload</td><td>可变</td><td>实际的数据部分，可能包含音频、视频或其他媒体数据。</td></tr><tr><td>Padding</td><td>可变</td><td>可选填充，以确保帧的字节对齐。</td></tr></tbody></table><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>视频会议：在视频会议应用中，RTP 用于传输实时音视频数据，并确保顺序和时间同步。</li><li>网络电话 (VoIP)：RTP 负责传输语音数据，并与 SIP（Session Initiation Protocol）等协议配合使用。</li><li>实时流媒体：RTP 在实时流媒体应用中，用于传输音视频内容，并支持对传输质量的监控。</li></ul><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="为何光有-UDP-不够，还需要-RTP"><a href="#为何光有-UDP-不够，还需要-RTP" class="headerlink" title="为何光有 UDP 不够，还需要 RTP"></a>为何光有 UDP 不够，还需要 RTP</h4><p>传输媒体流对网络的要求：IP 网络的不可预知性，数据包可能存在丢失、错序等问题</p><p>因此，接收端需要能正确还原音频或视频信号，需要：</p><ol><li>检测出错序，并保持采样和播放之间的同步关系（解决方案：时间戳）</li><li>需要在接收端能够检测出分组丢失（解决方案：序列号）</li></ol><p>那就只有用 RTP 了，UDP 没这功能</p><h2 id="RTCP-Real-time-Transport-Control-Protocol"><a href="#RTCP-Real-time-Transport-Control-Protocol" class="headerlink" title="RTCP(Real-time Transport Control Protocol)"></a>RTCP(Real-time Transport Control Protocol)</h2><p>传输协议</p><p> <code>RTCP</code>为<code>RTP</code>提供<code>流量控制</code>和<code>拥塞控制</code>。在RTP会话期间,各参与者周期性地传送RTCP包。</p><p> RTCP包中含有已发送的<strong>数据包的数量</strong>、<strong>丢失的数据包的数量</strong>等统计资料.因此,服务器可以利用这些信息动态地改变传输速率，甚至改变有效载荷类型。</p><p> RTP和RTCP配合使用，它们能以有效的反馈和最小的开销使传输效率最佳化。因而特别适合传送网上的实时数据。 </p><h2 id="RTSP（Real-time-Streaming-Protocol）"><a href="#RTSP（Real-time-Streaming-Protocol）" class="headerlink" title="RTSP（Real-time Streaming Protocol）"></a>RTSP（Real-time Streaming Protocol）</h2><h3 id="协议类型-1"><a href="#协议类型-1" class="headerlink" title="协议类型"></a>协议类型</h3><p>应用层协议</p><p>RTSP在体系结构上位于应用层，在RTP和RTCP之上, 它使用<code>TCP</code>或<code>RTP</code>完成数据传输。</p><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>当应用程序提供<code>RTSP协议</code>建立一个<code>RTP会话</code>时，应用程序将确定一对目的传输地址（一个网络地址和<code>两个端口号</code>），其中两个端口号中的<strong>偶数端口是分配给RTP进行裸码流数据传输</strong>的，<strong>奇数端口则是分配给RTCP进行传输控制</strong>的。</p><p>RTP的发送过程如下：</p><ol><li>从上层接收流媒体信息码流（如H.264），封装成RTP数据包；RTCP从上层接收控制信息，封装成RTCP控制包。</li><li>将RTP 数据包发往UDP端口对中偶数端口；RTCP将RTCP控制包发往UDP端口对中的接收端口。</li></ol><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>实时流媒体应用：<br>RTSP被广泛用于实时流媒体应用，包括在线广播、网络摄像头、监控摄像头、IPTV、视频会议、VoIP等。这些应用需要灵活控制流媒体会话，例如播放、暂停、停止、快进、快退等。</li><li><strong>网络摄像头和监控系统（安防领域）</strong>：<br>RTSP在网络摄像头和监控系统中应用广泛。它允许客户端在需要时连接到摄像头，开始流媒体传输，实时查看视频监控，并可以在不同时间点暂停或停止传输。</li><li>IPTV（互联网电视）：<br>RTSP在IPTV中用于控制和传输电视流。用户可以通过RTSP控制收看特定的频道、录制节目、调节播放参数等。RTSP的灵活性使其能够处理按需点播和直播内容。</li><li>多媒体内容点播：<br>在多媒体内容点播服务中，RTSP用于提供类似VCR的功能，包括快进、快退、跳转到特定位置等。它支持按需内容流传输和控制。</li><li>视频会议：<br>RTSP可以用于视频会议系统，提供会议中音频和视频流的控制。它允许用户加入会议、离开会议、调整传输参数等。</li><li>远程教育和在线学习：<br>RTSP在远程教育和在线学习环境中用于实时流媒体传输，帮助教师和学生进行互动。它可以用于播放课程视频、实时课堂、教学演示等。</li><li>企业内网广播：<br>企业可以使用RTSP进行内部广播，例如公司公告、培训课程、员工会议等。RTSP的灵活控制能力使其适用于内部流媒体传输。</li></ol><h3 id="其他问题-1"><a href="#其他问题-1" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="RTSP有握手过程吗？"><a href="#RTSP有握手过程吗？" class="headerlink" title="RTSP有握手过程吗？"></a>RTSP有握手过程吗？</h4><p>RTSP（Real-Time Streaming Protocol，实时流媒体传输协议）没有传统意义上的握手过程，如TCP的三次握手或类似于RTMP的握手机制。RTSP主要用于控制多媒体流的传输，提供了类似于HTTP的客户端-服务器交互机制，允许客户端发出控制命令来启动、停止或操纵媒体流。</p><p>尽管没有典型的握手过程，但RTSP的会话控制过程中涉及建立和维护会话，这包括发送初始请求（如SETUP）来创建一个会话，并使用会话标识符（Session ID）来跟踪会话状态。这一过程类似于HTTP的请求-响应模式，以下是一些常见的RTSP请求：</p><ol><li>OPTIONS：用于查询服务器支持的RTSP方法。</li><li>DESCRIBE：请求流媒体描述信息（如SDP，Session Description Protocol）。</li><li>SETUP：请求在特定的传输通道（如RTP&#x2F;UDP）上建立会话。</li><li>PLAY：启动媒体流的播放。</li><li>PAUSE：暂停媒体流的播放。</li><li>TEARDOWN：结束会话，释放资源。</li></ol><p>在这个过程中，RTSP会通过Session ID来维持会话的状态和唯一性，而不是通过类似握手的同步机制。RTSP的会话是无状态的，这意味着每个请求需要携带足够的上下文信息，以便服务器能够理解客户端的意图。</p><h2 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h2><h3 id="协议类型-2"><a href="#协议类型-2" class="headerlink" title="协议类型"></a>协议类型</h3><p>应用层协议</p><h3 id="工作机制-1"><a href="#工作机制-1" class="headerlink" title="工作机制"></a>工作机制</h3><p><img src="/2024/04/25/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/rtmp_1.png"></p><p>RTMP协议规定，播放一个流媒体有两个前提步骤：  </p><ol><li>建立一个网络连接（NetConnection）；  </li><li>建立一个网络流（NetStream）。</li></ol><p>其中，网络连接代表服务器端应用程序和客户端之间基础的连通关系。网络流代表了发送多媒体数据的通道。服务器和客户端之间只能建立一个网络连接，但是基于该连接可以创建很多网络流。</p><p>播放一个RTMP协议的流媒体需要经过以下几个步骤：握手，建立连接，建立流，播放。RTMP连接都是以握手作为开始的。建立连接阶段用于建立客户端与服务器之间的“网络连接”；建立流阶段用于建立客户端与服务器之间的“网络流”；播放阶段用于传输视音频数据。</p><p>握手过程：</p><ol><li>客户端握手 C0：<br>客户端发送 C0 消息，它包含协议版本（通常是 3）。</li><li>服务器响应 S0：<br>服务器接收 C0 后，发送 S0 消息，包含协议版本，通常与客户端的协议版本相同。</li><li>客户端握手 C1：<br>客户端发送 C1 消息，包含一个 1536 字节的随机数据和一个 4 字节的时间戳。这段随机数据用于后续的握手验证。</li><li>服务器响应 S1：<br>服务器接收 C1 后，发送 S1 消息。该消息也包含 1536 字节的随机数据和一个 4 字节的时间戳。服务器的随机数据是不同于客户端的，用于确保握手的随机性。</li><li>客户端握手 C2：<br>客户端发送 C2 消息，它包含 1536 字节的数据，这是之前服务器 S1 消息中的随机数据。通过这种方式，客户端表明它收到了服务器的响应，并且验证了握手的一致性。</li><li>服务器确认 S2：<br>服务器接收 C2 后，发送 S2 消息，该消息包含 1536 字节的数据，与客户端 C1 消息中的随机数据相同。通过这种方式，服务器验证了客户端的响应。</li></ol><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>直播流媒体：<br>RTMP 是一种流行的流媒体协议，广泛用于直播视频、音频流和实时聊天应用程序。其低延迟特性使其成为直播场景的热门选择，尤其是网络视频平台和直播节目。</li><li>实时互动：<br>由于 RTMP 的低延迟和可靠性，它在实时互动应用中被广泛使用，如在线游戏直播、视频通话、在线教学和网络研讨会。</li><li>内容分发网络 (CDN)：<br>RTMP 是许多内容分发网络用来在服务器之间传输实时流媒体的协议。CDN 使用 RTMP 将直播流分发到边缘节点，并通过其他协议（如 HLS 或 DASH）向客户端分发内容。</li><li>广播行业：<br>在广播行业，RTMP 仍然是流行的协议，用于将现场视频源传输到中央服务器，然后广播或流式传输给观众。</li><li>媒体制作与管理：<br>RTMP 通常用于将实时流媒体从摄像机或媒体制作工作站发送到视频制作软件和平台。这使得现场拍摄和实时编辑成为可能。</li><li>在线教育和网络研讨会：<br>RTMP 被用于实时传输视频和音频流，用于在线教育和网络研讨会。它的低延迟特性使其适合这种需要即时互动的场景。</li><li>社交媒体直播：<br>一些社交媒体平台支持 RTMP 协议，允许用户使用直播软件或硬件进行实时直播。</li></ol><h3 id="其他问题-2"><a href="#其他问题-2" class="headerlink" title="其他问题"></a>其他问题</h3><h2 id="HTTP-FLV-HTTP-Flash-Video"><a href="#HTTP-FLV-HTTP-Flash-Video" class="headerlink" title="HTTP-FLV (HTTP-Flash Video)"></a>HTTP-FLV (HTTP-Flash Video)</h2><h3 id="协议类型-3"><a href="#协议类型-3" class="headerlink" title="协议类型"></a>协议类型</h3><p>应用层协议<br>基于<code>HTTP</code>协议</p><h3 id="工作机制-2"><a href="#工作机制-2" class="headerlink" title="工作机制"></a>工作机制</h3><p>HTTP 协议中有个约定：<code>content-length</code>字段，http 的 body 部分的长度。</p><ul><li>服务器回复 http 请求的时候如果有这个字段，客户端就接收这个长度的数据然后就认为数据传输完成了。</li><li>如果服务器回复 http 请求中没有这个字段，客户端就一直接收数据，直到服务器跟客户端的 socket 连接断开。 (流式传输)</li></ul><p>http-flv 直播就是利用第二个原理，服务器回复客户端请求的时候不加 content-length 字段，在回复了 http 内容之后，紧接着发送 flv 数据，客户端就一直接收数据了。</p><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><p>网络直播：<br>HTTP-FLV 适合实时网络直播，因为它可以在客户端与服务器之间保持持续的连接，并即时传输数据。这种机制有助于减少延迟，实现实时直播。</p></li><li><p>视频点播：<br>HTTP-FLV 也可以用于点播内容的播放。通过 HTTP 的灵活性，服务器可以根据客户端的需求提供流媒体数据。</p></li><li><p>Web 视频播放：<br>HTTP-FLV 的兼容性使其适用于 Web 上的嵌入式视频播放，特别是在 Flash 时代流行的各种嵌入式视频播放器。</p></li></ol><h3 id="其他问题-3"><a href="#其他问题-3" class="headerlink" title="其他问题"></a>其他问题</h3><h2 id="HLS-HTTP-Live-Streaming"><a href="#HLS-HTTP-Live-Streaming" class="headerlink" title="HLS (HTTP Live Streaming)"></a>HLS (HTTP Live Streaming)</h2><p>HLS 是一种基于 HTTP 的流媒体传输协议，最初由苹果公司开发，现在是流媒体领域的一个广泛采用的协议。下面是对 HLS 协议的详解，包括其类型、工作机制、应用场景和其他常见问题。</p><h3 id="协议类型-4"><a href="#协议类型-4" class="headerlink" title="协议类型"></a>协议类型</h3><p>应用层协议<br>基于<code>HTTP</code>协议</p><h3 id="工作机制-3"><a href="#工作机制-3" class="headerlink" title="工作机制"></a>工作机制</h3><p>HLS 的核心机制是将音视频内容分段，然后通过 HTTP 请求进行传输和播放。其工作流程大致如下：</p><ol><li>内容分段：<br>源视频文件或直播流被切割成较小的段（segments），每个段通常几秒钟长，通常为 10 秒。</li><li>创建索引文件：<br>同时，生成一个索引文件（或称为清单文件、播放列表），通常是 .m3u8 文件。这个索引文件列出所有视频段的 URL，以及其他元数据，如时间戳、码率、分辨率等。</li><li>客户端播放：<br>客户端（通常是视频播放器或媒体播放软件）首先请求索引文件，然后根据索引文件中的信息，按顺序请求视频段，并进行播放。</li><li>可自适应的质量：<br>HLS 支持多种比特率和分辨率的视频段，客户端可以根据网络状况选择最佳的段以实现自适应流媒体（Adaptive Bitrate Streaming）。这种特性使 HLS 在不同带宽下都能保持较好的播放体验。</li><li>缓存和 CDN 支持：<br>由于 HLS 基于 HTTP 协议，网络基础设施中的缓存和 CDN（内容分发网络）可以有效地支持 HLS，从而提高流媒体传输的效率和可靠性。</li></ol><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>直播和广播：<br>HLS 被广泛用于直播活动、赛事转播等。</li><li>点播和回放：<br>HLS 也可用于点播内容或流媒体服务中的内容回放。</li><li>多平台兼容性：<br>由于 HLS 的 HTTP 基础，它在各种平台和设备上都可以使用，特别是在苹果生态系统中广泛支持。</li></ol><h3 id="其他问题-4"><a href="#其他问题-4" class="headerlink" title="其他问题"></a>其他问题</h3><h1 id="新兴流媒体协议"><a href="#新兴流媒体协议" class="headerlink" title="新兴流媒体协议"></a>新兴流媒体协议</h1><p>基于浏览器插件的老牌直播协议RTMP终于寿钟正寝，虽然各大CDN厂商还在坚持使用RTMP协议，但是也难逃被各大浏览器厂商淘汰的趋势和事实；<strong>RTSP主要应用于安防领域</strong>，而随之兴起流行的HTTP-FLV、HLS直播技术也因为延迟大，平台依赖性强，网络自适应差等问题饱受诟病。</p><p>而新兴的WEBRTC协议是专门基于网页js设计的及时音视频通信协议，其无插件的直播性能完全能满足流媒体直播的要求，而新兴的互联网90%的浏览流量都在浏览器上，所以WEBRTC是目前互联网直播协议中一种比较优质是选择。</p><h2 id="GB28181"><a href="#GB28181" class="headerlink" title="GB28181"></a>GB28181</h2><p>GB28181是中国国家标准编号，标题是“基于IP网络的安全防范视频监控联网系统信息传输、交换、控制技术要求”。这是一个中国国内的标准，主要用于安全防范和监控系统，确保不同制造商的设备在基于IP的网络环境下能够互操作。GB28181标准的主要用途在于公共安全和城市监控应用，例如公安、交通、社区等。</p><h3 id="协议类型-5"><a href="#协议类型-5" class="headerlink" title="协议类型"></a>协议类型</h3><p>GB28181规范了基于IP网络的安全防范视频监控联网系统的信息传输、交换、控制等技术要求。主要内容包括：</p><ol><li>通信协议：规定了信令和媒体传输协议，确保设备之间可以互操作。</li><li>媒体传输：定义了音视频流的传输方式，支持RTP、RTCP等。</li><li>控制信令：定义了设备的控制、管理、告警等功能，包括注册、注销、心跳等信令。</li><li>设备互操作性：确保不同厂商的设备能够在同一个网络环境下进行协作。</li></ol><h3 id="工作机制-4"><a href="#工作机制-4" class="headerlink" title="工作机制"></a>工作机制</h3><p>GB28181采用了标准的IP网络协议堆栈，通常基于<code>SIP（Session Initiation Protocol）</code>作为信令协议，使用<code>RTP（Real-time Transport Protocol）</code>传输音视频流。其工作机制大致如下：</p><ol><li>设备注册：<br>设备通过SIP向中央服务器注册，以便在网络中标识和管理。</li><li>媒体传输：<br>音视频流通过RTP传输，通常在局域网或广域网中传输监控内容。</li><li>设备控制：<br>中央服务器可以通过SIP信令向设备发送控制指令，例如摄像头的移动、变焦、聚焦等。</li><li>告警和心跳：<br>设备可以向服务器发送告警信息或心跳信号，确保系统状态正常。</li></ol><h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><p>主要应用于安全防范和视频监控领域</p><h3 id="其他问题-5"><a href="#其他问题-5" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="SIP（Session-Initiation-Protocol）与-SDP（Session-Description-Protocol）"><a href="#SIP（Session-Initiation-Protocol）与-SDP（Session-Description-Protocol）" class="headerlink" title="SIP（Session Initiation Protocol）与 SDP（Session Description Protocol）"></a>SIP（Session Initiation Protocol）与 SDP（Session Description Protocol）</h4><p>SIP 和 SDP 是用于通信领域的重要协议。虽然它们常常一起使用，但它们在功能和作用上有很大的区别。</p><ul><li><p>SIP<br>  SIP，全称 “Session Initiation Protocol”，是一种应用层协议，主要用于创建、修改和终止多媒体会话（如语音、视频、消息等）。它在网络电话、即时消息、视频会议、流媒体等应用中广泛使用。SIP 的核心功能包括：</p><ol><li>会话建立：通过邀请消息（INVITE）和应答消息等建立会话。</li><li>会话修改：在会话进行过程中调整会话的参数，例如添加或移除媒体流。</li><li>会话终止：通过发送 BYE 消息来结束会话。</li></ol><p>  SIP 使用请求-响应模型，类似于 HTTP，并支持多种传输协议（例如，UDP、TCP、TLS）。SIP 不定义实际传输的数据，而是处理与会话控制相关的信令。</p></li><li><p>SDP<br>  SDP，全称 “Session Description Protocol”，是一种用于描述多媒体会话参数的协议。它通常与 SIP 一起使用，用于描述会话的相关信息。<br>  SDP 描述的内容包括：</p><ol><li>会话名称和目的：用于标识会话。</li><li>时间信息：表明会话何时开始和结束。</li><li>媒体描述：包括媒体类型、传输协议、端口号、编解码器等。</li><li>连接信息：表明会话在哪个网络地址进行。</li></ol><p>  SDP 的结构通常是文本格式的，易于解析和生成。它在 SIP 消息中常见，特别是用于描述会话的媒体属性。在 SIP 中，SDP 通常包含在 INVITE 请求和应答消息中，用于协商通信双方如何交换媒体流。</p></li><li><p>关系<br>  SIP 和 SDP 的关系可以概括为：</p><ul><li>SIP 负责建立、修改和终止会话，是一种用于信令和控制的协议。</li><li>SDP 用于描述会话的细节，包括媒体类型、传输参数和编解码器等，是一种描述性协议。</li></ul><p>  在 SIP 会话的建立过程中，SDP 通常作为 SIP 消息的一部分，以描述会话的详细信息。在 SIP 会话中，SDP 的使用是为了协商会话双方的媒体参数，确保能够正确交换媒体流。</p></li></ul><h2 id="WebRTC（Web-Real-Time-Communication）"><a href="#WebRTC（Web-Real-Time-Communication）" class="headerlink" title="WebRTC（Web Real-Time Communication）"></a>WebRTC（Web Real-Time Communication）</h2><p>WebRTC 是一种开放框架，用于在网络应用程序和网站之间实现实时通信。它是一个基于浏览器的技术，使开发人员能够创建语音、视频和数据的实时通信应用，而无需用户下载任何插件或第三方软件。</p><h3 id="协议类型-6"><a href="#协议类型-6" class="headerlink" title="协议类型"></a>协议类型</h3><p>WebRTC 包含一系列协议、API 和标准，用于实现实时通信。主要涉及的协议包括：</p><ol><li>ICE（Interactive Connectivity Establishment）：<br>用于发现和连接两个端点之间的最优路径。</li><li>STUN（Session Traversal Utilities for NAT）：<br>用于找到对等方的公共 IP 地址。</li><li>TURN（Traversal Using Relays around NAT）：<br>用于在直接连接不可能时，通过中继服务器传递数据。</li><li>SRTP（Secure Real-time Transport Protocol）：<br>用于安全的音视频传输。</li><li>DTLS（Datagram Transport Layer Security）：<br>为 WebRTC 提供安全性和数据加密。</li></ol><h3 id="工作机制-5"><a href="#工作机制-5" class="headerlink" title="工作机制"></a>工作机制</h3><p>WebRTC 的工作机制主要包括以下几个步骤：</p><ol><li>信令（Signaling）：<br>这是一种用于建立 WebRTC 会话的过程，包括会话初始化、设备协商和连接管理。信令本身不属于 WebRTC 的规范范围，开发人员可以使用任意方法实现，例如 WebSockets 或其他协议。</li><li>连接建立：<br>通过 ICE 协商，确定最合适的路径。过程中使用 STUN 和 TURN 来处理 NAT 和防火墙问题。</li><li>安全通信：<br>通过 DTLS 和 SRTP，确保音视频数据在传输过程中保持加密和安全。</li><li>媒体和数据通道：<br>建立后，WebRTC 可以在对等端之间传输音频、视频和数据。数据通道允许任意二进制或文本数据的传输，适用于多种应用场景。</li></ol><p>工作流程：<br><img src="/2024/04/25/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/gb28181.png" alt="工作流程"></p><h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>视频通话和语音通话：用于在浏览器中创建实时音视频通话应用，如视频会议、在线教育等。</li><li>实时数据传输：可用于文件共享、在线游戏、协作应用等。</li><li>直播流媒体：WebRTC 可以用于低延迟直播或点对点流媒体传输。</li></ol><h3 id="其他问题-6"><a href="#其他问题-6" class="headerlink" title="其他问题"></a>其他问题</h3>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传输协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我遇到过的疑难杂症</title>
      <link href="/2024/04/17/%E6%88%91%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
      <url>/2024/04/17/%E6%88%91%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/</url>
      
        <content type="html"><![CDATA[<h1 id="我遇到过的疑难杂症"><a href="#我遇到过的疑难杂症" class="headerlink" title="我遇到过的疑难杂症"></a>我遇到过的疑难杂症</h1><h2 id="单片机上跑的udp程序突然崩溃"><a href="#单片机上跑的udp程序突然崩溃" class="headerlink" title="单片机上跑的udp程序突然崩溃"></a>单片机上跑的udp程序突然崩溃</h2><p>同事使用C语言写了个udp程序，与我的服务通信，逻辑是他起一个socket，向我发送数据，我回复OK。<br>一开始工作正常，但是一段时间后他的程序崩溃。<br>经排查，是因为他没有写<code>recv()</code>函数，且一直<code>复用的同一个socket</code>。数据到达后，没处理，堆积在缓冲区导致错误。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg使用说明</title>
      <link href="/2024/04/14/FFmpeg%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2024/04/14/FFmpeg%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="FFmpeg使用说明"><a href="#FFmpeg使用说明" class="headerlink" title="FFmpeg使用说明"></a>FFmpeg使用说明</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="封装格式-编码格式-协议"><a href="#封装格式-编码格式-协议" class="headerlink" title="封装格式 编码格式 协议"></a>封装格式 编码格式 协议</h3><p><img src="/2024/04/14/FFmpeg%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/avpack.png"></p><ul><li>封装格式：MP4</li><li>编码格式：H.264</li><li>协议：RTMP</li></ul><h3 id="音／视频流"><a href="#音／视频流" class="headerlink" title="音／视频流"></a>音／视频流</h3><p>在音视频领域，我们把一路音／视频称为一路流。如我们小时候经常使用VCD看港片，在里边可以选择粤语或国语声音，其实就是CD视频文件中存放了两路音频流，用户可以选择其中一路进行播放。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>我们一般把 MP4､ FLV、MOV等文件格式称之为容器。也就是在这些常用格式文件中，可以存放多路音视频文件。以 MP4 为例，就可以存放一路视频流，多路音频流，多路字幕流。</p><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>channel是音频中的概念，称之为声道。在一路音频流中，可以有单声道，双声道或立体声。</p><h3 id="视频解码"><a href="#视频解码" class="headerlink" title="视频解码"></a>视频解码</h3><p>视频解码是将视频压缩编码后的数据流（例如 H.264、H.265 等）解码成原始的像素数据（通常是 YUV 格式），以便于显示或进一步处理的过程。在视频编码中，为了减小文件大小和提高传输效率，视频数据经过压缩编码处理，即将原始的视频数据压缩成较小的码流。而视频解码则是将这些压缩后的数据流还原成原始的视频像素数据，以便于播放或后续处理。</p><ul><li><p>硬解码：</p><p>  硬解码是利用专用的硬件解码器（通常是 GPU）来解码音视频流。硬解码器通常集成在显卡或其他专用的硬件设备中，能够高效地处理音视频解码任务。硬解码器通常支持多种音视频编解码器，并能够通过硬件加速来实现高效的解码性能。由于硬解码利用专用的硬件资源，因此能够在低功耗的情况下实现高效的解码，适用于移动设备、嵌入式系统和高性能计算环境等场景。</p></li><li><p>软解码：</p><p>  软解码是利用通用的处理器（如 CPU）来解码音视频流。软解码器是通过软件实现的音视频解码算法，不依赖于专用的硬件设备。软解码器通常运行在通用的计算机系统上，利用 CPU 的计算能力来进行音视频解码。软解码虽然不具备硬解码那样的硬件加速能力，但能够在普通的计算机系统上运行，并且通常具有更好的兼容性和灵活性。软解码适用于各种计算环境，但在解码大尺寸、高码率的高清视频时可能会受到性能限制。</p></li><li><p>H.265 相比于 H.264 具有更高的压缩效率和更高的视频质量，但也需要更多的计算资源来进行编码。因此，在选择编码标准时，需要根据具体的应用场景和需求权衡各种因素。</p></li></ul><h3 id="DTS与PTS"><a href="#DTS与PTS" class="headerlink" title="DTS与PTS"></a>DTS与PTS</h3><p>DTS（Decoding Time Stamp）和 PTS（Presentation Time Stamp）是用于管理音视频流中时间信息的两种时间戳。</p><ol><li><p>DTS（解码时间戳）：</p><ul><li>DTS 表示数据在解码器中解码的时间点。它指示了数据在解码器中被解码的时间，即解码器何时开始处理数据。</li><li>对于视频流，DTS 表示视频帧被解码的时间点。</li><li>对于音频流，DTS 表示音频样本被解码的时间点。</li></ul></li><li><p>PTS（显示时间戳）：</p><ul><li>PTS 表示数据在播放器中显示的时间点。它指示了数据在播放器中何时被呈现给用户。</li><li>对于视频流，PTS 表示视频帧被显示的时间点。</li><li>对于音频流，PTS 表示音频样本被播放的时间点。</li></ul></li></ol><p>通常情况下，音视频数据在传输过程中可能会发生延迟或者重排列，DTS 和 PTS 用于确保数据能够在正确的时间点被解码和显示，以保证音视频同步以及顺畅播放。PTS 必须始终晚于或等于 DTS，以确保数据按正确的顺序呈现。</p><h3 id="常见分辨率"><a href="#常见分辨率" class="headerlink" title="常见分辨率"></a>常见分辨率</h3><p>3840<em>2160 (4K)<br>2560</em>1440 (2K)<br>1920<em>1080 (1080P 高清 200万像素)<br>1280</em>720 (720P)<br>640*360 (360P)</p><p>除了1080P还有1080I<br>这里的P和I分别表示逐行扫描与隔行扫描<br>电视一般用I 网络视频，视频文件用P</p><h3 id="dpi"><a href="#dpi" class="headerlink" title="dpi"></a>dpi</h3><p>每英寸像素</p><h3 id="色彩空间模型"><a href="#色彩空间模型" class="headerlink" title="色彩空间模型"></a>色彩空间模型</h3><p>记录像素点色彩数据的方式<br>有RGB，YUV420，YUV422，YUV444，HSV，CMYK</p><p>网络视频一般使用<code>YUV420</code><br>虽然颜色有所失真，但是数据量少</p><h3 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h3><p>一秒的视频帧数（FPS）</p><p>网络视频一般为25FPS、30FPS</p><p>过高的帧率在感官上不会有所提升，反而影响性能</p><h3 id="码率"><a href="#码率" class="headerlink" title="码率"></a>码率</h3><ul><li>一秒的数据量大小，单位Mbps</li><li>码率的设置是为了限制数据量过大，防止客户端带宽不足而产生卡顿</li><li>编码器会根据最大码率对视频进行有损压缩</li></ul><h3 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h3><blockquote><p>GOP一般是H.264，H.265这些编码格式才有的概念<br>GOP（Group of Pictures）是视频编码中的一个重要概念，它定义了一组连续的视频帧，这些帧之间存在特定的时间关系，用于视频压缩编码和解码。</p></blockquote><p>一个 GOP 包含以下类型的帧：</p><ol><li><p>I帧（Intra-coded Frame）：</p><p> I帧是一个关键帧，它是完整的帧，不依赖于其他帧进行解码。在编码器中，I帧通过对整个帧进行压缩编码，以保留最大的图像信息，从而提供了视频的基础图像。解码器可以利用I帧进行随机访问和解码。</p></li><li><p>P帧（Predictive-coded Frame）：</p><p> P帧是通过对前向预测（从前面的I帧或P帧中预测）进行压缩编码得到的。它只包含当前帧和之前帧之间的差异数据，而不包含整个图像数据。P帧可以通过参考之前的I帧或P帧来解码。</p></li><li><p>B帧（Bidirectional-coded Frame）：</p><p> B帧是通过对前向和后向预测（从前面的I帧或P帧以及后面的P帧中预测）进行压缩编码得到的。它包含当前帧和前后帧之间的差异数据，能够进一步提高视频的压缩比和质量。B帧需要参考前后的I帧或P帧来解码。</p><p> 由于需要根据后向的帧进行推理，所以在<code>直播流等场景下，是不产生B帧的</code>，使直播流畅。</p></li></ol><p>GOP 的结构通常如下所示：</p><pre><code class="css">I P P P B B P P P B B P P ...</code></pre><p>其中，每个GOP以一个I帧开始，后面跟随一系列的P帧和B帧。GOP的长度（即包含的帧数）可以根据具体的编码设置进行调整，常见的GOP长度为 15、30、60 等。较长的GOP长度可以提高压缩效率，但会增加视频的延迟和解码复杂度；而较短的GOP长度可以提高视频的抗干扰能力和随机访问性能，但会降低压缩效率。因此，在实际应用中，需要根据视频的特性和需求来选择合适的GOP长度。</p><ul><li><p>在线播放场景  </p><ul><li>一般不必关心GOP  </li><li>为了防止未加载完跳转卡顿时间长等问题–&gt;<code>因为两个I帧间隔过长</code>  </li><li>可以将GOP设置为帧率的4-5倍</li></ul></li><li><p>直播场景</p><ul><li>流媒体服务器设置缓存I帧</li><li>GOP设置为帧率的1-2倍</li><li>禁止生成B帧</li></ul></li></ul><h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><ul><li><p>具体的编码过程由编码格式决定</p></li><li><p>每个编码格式对应不同的压缩&#x2F;解压缩算法</p></li><li><p>每个编码格式对应不同的编码器&#x2F;解码器</p></li><li><p>客户端没有对应编码格式的解码器，是播不出视频的</p></li><li><p>只有对视频文件大小产生影响的参数才会作用与<code>编码阶段</code>，如码率，最大码率等，限制文件的大小，可能会发生有损压缩</p></li><li><p>分辨率，帧率等参数是由<code>转码程序</code>完成的，编码器不支持这些修改</p></li></ul><h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><ul><li>当前一刻的声音样本</li><li>真实声音虽然是连续的，但是在计算机中，声音是离散且均匀的声音样本</li></ul><h3 id="位深度"><a href="#位深度" class="headerlink" title="位深度"></a>位深度</h3><p>音频的位深度是指用于表示<code>每个采样值的比特数</code>。它决定了每个采样值可以表示的幅度范围，也影响了音频的动态范围和信噪比。</p><p>常见的位深度包括 8 位、16 位、24 位和 32 位等。较低的位深度会限制音频信号的动态范围，可能导致信号的失真和噪声的增加，特别是在低音量或者动态范围较大的场景下。相反，较高的位深度可以提供更广阔的动态范围和更低的噪声水平，因此产生更高质量的音频。</p><p>一般来说，16 位的位深度已经能够满足大多数音频应用的要求，包括 CD 音质和广播。24 位的位深度被认为是高保真音频的标准，它提供了更高的动态范围和更低的噪声水平，因此在专业录音和音乐制作中被广泛使用。32 位的位深度通常用于一些特殊需求，如音频处理中的临时计算过程，但在存储和传输过程中会转换为较低的位深度。</p><h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><p>采样率（也称为采样频率）是指在一段时间内对模拟信号进行采样的频率，通常用赫兹（Hz）来表示。在数字音频处理中，采样率决定了每秒钟采集的采样数，它是一个非常重要的参数，直接影响到数字音频的质量和精度。</p><p>常见的音频采样率包括：</p><ol><li>8 kHz：音频通话或监控录音。</li><li>22.05 kHz、24 kHz：FM调频广播。</li><li>44.1 kHz：这是最常用的音频采样率之一，用于 CD 音质。在音频 CD 中，每秒钟采集 44100 个样本。</li><li>48 kHz：这是另一个常见的音频采样率，用于广播、电影和多媒体制作等领域。</li><li>96 kHz、192 kHz：这些是高保真音频的采样率，用于专业音频录制和制作，它们提供了更高的音频质量和更广阔的频率范围。</li></ol><p>较高的采样率可以提供更高的音频质量和更广泛的频率响应范围，因为它们能够更准确地捕捉音频信号的细节。然而，高采样率也会导致更大的数据量和更高的处理需求。</p><p>选择合适的采样率取决于具体的应用需求。对于一般的音频播放和日常录制，通常使用标准的采样率（如 44.1 kHz 或 48 kHz）即可满足需求。而在专业音频制作和高保真音频领域，可能会选择更高的采样率以获得更高的音频质量。</p><h3 id="音频帧"><a href="#音频帧" class="headerlink" title="音频帧"></a>音频帧</h3><p>将一小段音频采样数据打包在一起</p><p>具体时间跨度由编码格式决定</p><h3 id="音频码率"><a href="#音频码率" class="headerlink" title="音频码率"></a>音频码率</h3><p>一般网络音频直播，音频文件，码率在128Kbps即可</p><h3 id="常用音视频编码标准"><a href="#常用音视频编码标准" class="headerlink" title="常用音视频编码标准"></a>常用音视频编码标准</h3><table><thead><tr><th>名称</th><th>推出机构</th><th>推出时间</th><th>目前使用领域</th></tr></thead><tbody><tr><td>HEVC（H.265）</td><td>MPEG&#x2F;ITU-T</td><td>2013</td><td>新王</td></tr><tr><td>H.264</td><td>MPEG&#x2F;ITU-T</td><td>2003</td><td>各个领域</td></tr><tr><td>MPEG4</td><td>MPEG</td><td>2001</td><td>不温不火</td></tr><tr><td>MPEG2</td><td>MPEG</td><td>1994</td><td>数字电视</td></tr><tr><td>VP9</td><td>Google</td><td>2013</td><td>不温不火</td></tr><tr><td>VP8</td><td>Google</td><td>2008</td><td>不普及</td></tr><tr><td>VC-1</td><td>Microsoft Inc.</td><td>2006</td><td>微软平台</td></tr></tbody></table><table><thead><tr><th>名称</th><th>推出机构</th><th>推出时间</th><th>目前使用领域</th><th>损失</th></tr></thead><tbody><tr><td>AAC</td><td>MPEG</td><td>1997</td><td>各个领域（新）</td><td>有损</td></tr><tr><td>MP3</td><td>MPEG</td><td>1993</td><td>各个领域（旧）</td><td>有损</td></tr><tr><td>FLAC</td><td>Josh Coalson</td><td>2001</td><td>数字音乐市场</td><td>无损</td></tr><tr><td>WAV</td><td>Microsoft 和 IBM</td><td>1991</td><td>音频处理和专业音乐制作领域</td><td>无损</td></tr></tbody></table><h3 id="常用协议与编码汇总"><a href="#常用协议与编码汇总" class="headerlink" title="常用协议与编码汇总"></a>常用协议与编码汇总</h3><p>见pdf</p><h3 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h3><p>OpenGL（Open Graphics Library）是一种用于渲染 2D 和 3D 矢量图形的跨平台图形 API（应用程序编程接口）。它允许开发人员通过编程方式创建高性能的图形应用程序，如视频游戏、模拟器、CAD 软件等。</p><p>OpenGL 由一个庞大的函数库组成，开发人员可以使用这些函数来执行各种图形操作，包括顶点操作、纹理映射、光照、投影等。它提供了一系列功能，使开发人员能够利用计算机的图形硬件来加速图形处理。OpenGL 是一种底层的图形 API，它提供了对图形硬件的直接访问，因此可以在不同的操作系统和硬件平台上实现高性能的图形渲染。</p><p>由于其跨平台特性和高性能，OpenGL 在计算机图形领域得到了广泛的应用。它被用于开发各种类型的图形应用程序，包括游戏、CAD 软件、虚拟现实应用程序、科学可视化工具等。OpenGL 是一个开放标准，由 Khronos Group 维护和推动发展，因此在不同的操作系统和硬件平台上都有相应的实现版本。</p><h3 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h3><p>OpenCV（Open Source Computer Vision Library）是一个开源的计算机视觉和图像处理库，提供了丰富的函数和工具，用于处理图像和视频数据。它由一系列 C++、Python、Java 等语言的函数库和模块组成，可以在各种平台上运行，包括 Windows、Linux、macOS 等。</p><p>OpenCV 提供了丰富的图像处理和计算机视觉功能，包括但不限于：</p><ol><li>图像读取和保存：支持读取和保存多种格式的图像文件，如 JPEG、PNG、BMP 等。</li><li>图像处理：包括图像变换、颜色空间转换、滤波、边缘检测、形态学操作等。</li><li>特征检测和描述：提供了多种特征检测和描述算法，如 Harris 角点检测、SIFT、SURF、ORB 等。</li><li>目标检测和跟踪：包括 Haar 特征、HOG 特征、卷积神经网络（CNN）等目标检测算法。</li><li>视频分析：提供了视频读取、视频流处理、光流估计、运动检测等功能。</li><li>机器学习：提供了一些基本的机器学习算法和工具，如支持向量机（SVM）、K近邻（KNN）等。</li></ol><p>OpenCV 是一个非常强大和广泛应用的图像处理库，被广泛应用于计算机视觉、图像处理、机器人、自动驾驶等领域。它被许多研究人员、工程师和开发者使用，并在学术界和工业界都有着广泛的影响。</p><h3 id="直播流常用协议"><a href="#直播流常用协议" class="headerlink" title="直播流常用协议"></a>直播流常用协议</h3><ol><li><p>RTMP、HTTP-FLV</p><ul><li>RTMP：<ul><li>一般用于直播源推流，直播系统内直播流数据传递。</li><li>浏览器摒弃了Flash播放器，且据说高并发下rtmp会有问题，所以不用于拉流。</li><li>建立在TCP之上。</li><li>延迟低：1-3s。</li><li>变种RTMPT、RTMPS等。</li></ul></li><li>HTTP-FLV：一般用于客户端直播流观看。<ul><li>网页需要引入flv.js才可播放该类型流。</li><li>延迟比RTMP略高。</li></ul></li><li>二者都是在FLV封装格式基础上的。</li><li>现在比较流行的方案是，直播源推流是RTMP协议，直播拉流观看是HTTP-FLV协议。</li></ul></li><li><p>HLS（HTTP Live Streaming）</p><ul><li><p>HLS协议一般只用作拉流观看，但是从严格意义上讲，HLS协议并不是流式协议。</p></li><li><p>它工作原理很简单，就是通过HTTP协议下载静态文件。</p></li><li><p>不同的是，HLS协议的文件由两部分组成，一是多个只有几秒长度的.ts碎片视频文件，另一个是记录这些视频文件地址的.m3u8索引文件，且这些静态文件都是直接写入磁盘的。</p></li><li><p>更具体的说，HLS观看地址是以http:&#x2F;&#x2F;开头、.m3u8结尾的，实际上这个地址就是索引文件的地址，客户端获取到索引文件后，就可以下载对应的碎片视频文件并开始播放了。</p></li><li><p>由于HLS协议实际上是通过HTTP协议请求文件的，且HLS相关文件是直接写入磁盘的，所以并不需要特殊的流媒体服务软件，使用Nginx等HTTP服务就可以了。</p></li><li><p>点播的场景下，也就是普通网络视频观看的场景下。.m3u8索引文件会记录所有的碎片视频文件地址，HLS在点播的场景下，优势是更加明显的。HLS协议的点播视频，会比.mp4、.flv的视频更快地播放出来，且在加载中跳转视频也会更加顺滑。</p></li><li><p>HLS协议在直播的场景下是没什么优势的。虽然HLS协议的直播流也可以适配很多播放场景，但是由于需要生成静态文件，直播延迟很大，大概在5-30秒左右，使用直播CDN的话，由于边缘节点同步等问题，直播延迟甚至可能会达到1分钟左右。</p></li><li><p>当然HLS协议也有一定的优势，在直播时移，也就是直播转点播，或者录播，也就是点播转直播的场景， 理论上只需要修改索引文件就可以了。</p></li></ul></li><li><p>WebRTC</p><ul><li><p>WebRTC协议其实并不是为了直播场景而设计的，WebRTC是一种点对点的视频&#x2F;语音通话协议。</p></li><li><p>由于WebRTC是基于UDP的，建立通信后，会不断以流式发送数据，所以延迟会比RTMP还要低。</p></li><li><p>在一些交互性较高的直播场景，如直播带货等场景，会使用WebRTC作为推流和观看协议 WebRTC的延迟理论上可以达到1秒内。</p></li></ul></li><li><p>RTSP</p><ul><li><p>RTSP一般不用作直播场景，RTSP一般用作摄像头、监控等硬件设备的实时视频流观看与推送上。</p></li><li><p>尽管RTSP协议也支持推流&#x2F;拉流，且支持TCP、UDP切换以及其他诸多优点。但是泛用性不足，特别是现在的浏览器都不支持RTSP的播放。</p></li></ul></li></ol><h3 id="点播封装格式"><a href="#点播封装格式" class="headerlink" title="点播封装格式"></a>点播封装格式</h3><p>MP4：适合在线播放视频不是主营业务的网站系统<br>FLV：适合短视频，小文件偏多的网站系统<br>HLS：适合长视频，大文件偏多的网站系统</p><h3 id="音频重采样"><a href="#音频重采样" class="headerlink" title="音频重采样"></a>音频重采样</h3><p>音频重采样是指将音频信号从一个采样率转换为另一个采样率的过程。采样率是指每秒对音频信号进行采样的次数，通常以赫兹（Hz）为单位。音频重采样可能涉及改变采样率、通道数、位深度等参数。</p><p>音频重采样可能需要的几种情况包括：</p><ul><li><p><strong>播放器与音频设备之间的不匹配</strong>：音频设备通常有其支持的固定采样率，如果要播放的音频数据的采样率与设备不匹配，就需要对音频数据进行重采样以适应设备的要求。</p></li><li><p><strong>音频数据源与目标之间的不匹配</strong>：从不同来源获取的音频数据可能具有不同的采样率，例如，网络音频流的采样率可能与本地音频设备的采样率不同，因此需要对音频数据进行重采样以使其匹配。</p></li><li><p><strong>音频处理过程中的采样率变化</strong>：在音频处理中，可能需要对音频数据进行采样率变换，以进行滤波、混音等处理，或者将音频与视频进行同步。</p></li><li><p><strong>音频合成</strong>：将多个来源的音频数据合成为一个音频流时，可能需要对其中一个或多个音频流进行重采样，以使其具有相同的采样率和其他参数。</p></li></ul><p>重采样的过程通常涉及<code>插值</code>、<code>抽取</code>或<code>过滤</code>等技术，以确保在转换过程中尽量减少失真和伪像。总的来说，音频重采样是一个常见的音频处理过程，可以帮助解决音频数据之间的不匹配问题，保证音频数据的质量和一致性。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="ffplay播放器流程"><a href="#ffplay播放器流程" class="headerlink" title="ffplay播放器流程"></a>ffplay播放器流程</h3><p><img src="/2024/04/14/FFmpeg%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/ffplay_flow.png"></p><h3 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h3><ul><li>libavcodec : 编&#x2F;解码</li><li>libavdevice : 设备视频文件的封装&#x2F;解封装</li><li>libavfilter : 帧级操作（如添加滤镜）</li><li>libavformat : 文件 I&#x2F;O 和 封装&#x2F;解封装</li><li>libavutil : 通用工具集合</li><li>libpostproc : 预处理</li><li>libswresample : 音频重采样、格式处理、混音等</li><li>libswscale : 色彩处理和缩放</li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>我们按使用目的可以将 FFMPEG 命令分成以下几类：</p><ul><li><p>基本信息查询命令</p></li><li><p>录制</p></li><li><p>分解&#x2F;复用</p></li><li><p>处理原始数据</p></li><li><p>滤镜</p></li><li><p>切割与合并</p></li><li><p>图／视互转</p></li><li><p>直播相关</p></li></ul><p>除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。<br><img src="/2024/04/14/FFmpeg%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/ffmpeg_flow.png"></p><ol><li><p>（demuxer）打开输入文件，解封装，从容器格式中分离出音频、视频：</p><p> 使用 FFmpeg 提供的 API 或命令行工具，打开要处理的输入文件。输入文件可以是音频文件、视频文件或者其他多媒体格式。</p></li><li><p>（decode）解码音视频数据：</p><p> 从输入文件中读取音视频数据，并进行解码。对于音频数据，通常使用音频解码器进行解码，得到原始的音频样本数据。对于视频数据，使用视频解码器进行解码，得到原始的视频帧数据。</p></li><li><p>（encode）进行处理并编码处理后的音视频数据：</p><p> 对音频数据和视频数据进行需要的处理，例如音频处理、视频处理、滤镜处理等。可以根据需要应用各种效果、转码、裁剪、缩放等操作。</p><p> 将处理后的音频数据和视频数据进行编码。对音频数据使用音频编码器进行编码，得到编码后的音频数据。对视频数据使用视频编码器进行编码，得到编码后的视频数据。</p></li><li><p>（muxer）混流，封装编码后的音视频数据：</p><p> 将编码后的音频数据和视频数据封装到容器格式中，生成最终的输出文件。可以选择不同的容器格式，如 MP4、AVI、FLV、MKV 等。</p></li></ol><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用说明</title>
      <link href="/2024/04/14/Git%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2024/04/14/Git%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="Git使用说明"><a href="#Git使用说明" class="headerlink" title="Git使用说明"></a>Git使用说明</h1><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>Git 提供了一个叫做<code>git config</code>的工具，专门用来配置或读取相应的工作环境变量。</p><p>这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p><ul><li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。</li><li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。</li><li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git&#x2F;config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git&#x2F;config 里的配置会覆盖 &#x2F;etc&#x2F;gitconfig 中的同名变量。</li></ul><p>在 Windows 系统上，Git 会找寻用户主目录下的 <code>.gitconfig</code>文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings$USER。</p><p>此外，Git 还会尝试找寻 &#x2F;etc&#x2F;gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>配置个人的用户名称和电子邮件地址：</p><pre><code class="bash">git config --global user.name &quot;huahua&quot;git config --global user.email test@huahua.com</code></pre><p>如果用了<code>--global</code>选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。</p><p>如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git&#x2F;config 文件里。</p><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：:</p><pre><code class="bash">git config --global core.editor emacs</code></pre><h3 id="差异分析工具"><a href="#差异分析工具" class="headerlink" title="差异分析工具"></a>差异分析工具</h3><p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p><pre><code class="bash">git config --global merge.tool vimdiff</code></pre><p>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。</p><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><p>要检查已有的配置信息，可以使用<code>git config --list</code>命令：</p><pre><code class="bash">git config --listhttp.postbuffer=2Muser.name=huahuauser.email=test@huahua.com</code></pre><p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 &#x2F;etc&#x2F;gitconfig 和 ~&#x2F;.gitconfig），不过最终 Git 实际采用的是最后一个。</p><p>这些配置我们也可以在 ~&#x2F;.gitconfig 或 &#x2F;etc&#x2F;gitconfig 看到，如下所示：</p><pre><code>vim ~/.gitconfig </code></pre><p>显示内容如下所示：</p><pre><code>[http]    postBuffer = 2M[user]    name = runoob    email = test@runoob.com</code></pre><p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：</p><pre><code>$ git config user.namehuahua</code></pre><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="创建仓库命令"><a href="#创建仓库命令" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h3><p>下表列出了 git 创建仓库的命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>git init</td><td>初始化仓库</td></tr><tr><td>git clone</td><td>拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table><h3 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h3><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><p>下表列出了有关创建与提交你的项目的快照的命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>git add</td><td>添加文件到暂存区</td></tr><tr><td>git status</td><td>查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td>git diff</td><td>比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td>git commit</td><td>提交暂存区到本地仓库。</td></tr><tr><td>git reset</td><td>回退版本。</td></tr><tr><td>git rm</td><td>将文件从暂存区和工作区中删除。</td></tr><tr><td>git mv</td><td>移动或重命名工作区文件。</td></tr><tr><td>git checkout</td><td>分支切换。</td></tr><tr><td>git switch （Git 2.23 版本引入）</td><td>更清晰地切换分支。</td></tr><tr><td>git restore （Git 2.23 版本引入）</td><td>恢复或撤销文件的更改。</td></tr></tbody></table><h3 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>git log</td><td>查看历史提交记录</td></tr><tr><td>git blame <file></file></td><td>以列表形式查看指定文件的历史修改记录</td></tr></tbody></table><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>git remote</td><td>远程仓库操作</td></tr><tr><td>git fetch</td><td>从远程获取代码库</td></tr><tr><td>git pull</td><td>下载远程代码并合并</td></tr><tr><td>git push</td><td>上传远程代码并合并</td></tr></tbody></table><h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h2><h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><ol><li>查看标签</li></ol><pre><code class="bash">git tag</code></pre><ol start="2"><li>打标签</li></ol><pre><code class="bash">git tag -a &lt;tagname&gt; -m &quot;tag desc&quot;</code></pre><h3 id="创建新分支并推送到远程仓库"><a href="#创建新分支并推送到远程仓库" class="headerlink" title="创建新分支并推送到远程仓库"></a>创建新分支并推送到远程仓库</h3><ol><li><p>创建新分支：</p><p> 首先，使用 Git 命令创建新的分支。假设要创建一个名为 new-feature 的新分支，可以使用以下命令：</p><pre><code class="bash">git checkout -b new-feature</code></pre><p> 这将创建一个名为 new-feature 的新分支，并将当前分支切换到该分支。</p></li><li><p>在新分支上进行工作：</p><p> 在新分支上进行修改、添加新文件等工作，完成新功能的开发或修改。</p></li><li><p>将新分支推送到远程仓库：</p><p> 使用 git push 命令将新创建的分支推送到远程仓库。如果远程仓库中还不存在该分支，可以使用 -u 选项将本地分支与远程分支关联起来。假设远程仓库名为 origin，可以使用以下命令：</p><pre><code class="bash">git push -u origin new-feature</code></pre><p> 这将把名为 new-feature 的新分支推送到远程仓库，并与远程仓库的同名分支关联起来。</p></li></ol><h3 id="设置上游分支"><a href="#设置上游分支" class="headerlink" title="设置上游分支"></a>设置上游分支</h3><ol><li><p>首先，打开命令行或终端窗口，进入你想要设置上游分支的本地仓库目录。</p></li><li><p>使用以下命令将远程仓库添加为上游分支：</p></li></ol><pre><code class="bash">git remote add upstream &lt;远程仓库URL&gt;</code></pre><ol start="3"><li>使用以下命令来验证上游分支是否设置成功：</li></ol><pre><code class="bash">git remote -v</code></pre><p>这个命令会列出所有与本地仓库相关联的远程仓库，包括上游分支。</p><ol start="4"><li>如果你希望从上游分支获取更新，可以使用以下命令：</li></ol><pre><code class="bash">git fetch upstream</code></pre><p>这个命令会从上游分支获取最新的提交。</p><ol start="5"><li>如果你想要将上游分支合并到你的本地分支中，可以使用以下命令：</li></ol><pre><code class="bash">git merge upstream/&lt;分支名&gt;</code></pre><p>这里的&lt;分支名&gt;是指上游分支的具体名称，例如main、master等。</p><h3 id="查找提交日志"><a href="#查找提交日志" class="headerlink" title="查找提交日志"></a>查找提交日志</h3><pre><code class="bash">git log --grep=&#39;xxx&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2024/04/13/MySQL/"/>
      <url>/2024/04/13/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="1-关系型和非关系型数据库的区别你了解多少？"><a href="#1-关系型和非关系型数据库的区别你了解多少？" class="headerlink" title="1.关系型和非关系型数据库的区别你了解多少？"></a>1.关系型和非关系型数据库的区别你了解多少？</h2><ul><li>关系型数据库的优点<ul><li>容易理解。因为它采用了关系模型来组织数据。</li><li>可以保持数据的一致性。</li><li>数据更新的开销比较小。</li><li>支持复杂查询（带where子句的查询）</li></ul></li><li>非关系型数据库的优点<ul><li>不需要经过SQL层的解析，读写效率高。</li><li>基于键值对，数据的扩展性很好。</li><li>可以支持多种类型数据的存储，如图片，文档等等。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 通用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2024/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1-HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）"><a href="#1-HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）" class="headerlink" title="1.HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）"></a>1.HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）</h2><ol><li><p>客户端Hello: 客户端向服务器发送一个消息，其中包含SSL版本、加密算法等信息。</p></li><li><p>服务器Hello: 服务器接收到客户端的消息后，选择加密算法，并向客户端发送确认信息，也包含了服务器的SSL证书。</p></li><li><p>证书验证: 客户端收到服务器发送的SSL证书后，验证其有效性。这包括检查证书是否由受信任的证书颁发机构（CA）签发，以及检查证书是否已过期或被撤销。</p></li><li><p>生成共享密钥: 客户端生成一个随机的对称密钥，用于加密通信。该密钥将使用服务器的公钥加密，并发送给服务器。</p></li><li><p>密钥交换: 服务器使用其私钥解密客户端发送的共享密钥。</p></li><li><p>握手完成: 至此，SSL握手完成。双方现在都具有了用于加密和解密通信的共享密钥，可以开始安全地进行数据传输。</p></li></ol><p>因为数字签名、摘要是证书防伪非常关键的武器。 “摘要”就是对传输的内容，通过hash算法计算出一段固定长度的串。然后，通过发送方的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名”</p><p>SSL&#x2F;TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><blockquote><p>补充：SSL&#x2F;TLS的四次握手，目前网上的主流答案都在重复阮一峰老师的博客，属于TLS 1.0版本的答案，使用RSA密钥交换算法。但是现在TLS 1.2已经成为主流，使用<code>ECDHE算法</code>，如果面试可以说出这个版本的答案，应该会更好。</p></blockquote><h2 id="2-如何保证公钥不被篡改？"><a href="#2-如何保证公钥不被篡改？" class="headerlink" title="2.如何保证公钥不被篡改？"></a>2.如何保证公钥不被篡改？</h2><p>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p><h2 id="3-Cookie是什么？"><a href="#3-Cookie是什么？" class="headerlink" title="3.Cookie是什么？"></a>3.Cookie是什么？</h2><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务，HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。</p><p>新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><p>cookie 的出现是因为 HTTP 是无状态的一种协议，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，cookie 的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够 cookie 认出你。</p><h2 id="4-Session知识大总结"><a href="#4-Session知识大总结" class="headerlink" title="4.Session知识大总结"></a>4.Session知识大总结</h2><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>使用 Session 维护用户登录状态的过程如下：</p><ol><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。<blockquote><p>注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p></blockquote></li></ol><h2 id="5-Cookie与Session的对比"><a href="#5-Cookie与Session的对比" class="headerlink" title="5.Cookie与Session的对比"></a>5.Cookie与Session的对比</h2><p>HTTP作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下Cookie和Session。</p><ul><li><p><strong>Cookie</strong><br>  Cookie是客户端保持状态的方法。  </p><p>  Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。</p><p>  除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。</p></li><li><p><strong>Session</strong>  </p><p>  Session是服务器保持状态的方法。</p><p>  首先需要明确的是，Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。</p></li></ul><p>当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了Cookie，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如sid&#x3D;xxxxx这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了。</p><h2 id="6-SQL注入攻击了解吗？"><a href="#6-SQL注入攻击了解吗？" class="headerlink" title="6.SQL注入攻击了解吗？"></a>6.SQL注入攻击了解吗？</h2><p>攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。 用户登录，输入用户名 lianggzone，密码 ‘ or ‘1’&#x3D;’1 ，如果此时使用参数构造的方式，就会出现 select * from user where name &#x3D; ‘lianggzone’ and password &#x3D; ‘’ or ‘1’&#x3D;‘1’ 不管用户名和密码是什么内容，使查询出来的用户列表不为空。如何防范SQL注入攻击使用预编译的PrepareStatement是必须的，但是一般我们会从两个方面同时入手。 </p><ol><li>Web端 <ul><li>有效性检验。</li><li>限制字符串输入的长度。</li></ul></li><li>服务端 <ul><li>不用拼接SQL字符串。</li><li>使用预编译的PrepareStatement。 </li><li>有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求) </li><li>过滤SQL需要的参数中的特殊字符。比如单引号、双引号。</li></ul></li></ol><h2 id="7-网络的七层模型与各自的功能"><a href="#7-网络的七层模型与各自的功能" class="headerlink" title="7.网络的七层模型与各自的功能"></a>7.网络的七层模型与各自的功能</h2><p><img src="/2024/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI1.png"><br><img src="/2024/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI2.png"></p><h2 id="8-什么是DHCP？工作原理？"><a href="#8-什么是DHCP？工作原理？" class="headerlink" title="8.什么是DHCP？工作原理？"></a>8.什么是DHCP？工作原理？</h2><p>DHCP（Dynamic Host Configuration Protocol）是一种网络协议，用于动态分配IP地址以及其他网络配置信息给计算机、网络设备和其他客户端设备。DHCP的主要作用是简化网络管理，提供灵活的IP地址分配方案，并降低了网络配置的复杂性。</p><p>以下是DHCP的基本工作原理：</p><ol><li><p>客户端请求：当一个设备加入网络或者需要更新网络配置时，它会向网络中的DHCP服务器发送一个 DHCP 请求。</p></li><li><p>DHCP Discover（发现）：客户端发送一个广播消息到网络上的所有DHCP服务器，请求IP地址分配和其他配置信息。这个消息称为 DHCP Discover 报文。</p></li><li><p>DHCP Offer（提供）：DHCP服务器收到客户端的 DHCP Discover 请求后，会回复一个 DHCP Offer 报文，其中包含了可用的IP地址以及其他配置信息，如子网掩码、默认网关、DNS服务器等。通常情况下，网络中可能有多个DHCP服务器，但是客户端只会选择其中一个DHCP Offer。</p></li><li><p>DHCP Request（请求）：客户端选择一个DHCP Offer，并向提供这个 Offer 的DHCP服务器发送一个 DHCP Request 报文，确认并请求分配相应的IP地址和配置信息。</p></li><li><p>DHCP Acknowledgment（确认）：DHCP服务器收到客户端的 DHCP Request 后，会向客户端发送一个 DHCP Acknowledgment 报文，确认分配给客户端的IP地址和配置信息。同时，DHCP服务器会在自己的地址租用表中记录下客户端的分配情况，以便将来的续约和管理。</p></li><li><p>IP地址租用：客户端在收到 DHCP Acknowledgment 后，会配置自己的网络接口，使用分配到的IP地址和其他配置信息进行通信。分配给客户端的IP地址是有限期的，称为租用期，一般在一段时间后过期。在IP地址租用期内，客户端可以使用这个IP地址。当租用期快要到期时，客户端可以向DHCP服务器发送续约请求，以延长租用期。</p></li></ol><p>通过DHCP，网络管理员可以集中管理IP地址和其他网络配置信息，动态地为网络中的设备分配IP地址，从而提高了网络的灵活性和可管理性。</p><h2 id="9-DNS查询方式有哪些？"><a href="#9-DNS查询方式有哪些？" class="headerlink" title="9.DNS查询方式有哪些？"></a>9.DNS查询方式有哪些？</h2><ul><li><p>递归解析<br>当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。</p></li><li><p>迭代解析<br>当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。</p></li></ul><h2 id="10-HTTP中缓存的私有和共有字段？知道吗？"><a href="#10-HTTP中缓存的私有和共有字段？知道吗？" class="headerlink" title="10.HTTP中缓存的私有和共有字段？知道吗？"></a>10.HTTP中缓存的私有和共有字段？知道吗？</h2><ul><li>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</li></ul><pre><code>Cache-Control: private</code></pre><ul><li>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</li></ul><pre><code>Cache-Control: public</code></pre><h2 id="11-GET-方法参数写法是固定的吗？"><a href="#11-GET-方法参数写法是固定的吗？" class="headerlink" title="11.GET 方法参数写法是固定的吗？"></a>11.GET 方法参数写法是固定的吗？</h2><p>在约定中，我们的参数是写在 ? 后面，用 &amp; 分割。</p><p>我们知道，解析报文的过程是通过获取 TCP 数据，用正则等工具从数据中获取 Header 和 Body，从而提取参数。</p><p>比如header请求头中添加token，来验证用户是否登录等权限问题。</p><p>也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行，万变不离其宗。</p><h2 id="12-GET-方法的长度限制是怎么回事？"><a href="#12-GET-方法的长度限制是怎么回事？" class="headerlink" title="12.GET 方法的长度限制是怎么回事？"></a>12.GET 方法的长度限制是怎么回事？</h2><p>网络上都会提到浏览器地址栏输入的参数是有限的。</p><p>首先说明一点，HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。</p><p>浏览器原因就不说了，服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。</p><h2 id="13-DDoS-攻击"><a href="#13-DDoS-攻击" class="headerlink" title="13.DDoS 攻击"></a>13.DDoS 攻击</h2><blockquote><p>DoS（Denial of Service）与DDoS（Distributed Denial of Service）区别，DOS是单一源，DDOS是分布式。</p></blockquote><p>DDoS（Distributed Denial of Service）攻击是一种网络攻击，旨在使目标系统无法提供正常的服务。在 DDoS 攻击中，攻击者利用大量的计算机或设备，通过同时向目标系统发送大量的请求或数据流量，耗尽目标系统的网络带宽、计算资源或其他系统资源，从而使其无法正常工作或提供服务。</p><p>以下是 DDoS 攻击的一般工作原理和特点：</p><ol><li><p>分布式攻击：DDoS 攻击通常利用大量分布在不同地理位置的计算机或设备，通过这些分布式的攻击节点向目标系统发起攻击。这些攻击节点被攻击者控制，组成了一个庞大的攻击网络。</p></li><li><p>洪水式攻击：DDoS 攻击通常采用洪水式（Flood）攻击方法，向目标系统发送大量的无效请求或数据包，以耗尽目标系统的网络带宽和资源。这些请求可能是 HTTP 请求、UDP 数据包、TCP SYN 数据包等。</p></li><li><p>层次化攻击：DDoS 攻击可以针对目标系统的不同层次进行攻击，包括网络层、传输层和应用层。例如，网络层攻击可以是对网络带宽的洪水攻击，传输层攻击可以是对 TCP 连接的 SYN 攻击，应用层攻击可以是对 Web 服务器的 HTTP 请求洪水攻击。</p></li><li><p>伪装和欺骗：攻击者可能会伪装攻击流量的源地址，使得目标系统难以识别和过滤攻击流量。此外，攻击者可能会利用反射攻击或放大攻击来增加攻击流量的规模。</p></li><li><p>目标多样性：DDoS 攻击的目标可以是任何连接到互联网的系统，包括网站、服务器、网络设备、云服务等。攻击目标通常是具有重要性或影响力的系统，以实现攻击者的目的。</p></li></ol><p>为了应对 DDoS 攻击，组织和个人可以采取各种防御措施，包括网络流量过滤、入侵检测和防御系统（IDS&#x2F;IPS）、使用 CDN（内容分发网络）、增强系统的容错性和弹性等。</p><h2 id="14-MTU和MSS分别是什么？"><a href="#14-MTU和MSS分别是什么？" class="headerlink" title="14.MTU和MSS分别是什么？"></a>14.MTU和MSS分别是什么？</h2><ul><li><p>MTU（Maximum Transmission Unit）是指在计算机网络中，数据链路层或网络层可以传输的最大数据包大小。简单来说，它表示在某个网络上一次能够传输的最大数据量，以字节为单位。MTU 的大小取决于网络技术和设备的规范，不同类型的网络通常具有不同的 MTU 值。</p></li><li><p>MSS（Maximum Segment Size）是指在 TCP 协议中，TCP 数据包中的 TCP 数据段的最大允许大小。由于在 TCP 通信中，数据通常被分割成多个 TCP 数据段进行传输，而每个 TCP 数据段的大小受限于 MTU 大小，因此 MSS 通常是 <code>MTU 减去 TCP 头部和 IP 头部的大小</code>。MSS 可以通过 TCP 握手阶段进行协商，并在后续的 TCP 通信中被使用。</p></li></ul><p>总的来说，MTU 表示网络传输中数据包的最大大小，而 MSS 表示 TCP 数据包中 TCP 数据段的最大大小。MTU 和 MSS 在网络通信中扮演着重要的角色，特别是在处理分段和分包的过程中。</p><h2 id="15-TCP头部中有哪些信息？"><a href="#15-TCP头部中有哪些信息？" class="headerlink" title="15.TCP头部中有哪些信息？"></a>15.TCP头部中有哪些信息？</h2><ol><li><p>源端口（Source Port）：占 16 位，用于标识发送方的端口号。</p></li><li><p>目标端口（Destination Port）：占 16 位，用于标识接收方的端口号。</p></li><li><p>序列号（Sequence Number）：占 32 位，用于标识 TCP 报文段中第一个数据字节的序号。序列号用于 TCP 的可靠传输机制，用于对报文段进行排序和重组。</p></li><li><p>确认号（Acknowledgment Number）：占 32 位，用于指示期望接收的下一个序列号。确认号用于 TCP 的可靠传输机制，用于确认接收到的报文段。</p></li><li><p>数据偏移（Data Offset）：占 4 位，表示 TCP 头部的长度，以 4 字节为单位。由于 TCP 头部长度可变，因此需要该字段来指示 TCP 头部的结束位置。</p></li><li><p>保留（Reserved）：占 6 位，保留用于将来的扩展。</p></li><li><p>控制标志（Flags）：包括以下控制标志，每个标志占 1 位：<br> URG：紧急指针（Urgent Pointer）有效。<br> ACK：确认序号有效。<br> PSH：推送数据。<br> RST：重置连接。<br> SYN：发起连接。<br> FIN：结束连接。  </p></li><li><p>窗口大小（Window Size）：占 16 位，用于指示发送方的接收窗口大小。接收窗口大小用于流量控制，用于指示发送方可以发送多少数据而不会导致接收方溢出。</p></li><li><p>校验和（Checksum）：占 16 位，用于检测 TCP 报文段是否在传输过程中发生了错误。</p></li><li><p>紧急指针（Urgent Pointer）：占 16 位，仅当 URG 标志被设置时有效。用于指示紧急数据的结束位置。</p></li><li><p>选项（Options）：可选字段，用于在 TCP 报文段中包含一些可选的信息，如最大报文段大小（MSS）、窗口扩大因子等。</p></li></ol><p>这些信息字段中的大多数都是 TCP 协议用于控制连接的传输过程和维护连接状态的。通过这些信息字段，TCP 协议能够提供可靠的、有序的、全双工的数据传输服务。</p><h2 id="16-常见TCP的连接状态有哪些？"><a href="#16-常见TCP的连接状态有哪些？" class="headerlink" title="16.常见TCP的连接状态有哪些？"></a>16.常见TCP的连接状态有哪些？</h2><ol><li><p>CLOSED（关闭）：初始状态，表示连接未被建立或已经终止。</p></li><li><p>LISTEN（监听）：服务器进入此状态，等待客户端连接请求。</p></li><li><p>SYN_SENT（同步已发送）：客户端发送SYN报文段以启动连接请求，并等待服务器的确认。</p></li><li><p>SYN_RECEIVED（同步已接收）：服务器收到客户端的SYN报文段，并发送自己的SYN和ACK报文段，以确认连接请求。</p></li><li><p>ESTABLISHED（已建立）：连接已经建立，双方可以进行数据传输。</p></li><li><p>FIN_WAIT_1（终止等待1）：客户端发送FIN报文段以关闭连接，等待服务器的确认。</p></li><li><p>FIN_WAIT_2（终止等待2）：客户端已经收到了服务器的确认，等待服务器发送自己的FIN报文段。</p></li><li><p>CLOSE_WAIT（关闭等待）：服务器收到客户端的FIN报文段，并发送自己的确认，等待客户端关闭连接。</p></li><li><p>CLOSING（关闭中）：双方同时发送了FIN报文段，等待对方的确认。</p></li><li><p>LAST_ACK（最后确认）：服务器发送FIN报文段，等待客户端的确认。</p></li><li><p>TIME_WAIT（时间等待）：连接已经关闭，等待可能延迟的数据报文段在网络中消失。这是为了防止出现重复的数据包，通常会在一段时间后自动释放。</p></li><li><p>CLOSE（关闭）：最终状态，连接已经完全关闭。</p></li></ol><p>这些状态描述了TCP连接在建立、数据传输和终止过程中的各种状态转换。不同的状态之间的转换是通过发送特定的TCP报文段来实现的。</p><h2 id="17-应用层常见协议知道多少？了解几个？"><a href="#17-应用层常见协议知道多少？了解几个？" class="headerlink" title="17.应用层常见协议知道多少？了解几个？"></a>17.应用层常见协议知道多少？了解几个？</h2><table><thead><tr><th>协议</th><th>名称</th><th>默认端口</th><th>底层协议</th></tr></thead><tbody><tr><td>HTTP</td><td>超文本传输协议</td><td>80</td><td>TCP</td></tr><tr><td>HTTPS</td><td>超文本传输安全协议</td><td>443</td><td>TCP</td></tr><tr><td>Telnet</td><td>远程登录服务的标准协议</td><td>23</td><td>TCP</td></tr><tr><td>FTP</td><td>文件传输协议</td><td>20传输和21连接</td><td>TCP</td></tr><tr><td>TFTP</td><td>简单文件传输协议</td><td>69</td><td>UDP</td></tr><tr><td>SMTP</td><td>简单邮件传输协议（发送用）</td><td>25</td><td>TCP</td></tr><tr><td>POP</td><td>邮局协议（接收用）</td><td>110</td><td>TCP</td></tr><tr><td>DNS</td><td>域名解析服务</td><td>53</td><td>服务器间进行域传输的时候用TCP 客户端查询DNS服务器时用 UDP</td></tr></tbody></table><h2 id="18-浏览器在与服务器建立了一个-TCP-连接后是否会在一个-HTTP-请求完成后断开？什么情况下会断开？"><a href="#18-浏览器在与服务器建立了一个-TCP-连接后是否会在一个-HTTP-请求完成后断开？什么情况下会断开？" class="headerlink" title="18.浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？"></a>18.浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</h2><p>在 HTTP&#x2F;1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 Connection: keep-alive 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免。</p><p>持久连接：既然维持 TCP 连接好处这么多，HTTP&#x2F;1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。</p><p>默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。</p><h2 id="19-三次握手"><a href="#19-三次握手" class="headerlink" title="19.三次握手"></a>19.三次握手</h2><p><img src="/2024/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/handshake.png"></p><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态，进行三次握手：</p><ul><li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 <code>SYN_SEND</code> 状态。</p><p>  首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</p></li><li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <code>SYN_RCVD</code> 的状态。</p><p>  在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</p></li><li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <code>ESTABLISHED</code> 状态。服务器收到 ACK 报文之后，也处于 <code>ESTABLISHED</code> 状态，此时，双方已建立起了连接。</p><p>  确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p></li></ul><p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p><p>在socket编程中，客户端执行connect()时，将触发三次握手。</p><h2 id="20-什么是半连接队列？"><a href="#20-什么是半连接队列？" class="headerlink" title="20.什么是半连接队列？"></a>20.什么是半连接队列？</h2><p>半连接队列（Half-open connection queue），也称为半连接队列或半打开连接队列，是指TCP协议中用于存放未完成三次握手过程的连接请求的队列。在TCP的三次握手握手过程中，当客户端向服务器发送SYN报文段（同步序列号），服务器收到后会回复一个SYN+ACK报文段（同步序列号+确认序号），此时连接处于半开（Half-open）状态。在正常情况下，服务器会等待客户端发送最后的ACK报文段以完成握手，建立完全的TCP连接。</p><p><code>半连接队列</code>的作用是临时存放未完成的连接请求，等待服务器进程处理。当服务器的连接请求队列已满或者服务器进程无法及时处理连接请求时，新的连接请求将会被放置在半连接队列中，暂时保持半开状态。一旦服务器进程准备好处理连接请求，它会从半连接队列中取出连接请求，完成后续的握手过程，建立完整的TCP连接。</p><p>半连接队列的大小是有限制的，通常由操作系统的配置参数决定。如果半连接队列已满而新的连接请求到达，则服务器会拒绝这些连接请求，导致客户端收到连接超时或拒绝连接的错误。因此，合理调整半连接队列的大小对于保障服务器的稳定运行至关重要。</p><h2 id="21-ISN-Initial-Sequence-Number-是固定的吗？"><a href="#21-ISN-Initial-Sequence-Number-是固定的吗？" class="headerlink" title="21. ISN(Initial Sequence Number)是固定的吗？"></a>21. ISN(Initial Sequence Number)是固定的吗？</h2><p>不，ISN（Initial Sequence Number）并不是固定的，它是在建立TCP连接时动态生成的一个随机值。ISN的目的是确保每个TCP连接都有一个唯一的起始序号，以防止重放攻击等安全问题。</p><blockquote><p>重放攻击是一种常见的网络攻击方式，攻击者通过截获和重新发送先前成功的通信数据包，以达到非法获取信息、欺骗系统或者拒绝服务的目的。</p></blockquote><p>在TCP连接的建立过程中，客户端和服务器各自选择一个ISN值。通常情况下，ISN是基于当前的时间戳和一些其他随机因素生成的，这样可以尽可能地避免ISN的重复和可预测性。</p><p>通过随机生成ISN，可以增加攻击者猜测ISN的难度，提高TCP连接的安全性。如果ISN是固定的或者可预测的，攻击者可能会利用这个信息来实施攻击，例如重放攻击、序列号猜测攻击等。因此，生成随机的ISN对于TCP连接的安全性至关重要。</p><h2 id="22-三次握手过程中可以携带数据吗？"><a href="#22-三次握手过程中可以携带数据吗？" class="headerlink" title="22.三次握手过程中可以携带数据吗？"></a>22.三次握手过程中可以携带数据吗？</h2><p>在TCP的三次握手过程中，通常不会携带数据。三次握手的主要目的是建立起客户端和服务器之间的连接，并协商一些连接参数，例如序列号等。</p><p>虽然报文段中会携带一些连接参数，但通常不会携带实际的数据。这是因为在三次握手过程中，客户端和服务器还没有建立起完全的TCP连接，因此还不能进行数据传输。只有在三次握手完成后，建立了完整的TCP连接之后，客户端和服务器才能开始进行数据传输。</p><p>并且，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>然而，在某些情况下，TCP协议的实现可能允许在三次握手的过程中携带少量的数据，这通常被称为<code>零窗口探测</code>。零窗口探测是为了解决一些特殊情况下的问题，例如当客户端和服务器都处于空闲状态，但服务器需要客户端发送一些数据来更新连接状态。在这种情况下，服务器可能会允许在SYN和SYN+ACK报文段中携带少量的数据。</p><h2 id="23-SYN攻击是什么？"><a href="#23-SYN攻击是什么？" class="headerlink" title="23.SYN攻击是什么？"></a>23.SYN攻击是什么？</h2><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 <code>DoS/DDoS</code> 攻击。</p><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux&#x2F;Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p><pre><code class="bash">netstat -n -p TCP | grep SYN_RECV</code></pre><p>常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）时间  </li><li>增加最大半连接数  </li><li>过滤网关防护  </li><li>SYN cookies技术</li></ul><h2 id="24-四次挥手相关内容"><a href="#24-四次挥手相关内容" class="headerlink" title="24.四次挥手相关内容"></a>24.四次挥手相关内容</h2><p><img src="/2024/04/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wave.png"><br>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的<code>半关闭</code>，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p><ol><li><p>第一次挥手（FIN1）：发送方（一般是客户端）向接收方（一般是服务器）发送一个FIN（Finish）报文段，表示发送方已经完成数据的发送，但仍然可以接收数据。</p></li><li><p>第二次挥手（ACK1）：接收方收到第一次挥手的FIN报文段后，会发送一个ACK（Acknowledgment）报文段作为确认，表示已经收到了发送方的关闭请求，并且同意关闭连接。</p></li><li><p>第三次挥手（FIN2）：接收方也可以在发送第二次挥手的ACK报文段之后，向发送方发送一个FIN报文段，表示接收方也已经完成数据的发送，但仍然可以接收数据。</p></li><li><p>第四次挥手（ACK2）：发送方收到第三次挥手的FIN报文段后，会发送一个ACK报文段作为确认，表示已经收到了接收方的关闭请求，并且同意关闭连接。此时连接处于完全关闭状态，双方都不再发送数据。</p></li></ol><p>需要注意的是，四次挥手过程中的ACK报文段可能携带数据，用于确认收到上一步的挥手请求。在第三次挥手和第四次挥手过程中，ACK报文段可以携带之前接收到的最后一批数据的确认序号。</p><p>四次挥手的目的是确保双方都能够确认连接的关闭，并且在关闭之前完成所有的数据传输。这个过程可以防止连接过早地关闭，导致数据丢失或者中断。</p><h2 id="25-对于FIN-WAIT-2，CLOSE-WAIT状态和TIME-WAIT状态？你知道多少"><a href="#25-对于FIN-WAIT-2，CLOSE-WAIT状态和TIME-WAIT状态？你知道多少" class="headerlink" title="25.对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？你知道多少?"></a>25.对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？你知道多少?</h2><ol><li><p>FIN_WAIT_2：</p><ul><li><p>半关闭状态。</p></li><li><p>发送断开请求一方还有接收数据能力，但已经没有发送数据能力。</p></li></ul></li><li><p>CLOSE_WAIT状态：</p><ul><li><p>被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。</p></li><li><p>被动关闭连接一方如果还有剩余数据要发送就会进入CLOSE_WAIT状态。</p></li></ul></li><li><p>TIME_WAIT状态：</p><ul><li>又叫2MSL等待状态。</li><li>如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。</li><li>在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。</li></ul></li></ol><h2 id="26-为什么挥手需要四次"><a href="#26-为什么挥手需要四次" class="headerlink" title="26.为什么挥手需要四次"></a>26.为什么挥手需要四次</h2><p>TCP连接的关闭需要四次挥手的原因是为了确保双方都能够确认连接的关闭，并且在关闭之前完成所有的数据传输。这个过程涉及到双向数据传输的结束和连接状态的维护，需要一定的步骤来完成。</p><h2 id="27-2MSL等待状态"><a href="#27-2MSL等待状态" class="headerlink" title="27.2MSL等待状态"></a>27.2MSL等待状态</h2><blockquote><p>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p></blockquote><p>2MSL（Two Maximum Segment Lifetime）是TCP连接的最长生存时间，通常用来确定连接处于TIME_WAIT状态的持续时间。</p><p>在TCP连接的关闭过程中，当发送方发送了最后一个ACK报文段后，连接会进入<code>TIME_WAIT</code>状态，等待<code>2MSL</code>时间。这个等待时间的目的是<strong>确保在网络中的所有数据报文段都已经被丢弃，以防止这些报文段在网络中仍然存在，并可能被之后建立的连接误认为是当前连接的报文段，导致数据传输错误</strong>。</p><p>2MSL的时间是两个报文段的最长生存时间（Maximum Segment Lifetime）的两倍。在一般情况下，<strong>MSL是一个IP数据报文段在网络中可以存活的最长时间，它通常被设置为路由器或其他网络设备的缓存时间</strong>。因此，2MSL就是为了确保在TIME_WAIT状态期间，网络中的所有数据报文段都被丢弃，而不会误认为是当前连接的数据。</p><p>在TIME_WAIT状态期间，连接的相关资源（如端口号等）仍然被保留，以防止之后建立的连接使用相同的资源造成冲突。在2MSL等待时间结束后，连接的资源会被释放，连接完全关闭。</p><h2 id="28-为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？"><a href="#28-为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？" class="headerlink" title="28.为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？"></a>28.为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</h2><p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><h2 id="29-TCP粘包问题是什么？你会如何去解决它？"><a href="#29-TCP粘包问题是什么？你会如何去解决它？" class="headerlink" title="29.TCP粘包问题是什么？你会如何去解决它？"></a>29.TCP粘包问题是什么？你会如何去解决它？</h2><p>TCP粘包问题是指在TCP通信过程中，发送方连续发送的数据包在接收方处被合并成一个或多个大的数据包，导致接收方无法正确解析和处理。这种情况可能会发生在<code>数据包到达接收方时的缓冲区合并过程中</code>，造成数据粘在一起而无法分割开。</p><p>TCP粘包问题可能由于多种因素引起，包括<code>网络传输过程中的延迟</code>、<code>缓冲区大小设置不合理</code>、<code>发送方数据包大小不一致</code>等。</p><p>解决TCP粘包问题的方法主要包括以下几种：</p><ul><li><p>消息边界标记：在数据包中添加特定的边界标记或者长度字段，用于标识消息的开始和结束。接收方根据这些标记来正确分割接收到的数据，以确保每个消息被正确处理。</p></li><li><p>固定长度消息：发送方将每个消息固定长度进行发送，接收方按照固定的长度来接收和处理消息，无需额外的边界标记。</p></li><li><p>消息头中包含消息长度：在消息头中包含消息的长度信息，接收方先读取消息长度，然后按照消息长度读取数据，确保每个消息都被正确处理。</p></li><li><p>使用应用层协议：使用更高层次的应用层协议，如HTTP、WebSocket等，这些协议通常有自己的消息分割规则，可以帮助解决粘包问题。</p></li><li><p>缓冲区调优：调整接收方的缓冲区大小，使其能够容纳更大的数据量，减少发生粘包的可能性。</p></li><li><p>时间间隔控制：发送方发送数据时，可以通过控制发送数据的时间间隔，或者发送数据的速率来减少粘包发生的频率。</p></li></ul><h2 id="30-HTTPS采用的加密方式有哪些？是对称还是非对称？"><a href="#30-HTTPS采用的加密方式有哪些？是对称还是非对称？" class="headerlink" title="30.HTTPS采用的加密方式有哪些？是对称还是非对称？"></a>30.HTTPS采用的加密方式有哪些？是对称还是非对称？</h2><p>HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。</p><h2 id="31-网络层常见协议？可以说一下吗？"><a href="#31-网络层常见协议？可以说一下吗？" class="headerlink" title="31.网络层常见协议？可以说一下吗？"></a>31.网络层常见协议？可以说一下吗？</h2><table><thead><tr><th>协议</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>IP</td><td>网际协议</td><td>IP协议不但定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择</td></tr><tr><td>ICMP</td><td>Internet控制报文协议</td><td>ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性，是ping和traceroute的工作协议</td></tr><tr><td>RIP</td><td>路由信息协议</td><td>使用“跳数”(即metric)来衡量到达目标地址的路由距离</td></tr><tr><td>IGMP</td><td>Internet组管理协议</td><td>用于实现组播、广播等通信</td></tr></tbody></table><h2 id="32-TCP四大拥塞控制算法总结"><a href="#32-TCP四大拥塞控制算法总结" class="headerlink" title="32.TCP四大拥塞控制算法总结"></a>32.TCP四大拥塞控制算法总结</h2><p>TCP拥塞控制算法是用于在网络拥塞情况下调整TCP连接的发送速率，以避免网络拥塞并提高网络性能的一组算法。四大拥塞控制算法包括：<code>慢启动</code>、<code>拥塞避免</code>、<code>快重传</code>、<code>快恢复</code>。下面是对这四个算法的简要总结：</p><ol><li><p>慢启动（Slow Start）：</p><ul><li>慢启动算法用于在连接启动时快速增加发送速率，以尽快填满网络的可用带宽。</li><li>当连接开始时，发送方将初始拥塞窗口设置为一个较小的值（通常是1个或者几个报文段大小），然后在每次收到对应的ACK确认时，将拥塞窗口大小翻倍。</li><li>慢启动算法的目标是快速探测到可用的带宽，并尽快将发送速率提高到一个合适的水平。</li></ul></li><li><p>拥塞避免（Congestion Avoidance）：</p><ul><li>拥塞避免算法用于在慢启动阶段结束后，以一种较为谨慎的方式继续增加发送速率，以避免引起网络拥塞。</li><li>在拥塞避免阶段，发送方将拥塞窗口以线性增长的方式增加，而不是指数增长。</li><li>拥塞避免算法的目标是逐渐增加发送速率，同时观察网络的拥塞情况并避免触发网络拥塞。</li></ul></li><li><p>快重传（Fast Retransmit）：</p><ul><li>快重传算法用于快速检测和恢复丢失的数据报文段，以避免等待超时重传带来的长延迟。</li><li>当发送方收到连续的三个相同的ACK确认时，说明前面的一个报文段丢失了，发送方会立即重传该丢失的报文段，而不必等待超时定时器触发。</li></ul></li><li><p>快恢复（Fast Recovery）：</p><ul><li>快恢复算法用于在发生快重传后，有效地降低拥塞窗口，以减少丢失报文段引起的网络拥塞。</li><li>当发送方收到三个重复的ACK确认时，不仅触发快重传，还会将拥塞窗口减半，并且进入快恢复状态。</li><li>在快恢复状态中，发送方将拥塞窗口设置为拥塞避免阈值的一半，并开始以拥塞避免算法的方式增加拥塞窗口。</li></ul></li></ol><h2 id="33-为何快速重传是选择3次ACK？"><a href="#33-为何快速重传是选择3次ACK？" class="headerlink" title="33.为何快速重传是选择3次ACK？"></a>33.为何快速重传是选择3次ACK？</h2><p>主要的考虑还是要区分包的丢失是由于链路故障还是乱序等其他因素引发。</p><p>两次duplicated ACK时很可能是乱序造成的！三次duplicated ACK时很可能是丢包造成的！四次duplicated ACK更更更可能是丢包造成的，但是这样的响应策略太慢。丢包肯定会造成三次duplicated ACK!综上是选择收到三个重复确认时窗口减半效果最好，这是实践经验。</p><h2 id="34-TCP-协议如何保证可靠传输？"><a href="#34-TCP-协议如何保证可靠传输？" class="headerlink" title="34.TCP 协议如何保证可靠传输？"></a>34.TCP 协议如何保证可靠传输？</h2><p>TCP（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层协议。TCP保证可靠传输的主要机制包括：</p><ol><li><p>确认和重传机制：</p><p> TCP使用确认和重传机制来确保数据的可靠传输。接收方收到数据后会向发送方发送确认消息（ACK），表示已成功接收数据。如果发送方在一定时间内未收到确认消息，会认为数据丢失，并触发数据的重传机制，重新发送丢失的数据。</p></li><li><p>序号和确认号：</p><p> TCP使用序号（Sequence Number）和确认号（Acknowledgment Number）来标识数据包的顺序和确认情况。发送方将每个数据包标记上唯一的序号，接收方在收到数据包后会将确认号设置为下一个期望接收的序号。通过序号和确认号的配对，TCP可以实现对数据传输的准确追踪和控制。</p></li><li><p>滑动窗口：</p><p> TCP使用滑动窗口协议来实现流量控制和可靠传输。发送方和接收方维护一个窗口大小，用来控制发送数据的速率和接收数据的能力。通过滑动窗口机制，TCP可以动态调整数据传输的速率，确保发送的数据不会超过接收方的处理能力。</p></li><li><p>连接管理：</p><p> TCP通过建立连接、数据传输和断开连接的完整过程来管理通信连接。在建立连接时，双方交换一系列控制信息（SYN、SYN-ACK、ACK），以确保双方能够正常通信。在数据传输过程中，TCP会维护连接状态和序列号等信息，以保证数据的可靠传输。在断开连接时，TCP会进行适当的释放和清理工作，以确保连接的安全关闭。</p></li><li><p>超时和重传策略：</p><p> TCP使用超时和重传策略来处理丢失的数据包。如果发送方在一定时间内未收到确认消息，则认为数据丢失，并触发数据的重传机制。TCP会根据网络条件和重传次数动态调整超时时间，以提高数据传输的效率和可靠性。</p></li></ol><h2 id="35-TCP和UDP的区别"><a href="#35-TCP和UDP的区别" class="headerlink" title="35.TCP和UDP的区别"></a>35.TCP和UDP的区别</h2><ol><li><p>TCP<strong>面向连接</strong>（如打电话要先拨号建立连接）;UDP是<strong>无连接</strong>的，即发送数据之前不需要建立连接</p></li><li><p>TCP提供<strong>可靠</strong>的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即<strong>不保证可靠交付</strong></p></li><li><p>TCP<strong>面向字节流</strong>，实际上是TCP把数据看成一连串无结构的字节流;UDP是<strong>面向报文</strong>的</p></li><li><p>UDP没有<strong>拥塞控制</strong>，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</p></li><li><p>每一条TCP连接只能是<strong>点到点</strong>的;UDP支持<strong>一对一，一对多，多对一和多对多</strong>的交互通信</p></li><li><p>TCP首部开销20字节;UDP的首部开销小，只有8个字节</p></li><li><p>TCP的逻辑通信信道是<strong>全双工</strong>的可靠信道，UDP则是不可靠信道</p></li><li><p>UDP是面向报文的，发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层，论应用层交给UDP多长的报文，它统统发送，一次发送一个。而对接收方，接到后直接去除首部，交给上面的应用层就完成任务了。因此，它需要应用层控制报文的大小</p></li><li><p>TCP是面向字节流的，它把上面应用层交下来的数据看成无结构的字节流会发送，可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着TCP会根据当前网络的拥塞状态来确定每个报文段的大小。</p></li></ol><h2 id="36-封包和拆包你听说过吗？它是基于TCP还是UDP的？"><a href="#36-封包和拆包你听说过吗？它是基于TCP还是UDP的？" class="headerlink" title="36.封包和拆包你听说过吗？它是基于TCP还是UDP的？"></a>36.封包和拆包你听说过吗？它是基于TCP还是UDP的？</h2><p>封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p><ul><li><p>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</p></li><li><p>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。</p></li></ul><h2 id="37-协议相关"><a href="#37-协议相关" class="headerlink" title="37.协议相关"></a>37.协议相关</h2><ul><li>TCP对应的应用层协议：<ul><li>HTTP</li><li>FTP</li><li>Telnet</li></ul></li><li>UDP对应的应用层协议：<ul><li>DNS</li><li>DHCP</li></ul></li><li>数据链路层常见协议:<ul><li>ARP</li><li>RARP</li><li>PPP</li></ul></li><li>Ping命令基于什么协议？原理是什么？<ul><li>ping是基于网络层的ICMP协议实现的。</li><li>通过向对方发送一个ICMP回送请求报文，如果对方主机可达的话会收到该报文，并响应一个ICMP回送回答报文。</li></ul></li></ul><h2 id="38-TCP-利用滑动窗口实现流量控制的机制？"><a href="#38-TCP-利用滑动窗口实现流量控制的机制？" class="headerlink" title="38.TCP 利用滑动窗口实现流量控制的机制？"></a>38.TCP 利用滑动窗口实现流量控制的机制？</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。TCP 利用滑动窗口实现流量控制。</p><p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据。</p><p>例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p><h2 id="39-可以解释一下RTO，RTT和超时重传分别是什么吗？"><a href="#39-可以解释一下RTO，RTT和超时重传分别是什么吗？" class="headerlink" title="39.可以解释一下RTO，RTT和超时重传分别是什么吗？"></a>39.可以解释一下RTO，RTT和超时重传分别是什么吗？</h2><p>当使用 TCP 进行通信时，RTO（Retransmission Timeout）、RTT（Round-Trip Time）和超时重传是三个与 TCP 连接可靠性和性能密切相关的概念。</p><ol><li><p>RTO（Retransmission Timeout）：</p><ul><li>RTO 是指重新传输超时时间，即 TCP 在发送数据后等待接收确认的时间长度。当发送方发送数据后，会启动一个定时器，等待接收方发送确认消息。如果在 RTO 时间内未收到确认消息，则认为数据丢失，触发数据的重传机制。RTO 的设定是 TCP 的一个重要参数，影响着数据传输的可靠性和性能。</li></ul></li><li><p>RTT（Round-Trip Time）：</p><ul><li>RTT 是指往返时间，即从发送数据到接收到确认消息所经历的时间。RTT 反映了数据在网络中传输的延迟情况，包括数据在网络中的传播延迟、处理延迟和队列延迟等。RTT 的计算通常通过记录发送数据的时间戳和接收确认消息的时间戳来实现，可以用于调整 RTO 时间以适应网络条件的变化。</li></ul></li><li><p>超时重传：</p><ul><li>超时重传是指当发送方在 RTO 时间内未收到确认消息时，触发的数据重传机制。发送方会重新发送未确认的数据，以确保数据能够被正确接收。超时重传是 TCP 实现可靠数据传输的关键机制之一，通过对丢失数据的及时重传，可以保证数据传输的可靠性。</li></ul></li></ol><p>综上所述，RTO 是 TCP 设定的重新传输超时时间，用于判断数据是否丢失；RTT 是数据往返时间，用于评估网络延迟情况；超时重传是 TCP 在 RTO 时间内未收到确认消息时触发的数据重传机制，用于确保数据传输的可靠性。这些概念在 TCP 连接的性能优化和故障排查中起着重要作用。</p><h2 id="40-CSRF攻击"><a href="#40-CSRF攻击" class="headerlink" title="40.CSRF攻击"></a>40.CSRF攻击</h2><p>CSRF（Cross-Site Request Forgery）跨站请求伪造是一种网络安全攻击，利用用户已经认证过的会话来执行未经授权的操作。攻击者通过诱使用户在受信任的网站上执行恶意操作，利用用户当前的身份认证信息向目标网站发送请求，从而实现攻击目标。CSRF 攻击通常利用用户浏览器的身份验证信息来执行恶意操作，而无需直接获取用户的用户名和密码。</p><p>CSRF 攻击的原理如下：</p><ol><li><p>攻击者诱使受害者登录到目标网站，并获取了用户的身份验证凭据（如会话 Cookie）。</p></li><li><p>攻击者构造恶意网站或者恶意邮件，在页面中插入恶意的请求代码，例如隐藏的表单、图片、iframe 等。</p></li><li><p>受害者访问了攻击者构造的恶意页面，浏览器会自动发送已经认证过的请求给目标网站，执行攻击者预设的恶意操作。</p></li><li><p>目标网站无法区分这个请求是由受害者自己发起的还是攻击者伪造的，因此会执行这个请求，从而使攻击者达到其目的。</p></li></ol><p>防范 CSRF 攻击的常用方法包括：</p><ol><li><p>CSRF Token：在用户请求中添加随机生成的 CSRF Token，服务器端验证请求中的 Token 是否合法。</p></li><li><p>SameSite Cookie 属性：设置 Cookie 的 SameSite 属性为Strict或Lax，限制跨站请求。当设置为 Strict 时，浏览器完全禁止第三方 Cookie；设置为 Lax 时，只允许在顶级导航中发送 Cookie。</p></li><li><p>Referer 检查：服务器端校验请求的 Referer 头部，确保请求来源是合法的网站。</p></li><li><p>双重确认：对于敏感操作，要求用户进行二次确认，如输入密码或者进行其他身份验证。</p></li><li><p>添加验证码：对于一些敏感操作，要求用户输入验证码，以确保请求是由用户本人发起的。</p></li></ol><h2 id="41-如何防范文件上传漏洞"><a href="#41-如何防范文件上传漏洞" class="headerlink" title="41.如何防范文件上传漏洞"></a>41.如何防范文件上传漏洞</h2><p>文件上传的目录设置为不可执行。</p><ol><li><p>判断文件类型。在判断文件类型的时候，可以结合使用MIME Type，后缀检查等方式。因为对于上传文件，不能简单地通过后缀名称来判断文件的类型，因为攻击者可以将可执行文件的后缀名称改为图片或其他后缀类型，诱导用户执行。</p></li><li><p>对上传的文件类型进行白名单校验，只允许上传可靠类型。</p></li><li><p>上传的文件需要进行重新命名，使攻击者无法猜想上传文件的访问路径，将极大地增加攻击成本，同时向shell.php.rar.ara这种文件，因为重命名而无法成功实施攻击。</p></li><li><p>限制上传文件的大小。</p></li><li><p>单独设置文件服务器的域名。</p></li></ol><h2 id="42-如何区分流量控制和拥塞控制？"><a href="#42-如何区分流量控制和拥塞控制？" class="headerlink" title="42.如何区分流量控制和拥塞控制？"></a>42.如何区分流量控制和拥塞控制？</h2><ul><li><p>流量控制属于通信双方协商；拥塞控制涉及通信链路全局。</p></li><li><p>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</p></li><li><p>实际最终发送窗口 &#x3D; min{流控发送窗口，拥塞窗口}。</p></li></ul><h2 id="43-常见的HTTP状态码有哪些？"><a href="#43-常见的HTTP状态码有哪些？" class="headerlink" title="43.常见的HTTP状态码有哪些？"></a>43.常见的HTTP状态码有哪些？</h2><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出</td></tr></tbody></table><ul><li><p>1xx 信息  </p><ul><li>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul></li><li><p>2xx 成功  </p><ul><li>200 OK</li><li>204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li><li>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li></ul></li><li><p>3xx 重定向</p><ul><li>301 Moved Permanently ：永久性重定向</li><li>302 Found ：临时性重定向</li><li>303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li><li>304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li><li>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li></ul></li><li><p>4xx 客户端错误</p><ul><li>400 Bad Request ：请求报文中存在语法错误。</li><li>401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li>403 Forbidden ：请求被拒绝。</li><li>404 Not Found</li></ul></li><li><p>5xx 服务器错误</p><ul><li>500 Internal Server Error ：服务器正在执行请求时发生错误。</li><li>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul></li></ul><h2 id="44-服务器出现大量close-wait的连接的原因是什么？有什么解决方法？"><a href="#44-服务器出现大量close-wait的连接的原因是什么？有什么解决方法？" class="headerlink" title="44.服务器出现大量close_wait的连接的原因是什么？有什么解决方法？"></a>44.服务器出现大量close_wait的连接的原因是什么？有什么解决方法？</h2><ul><li><p>close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：</p><ul><li>服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li><li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收</li></ul></li><li><p>处理方法：</p><ul><li>停止应用程序</li><li>修改程序里的bug</li></ul></li></ul><h2 id="45-一台机器能够使用的端口号上限是多少，是否可以修改？如果想要用的端口超过这个限制怎么办？"><a href="#45-一台机器能够使用的端口号上限是多少，是否可以修改？如果想要用的端口超过这个限制怎么办？" class="headerlink" title="45.一台机器能够使用的端口号上限是多少，是否可以修改？如果想要用的端口超过这个限制怎么办？"></a>45.一台机器能够使用的端口号上限是多少，是否可以修改？如果想要用的端口超过这个限制怎么办？</h2><ul><li><p>65536.因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16&#x3D;65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。</p></li><li><p>而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 通用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2024/04/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/04/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-进程、线程和协程的区别和联系"><a href="#1-进程、线程和协程的区别和联系" class="headerlink" title="1.进程、线程和协程的区别和联系"></a>1.进程、线程和协程的区别和联系</h2><table><thead><tr><th></th><th>进程</th><th>线程</th><th>协程</th></tr></thead><tbody><tr><td>定义</td><td>资源分配和拥有的基本单位</td><td>程序执行的基本单位</td><td>用户态的轻量级线程，线程内部调度的基本单位</td></tr><tr><td>切换情况</td><td>进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td><td>保存和设置程序计数器、少量寄存器和栈的内容</td><td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td></tr><tr><td>切换者</td><td>操作系统</td><td>操作系统</td><td>用户</td></tr><tr><td>切换过程</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态(没有陷入内核)</td></tr><tr><td>调用栈</td><td>内核栈</td><td>内核栈</td><td>用户栈</td></tr><tr><td>拥有资源</td><td>CPU资源、内存资源、文件资源和句柄等</td><td>程序计数器、寄存器、栈和状态字</td><td>拥有自己的寄存器上下文和栈</td></tr><tr><td>并发性</td><td>不同进程之间切换实现并发，各自占有CPU实现并行</td><td>一个进程内部的多个线程并发执行</td><td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td></tr><tr><td>系统开销</td><td>切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td><td>切换时只需保存和设置少量寄存器内容，因此开销很小</td><td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td></tr><tr><td>通信方面</td><td>进程间通信需要借助操作系统</td><td>线程间可以直接读写进程数据段(如全局变量)来进行通信</td><td>共享内存、消息队列</td></tr></tbody></table><h2 id="2-外中断和异常有什么区别？"><a href="#2-外中断和异常有什么区别？" class="headerlink" title="2.外中断和异常有什么区别？"></a>2.外中断和异常有什么区别？</h2><p>外中断（Interrupt）和异常（Exception）是计算机体系结构中两种不同的概念，它们有以下区别：</p><ol><li>来源：<br>外中断是由外部设备（如键盘、鼠标、定时器等）触发的中断，通常用于与计算机外部设备进行通信和交互。<br>异常是由于程序执行过程中出现了某种错误或不正常情况而触发的事件，例如除零、访问非法内存、非法指令等。</li><li>触发时机：<br>外中断是在 CPU 执行指令的过程中由外部设备发出的中断请求，可以在任何时候发生，甚至在指令执行的中间。<br>异常是在指令执行过程中出现了错误或不正常情况时发生的，通常是由当前指令执行的结果导致的。</li><li>处理方式：<br>外中断通常由操作系统的中断处理程序进行处理，它会保存当前进程的状态，切换到相应的中断处理程序，并在处理完成后返回到原进程继续执行。<br>异常通常由异常处理机制（如操作系统或硬件）进行处理，它会根据异常类型执行相应的处理逻辑，可能包括异常处理程序的调用、异常信息的记录等。</li><li>举例：<br>外中断的例子包括定时器中断、IO 设备中断等。<br>异常的例子包括除零异常、内存访问异常、非法指令异常等。</li></ol><p>总的来说，外中断和异常都是计算机体系结构中的重要概念，它们分别用于处理外部设备的中断请求和程序执行过程中的错误或异常情况，但在触发时机、处理方式等方面有所不同。</p><h2 id="3-进程调度算法你了解多少？"><a href="#3-进程调度算法你了解多少？" class="headerlink" title="3.进程调度算法你了解多少？"></a>3.进程调度算法你了解多少？</h2><ol><li><p><strong>先来先服务 first-come first-serverd（FCFS）</strong><br> 非抢占式的调度算法，按照请求的顺序进行调度。</p><p> 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p></li><li><p><strong>短作业优先 shortest job first（SJF）</strong><br> 非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p><p> 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p></li><li><p><strong>最短剩余时间优先 shortest remaining time next（SRTN）</strong><br> 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。</p><p> 如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p></li><li><p><strong>时间片轮转</strong><br> 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。</p><p> 当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p> 时间片轮转算法的效率和时间片的大小有很大关系：</p><p> 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。</p></li><li><p><strong>优先级调度</strong><br> 为每个进程分配一个优先级，按优先级进行调度。</p><p> 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p></li><li><p><strong>多级反馈队列</strong><br> 一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p> 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。</p><p> 这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p> 可以将这种调度算法看成是<code>时间片轮转调度算法和优先级调度算法的结合</code>。</p></li></ol><h2 id="4-Linux下进程间通信方式？"><a href="#4-Linux下进程间通信方式？" class="headerlink" title="4.Linux下进程间通信方式？"></a>4.Linux下进程间通信方式？</h2><ul><li><p>管道：</p><ul><li><p>无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。</p></li><li><p>有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</p></li></ul></li><li><p>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。</p></li><li><p>消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li><li><p>套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</p></li><li><p>信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</p></li><li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。</p></li></ul><h2 id="5-如果系统中具有快表后，那么地址的转换过程变成什么样了？"><a href="#5-如果系统中具有快表后，那么地址的转换过程变成什么样了？" class="headerlink" title="5.如果系统中具有快表后，那么地址的转换过程变成什么样了？"></a>5.如果系统中具有快表后，那么地址的转换过程变成什么样了？</h2><ol><li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。  </li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。  </li><li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)</li></ol><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，–般来说快表的命中率可以达到90%以上。</p><ul><li><p>局部性原理:<br>局部性原理是计算机系统设计中的一个重要概念，它指的是在程序执行过程中，访问内存的趋势是倾向于集中在一小部分地址范围内。局部性原理分为两种类型：时间局部性和空间局部性。</p><ul><li>时间局部性（Temporal Locality）：</li></ul></li></ul><p>时间局部性指的是，如果在程序的某个时间点访问了某个存储单元，那么在不久之后的时间内，很可能会再次访问相同的存储单元。这意味着程序倾向于重复使用最近使用过的数据或指令。时间局部性的主要原因是程序中存在循环、子程序调用等结构，导致某些数据被反复使用。</p><pre><code>* 空间局部性（Spatial Locality）：</code></pre><p>空间局部性指的是，如果程序访问了某个存储单元，那么在不久之后的时间内，很可能会访问与该存储单元相邻的存储单元。这意味着程序倾向于顺序地访问相邻的内存位置，例如数组、矩阵等数据结构。空间局部性的主要原因是计算机系统中的缓存机制，通常会将相邻的内存位置加载到缓存中，以提高访问效率。</p><h2 id="6-动态分区分配算法有哪几种？可以分别说说吗？"><a href="#6-动态分区分配算法有哪几种？可以分别说说吗？" class="headerlink" title="6.动态分区分配算法有哪几种？可以分别说说吗？"></a>6.动态分区分配算法有哪几种？可以分别说说吗？</h2><table><thead><tr><th>算法</th><th>算法思想</th><th>分区排列顺序</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>首次适应</td><td>从头到尾找适合的分区</td><td>空闲分区以地址递增次序排列</td><td>综合看性能最好。算法开销小，回收分区后一.般不需要对空闲分区队列重新排序</td><td></td></tr><tr><td>最佳适应</td><td>优先使用更小的分区，以保留更多大分区</td><td>空闲分区以容量递增次序排列</td><td>会有更多的大分区被保留下来，更能满足大进程需求</td><td>会产生很多太小的、难以利用的碎片;算法开销大，回收分区后可能需要对空闲分区队列重新排序</td></tr><tr><td>最坏适应</td><td>优先使用更大的分区，以防止产生太小的不可用的碎片</td><td>空闲分区以容量递减次序排列</td><td>可以减少难以利用的小碎片</td><td>大分区容易被用完，不利于大进程;算法开销大(原因同上)</td></tr><tr><td>邻近适应</td><td>由首次适应演变而来，每次从上次查找结束位置开始查找</td><td>空闲分区以地址递增次序排列(可排列成循环链表)不</td><td>用每次都从低地址的小分区开始检索。算法开销小(原因同首次适应算法)</td><td>会使高地址的大分区也被用完</td></tr></tbody></table><h2 id="7-虚拟技术你了解吗？"><a href="#7-虚拟技术你了解吗？" class="headerlink" title="7.虚拟技术你了解吗？"></a>7.虚拟技术你了解吗？</h2><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：<code>时（时间）分复用技术</code>和<code>空（空间）分复用技术</code>。</p><ul><li><p>多进程与多线程：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p></li><li><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p></li></ul><h2 id="8-虚拟内存的目的是什么？"><a href="#8-虚拟内存的目的是什么？" class="headerlink" title="8.虚拟内存的目的是什么？"></a>8.虚拟内存的目的是什么？</h2><p><strong>空分复用:</strong></p><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。</p><p>这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p><p>例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><h2 id="9-一个C-C-程序从开始编译到生成可执行文件的完整过程，你能说出来多少？"><a href="#9-一个C-C-程序从开始编译到生成可执行文件的完整过程，你能说出来多少？" class="headerlink" title="9.一个C&#x2F;C++程序从开始编译到生成可执行文件的完整过程，你能说出来多少？"></a>9.一个C&#x2F;C++程序从开始编译到生成可执行文件的完整过程，你能说出来多少？</h2><p>四个过程：</p><p>（1）预编译 主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</p><ol><li><p>删除所有的#define，展开所有的宏定义。</p></li><li><p>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</p></li><li><p>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。</p></li><li><p>删除所有的注释，“&#x2F;&#x2F;”和“&#x2F;**&#x2F;”。</p></li><li><p>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。</p></li><li><p>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。</p></li></ol><p>（2）编译 把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p><ol><li><p>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</p></li><li><p>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</p></li><li><p>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</p></li><li><p>优化：源代码级别的一个优化过程。</p></li><li><p>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</p></li><li><p>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p></li></ol><p>（3）汇编</p><p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。</p><p>经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux下)、xxx.obj(Windows下)。</p><p>（4）链接</p><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p><ol><li><p>静态链接： 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p><ul><li>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</li></ul></li><li><p>动态链接： 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p><ul><li><p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</p></li><li><p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p></li><li><p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p></li></ul></li></ol><h2 id="10-讲解逻辑地址转换为物理地址的基本过程"><a href="#10-讲解逻辑地址转换为物理地址的基本过程" class="headerlink" title="10.讲解逻辑地址转换为物理地址的基本过程"></a>10.讲解逻辑地址转换为物理地址的基本过程</h2><p><img src="/2024/04/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/addressing.png"></p><h2 id="11-进程同步的四种方法"><a href="#11-进程同步的四种方法" class="headerlink" title="11.进程同步的四种方法"></a>11.进程同步的四种方法</h2><ol><li><p>临界区  </p><p> 对临界资源进行访问的那段代码称为临界区。</p><p> 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p></li><li><p>同步与互斥  </p><p> 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。  </p><p> 互斥：多个进程在同一时刻只有一个进程能进入临界区。</p></li><li><p>信号量  </p><p> 信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p></li><li><p>管程  </p><p> 管程是一种高级的同步机制，它将数据结构和操作封装在一起，提供了对共享资源的访问和控制。只有通过管程提供的操作才能访问共享资源，从而确保了对共享资源的互斥访问。</p><p> 管程（Monitor）实质上可以看作是一个类或者一个抽象数据类型（ADT）。它封装了共享资源以及对该资源的访问和控制方法，提供了一种高级的同步机制。</p></li></ol><h2 id="12-进程通信方式"><a href="#12-进程通信方式" class="headerlink" title="12.进程通信方式"></a>12.进程通信方式</h2><ul><li><p>管道(pipe)：允许一个进程和另一个与它有共同祖先的进程之间进行通信</p></li><li><p>命名管道(FIFO)：类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建</p></li><li><p>消息队列(MQ)：消息队列是消息的连接表，包括POSIX消息对和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点；</p></li><li><p>信号量(semaphore)：信号量主要作为进程间以及同进程不同线程之间的同步手段；</p></li><li><p>共享内存(shared memory)：它使得多个进程可以访问同一块内存空间，<strong>是最快的可用IPC形式。</strong>这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥</p></li><li><p>信号(signal)：信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身<br>内存映射(mapped memory)：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它</p></li><li><p>Socket：它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信</p></li></ul><h2 id="13-介绍一下几种典型的锁？"><a href="#13-介绍一下几种典型的锁？" class="headerlink" title="13.介绍一下几种典型的锁？"></a>13.介绍一下几种典型的锁？</h2><ul><li><p>读写锁  </p><ul><li>多个读者可以同时进行读</li><li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li><li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li></ul></li><li><p>互斥锁</p><ul><li><p>一次只能一个线程拥有互斥锁，其他线程只有等待</p></li><li><p>互斥锁是在抢锁失败的情况下<strong>主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度</strong>，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p></li></ul></li><li><p>条件变量</p><ul><li>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。</li></ul></li><li><p>自旋锁</p><ul><li>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</li></ul></li></ul><h2 id="14-逻辑地址VS物理地址"><a href="#14-逻辑地址VS物理地址" class="headerlink" title="14.逻辑地址VS物理地址"></a>14.逻辑地址VS物理地址</h2><blockquote><p>注意：物理地址指的是程序在内存中的地址，而不是程序在硬盘中的地址。</p></blockquote><p>逻辑地址（Logical Address）和物理地址（Physical Address）是在计算机系统中用于访问内存的两种不同的地址类型，它们之间存在着映射关系。下面是它们的区别：</p><ol><li><p>逻辑地址：</p><ul><li>逻辑地址是由CPU产生的地址，用于访问内存中的数据和指令。它是一个虚拟地址，与实际的硬件内存地址无关。</li><li>在多道程序设计环境下，每个进程都有自己的逻辑地址空间。逻辑地址是相对于进程而言的，它从0开始，通常是一个连续的地址空间。</li><li>逻辑地址的映射是由操作系统的内存管理单元来完成的，包括地址翻译、分页机制、分段机制等。</li></ul></li><li><p>物理地址：</p><ul><li>物理地址是实际存储在计算机硬件中的地址，用于在内存中定位数据和指令的位置。它是相对于物理内存模块而言的，是真实存在的硬件地址。</li><li>物理地址是由内存管理单元（Memory Management Unit，MMU）根据逻辑地址的映射关系转换得到的。MMU负责将逻辑地址映射到相应的物理地址上，以便CPU可以正确地访问内存中的数据。</li></ul></li><li><p>映射关系：</p><ul><li>逻辑地址和物理地址之间存在着映射关系，这个映射关系由操作系统的内存管理单元来管理和维护。</li><li>当CPU发出一个逻辑地址时，MMU会根据逻辑地址的映射关系将其转换为相应的物理地址，然后用于实际的内存访问。</li></ul></li></ol><p>总的来说，逻辑地址是虚拟的地址空间，是由CPU产生的相对地址；而物理地址是真实的硬件地址，是内存中实际存储数据和指令的位置。通过逻辑地址和物理地址之间的映射关系，CPU可以正确地访问内存中的数据和指令。</p><h2 id="15-内存交换"><a href="#15-内存交换" class="headerlink" title="15.内存交换"></a>15.内存交换</h2><ol><li><p>内存覆盖（Memory Overlay）：</p><ul><li>内存覆盖是一种技术，用于在内存有限的情况下运行较大的程序。当程序的内存需求超过了系统的物理内存时，操作系统会将程序的一部分加载到内存中运行，然后根据需要逐步覆盖、替换加载的程序段。</li><li>内存覆盖通常用于早期的计算机系统，特别是在内存容量受限的环境下。它可以让大型程序在较小的内存空间中运行，但需要手动管理内存的分段和覆盖过程。</li></ul></li><li><p>内存交换（Memory Swapping）：</p><ul><li>内存交换是一种技术，用于在系统的物理内存不足时将部分内存中的数据和程序暂时移到辅助存储设备（如硬盘）中。这样可以腾出内存空间供其他程序使用。</li><li>当操作系统检测到物理内存不足时，它会将部分不活动的进程或者数据交换到硬盘上，以释放内存空间。当需要访问这些被交换出去的数据时，操作系统会将其再次交换回内存中，以满足程序的需求。</li><li>内存交换是一种动态的内存管理技术，操作系统可以根据系统的内存需求自动进行内存交换，无需用户干预。</li></ul></li></ol><p>总的来说，内存覆盖和内存交换都是用于解决内存有限的情况下运行大型程序的技术，但它们的实现方式和应用场景略有不同。<strong>内存覆盖主要用于早期计算机系统中，而内存交换则是现代操作系统中常用的内存管理技术之一</strong>。</p><h2 id="16-如何让进程后台运行"><a href="#16-如何让进程后台运行" class="headerlink" title="16.如何让进程后台运行"></a>16.如何让进程后台运行</h2><ol><li><p>使用后台运行命令：</p><ul><li>在 Unix&#x2F;Linux 系统中，可以使用 &amp; 符号将命令放置在后台运行。例如：.&#x2F;my_program &amp;。</li><li>实际上，这样是将命令放入到一个作业队列中了。这样可以使得该进程在后台运行，不会阻塞当前终端的使用。</li></ul></li><li><p>使用 nohup 命令：</p><ul><li>nohup 命令可以让进程在后台运行，并且不受终端关闭的影响。例如：nohup .&#x2F;my_program &amp;。</li><li>使用 nohup 后，即使关闭终端或者注销用户，进程仍然会继续在后台运行。</li></ul></li><li><p>使用 screen 或者 tmux：</p><ul><li>screen 或者 tmux 是终端复用工具，可以创建一个或多个终端窗口，并在其中运行进程。即使关闭了当前终端窗口，进程仍然会继续在后台运行。</li><li>具体使用方法请参考 screen 或者 tmux 的文档。</li></ul></li><li><p>使用后台运行守护进程：</p><ul><li>将需要后台运行的程序设计为守护进程，并使用系统服务管理工具（如 systemd、init.d 等）启动该守护进程。</li><li>守护进程是一种在后台运行的长期运行的进程，通常用于执行系统任务或服务。</li></ul></li></ol><h2 id="17-快表在什么位置"><a href="#17-快表在什么位置" class="headerlink" title="17.快表在什么位置"></a>17.快表在什么位置</h2><p>TLB（Translation Lookaside Buffer，快表）通常位于处理器的内部，是一个高速缓存结构，用于存储最近使用的逻辑地址到物理地址的映射关系。TLB的设计旨在加速逻辑地址到物理地址的转换过程，提高系统的性能和响应速度。</p><h2 id="18-守护进程、僵尸进程和孤儿进程"><a href="#18-守护进程、僵尸进程和孤儿进程" class="headerlink" title="18.守护进程、僵尸进程和孤儿进程"></a>18.守护进程、僵尸进程和孤儿进程</h2><ol><li><p>守护进程（Daemon Process）：</p><ul><li>守护进程是在后台运行的一种特殊进程，通常是由操作系统启动并且在后台运行的进程。它通常不与任何用户交互，而是执行一些系统任务或服务，例如网络服务、日志服务等。</li><li>守护进程通常在系统启动时被初始化，并且一直运行直到系统关闭。它们通常不会终止，除非出现严重的错误或者手动停止。</li></ul></li><li><p>僵尸进程（Zombie Process）：</p><ul><li>僵尸进程是已经完成执行但是其父进程尚未调用 <code>wait()</code> 或 <code>waitpid()</code> 函数来获取其终止状态的进程。在这种情况下，操作系统会将僵尸进程保留在进程表中，直到其父进程获取其终止状态。</li><li>僵尸进程不会占用系统资源，但是如果太多的僵尸进程积累，会导致系统的进程表被占满，从而影响系统的正常运行。</li></ul></li><li><p>孤儿进程（Orphan Process）：</p><ul><li>孤儿进程是指其父进程提前终止或者意外终止，而导致子进程成为没有父进程的进程。在这种情况下，子进程会被 <code>init</code> 进程（进程号为1）接管。</li><li>孤儿进程会继续在系统中运行，直到其自己终止或者被 <code>init</code> 进程接管。这样可以确保孤儿进程不会成为僵尸进程，因为 <code>init</code> 进程会及时调用 <code>wait()</code> 函数获取其终止状态。</li></ul></li></ol><h2 id="19-如何避免僵尸进程？"><a href="#19-如何避免僵尸进程？" class="headerlink" title="19.如何避免僵尸进程？"></a>19.如何避免僵尸进程？</h2><ol><li><p>父进程调用 wait() 或 waitpid() 函数：</p><ul><li>父进程可以通过调用 wait() 或 waitpid() 函数来等待子进程的退出，并获取子进程的终止状态。这样可以及时回收子进程的资源，并避免其成为僵尸进程。</li><li>在父进程中定期调用 wait() 或 waitpid() 函数可以确保及时处理子进程的退出。</li></ul></li><li><p>使用信号处理函数：</p><ul><li>父进程可以注册 <code>SIGCHLD</code> 信号的处理函数，在收到该信号时调用 <code>wait()</code> 或 <code>waitpid()</code> 函数来处理子进程的退出。</li><li>当子进程退出时，操作系统会向父进程发送 SIGCHLD 信号，父进程可以在信号处理函数中获取子进程的终止状态。</li></ul></li><li><p>设置信号处理方式为忽略（SIG_IGN）：</p><ul><li>父进程可以将 <code>SIGCHLD</code> 信号的处理方式设置为忽略，这样子进程退出时可让内核把僵尸子进程转交给init进程去处理，不会产生僵尸进程。</li><li>但是需要注意的是，这种方式下无法获取子进程的终止状态，可能会导致资源泄漏或者无法正确处理异常情况。</li></ul></li></ol><h2 id="20-Linux中异常和中断的区别"><a href="#20-Linux中异常和中断的区别" class="headerlink" title="20.Linux中异常和中断的区别"></a>20.Linux中异常和中断的区别</h2><p>在Linux系统中，异常（Exception）和中断（Interrupt）是两种不同的事件，它们的触发方式、处理方式以及产生的原因有所不同。</p><ol><li><p>异常（Exception）：</p><ul><li>异常是指在程序执行过程中发生的意外事件或错误情况，例如除零错误、内存访问越界等。异常通常是由CPU在执行指令过程中检测到的，它是指令执行的结果与预期不符导致的。</li><li>在Linux系统中，异常由CPU直接检测并触发，然后将控制权转移给操作系统内核。操作系统内核会根据异常的类型和原因采取相应的处理措施，例如向用户进程发送信号、终止异常进程等。</li></ul></li><li><p>中断（Interrupt）：</p><ul><li>中断是指外部设备或者硬件组件发送的信号，用于通知CPU需要处理某个事件或者执行某个操作。中断可以是来自硬件设备的信号（硬件中断），也可以是来自软件的信号（软件中断）。</li><li>在Linux系统中，中断通常由硬件设备发送给CPU，例如定时器中断、键盘输入中断等。当CPU接收到中断信号时，会暂停当前的执行流程，并转移到中断处理程序（中断服务程序）中执行。中断处理程序负责处理中断事件，并进行相应的处理，例如读取设备数据、响应用户输入等。</li></ul></li></ol><p>总的来说，异常是程序执行过程中的错误情况，由CPU直接检测并触发；而中断是外部设备发送的信号，用于通知CPU需要处理某个事件或者执行某个操作。异常和中断在触发方式、处理方式以及产生原因上有着明显的区别。</p><h2 id="21-一般情况下在Linux-windows平台下栈空间的大小"><a href="#21-一般情况下在Linux-windows平台下栈空间的大小" class="headerlink" title="21.一般情况下在Linux&#x2F;windows平台下栈空间的大小"></a>21.一般情况下在Linux&#x2F;windows平台下栈空间的大小</h2><ul><li><p>Linux环境下有操作系统决定，一般是8MB，8192KB，通过<code>ulimit</code>命令查看以及修改</p></li><li><p>Windows环境下由编译器决定，VC++6.0一般是1M</p></li></ul><h2 id="22-交换空间是什么"><a href="#22-交换空间是什么" class="headerlink" title="22.交换空间是什么"></a>22.交换空间是什么</h2><p>交换空间（Swap Space）是指操作系统用于扩展虚拟内存的一种技术，它将部分内存数据临时存储到磁盘上以释放物理内存空间。交换空间通常用于以下几种情况：</p><ol><li><p>内存不足：当系统的物理内存不足以容纳所有的进程和数据时，操作系统会将部分不经常使用的数据存储到交换空间中，以释放物理内存空间给更重要的进程使用。</p></li><li><p>内存回收：操作系统可以使用交换空间来回收不活动的内存页面，以便将其分配给其他进程使用。这有助于优化内存的使用效率和系统的性能。</p></li><li><p>休眠和恢复：在某些情况下，操作系统可以使用交换空间来存储休眠进程的状态，以便在系统重新启动或恢复时能够快速恢复进程的状态。</p></li></ol><p>交换空间通常由操作系统预先分配，并且可以是一个专门的交换分区，也可以是一个交换文件。交换空间的大小可以根据系统的配置和需求进行调整，但是过度使用交换空间可能会影响系统的性能，因为磁盘访问速度远远低于内存访问速度。因此，合理配置交换空间是系统性能优化的重要一环。</p><h2 id="23-常见的几种磁盘调度算法"><a href="#23-常见的几种磁盘调度算法" class="headerlink" title="23.常见的几种磁盘调度算法"></a>23.常见的几种磁盘调度算法</h2><ol><li><p>先来先服务（First-Come, First-Served，FCFS）：</p><ul><li>FCFS 是最简单的磁盘调度算法，按照请求到达的顺序依次处理磁盘访问请求。</li><li>这种算法的优点是公平性，即所有的请求都能够得到处理。但是它可能会导致磁盘头在磁盘上来回移动，造成平均响应时间较长。</li></ul></li><li><p>最短寻道时间优先（Shortest Seek Time First，SSTF）：</p><ul><li>SSTF 算法会优先处理与磁头当前位置最接近的磁盘访问请求。</li><li>这种算法能够减少磁盘头的移动距离，从而缩短平均响应时间。但是它可能会导致部分请求长时间等待，造成请求饥饿现象。</li></ul></li><li><p>电梯算法（Elevator Algorithm）：</p><ul><li>电梯算法模拟了电梯在多层楼间上下运动的过程，磁盘头会沿着一个方向移动，直到该方向上没有未处理的请求，然后改变方向。</li><li>这种算法能够有效地减少磁盘头的移动次数，从而提高磁盘访问的效率。但是它可能会导致一些请求长时间等待，特别是当磁盘请求集中在一个方向时。</li></ul></li><li><p>扫描算法（SCAN）：</p><ul><li>扫描算法（也称为电梯算法的变种）从磁盘上的一个端点开始沿着一个方向移动，处理所有的请求，直到达到另一个端点，然后返回，继续处理另一侧的请求。</li><li>这种算法能够平衡磁盘头的移动，避免了某些请求长时间等待的情况，但是可能会导致磁盘头在两端之间频繁切换，造成磁盘头的忙碌。</li></ul></li></ol><h2 id="24-抖动你知道是什么吗？它也叫颠簸现象"><a href="#24-抖动你知道是什么吗？它也叫颠簸现象" class="headerlink" title="24.抖动你知道是什么吗？它也叫颠簸现象"></a>24.抖动你知道是什么吗？它也叫颠簸现象</h2><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)</p><h2 id="25-内存交换中，被换出的进程保存在哪里？"><a href="#25-内存交换中，被换出的进程保存在哪里？" class="headerlink" title="25.内存交换中，被换出的进程保存在哪里？"></a>25.内存交换中，被换出的进程保存在哪里？</h2><p>保存在磁盘中，也就是外存中。具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I&#x2F;O速度比文件区的更快。</p><h2 id="26-ASCII、Unicode和UTF-8编码的区别？"><a href="#26-ASCII、Unicode和UTF-8编码的区别？" class="headerlink" title="26.ASCII、Unicode和UTF-8编码的区别？"></a>26.ASCII、Unicode和UTF-8编码的区别？</h2><ul><li><p>ASCII<br>  ASCII 只有127个字符，表示英文字母的大小写、数字和一些符号，但由于其他语言用ASCII 编码表示字节不够，例如：常用中文需要两个字节，且不能和ASCII冲突，中国定制了GB2312编码格式，相同的，其他国家的语言也有属于自己的编码格式。</p></li><li><p>Unicode<br>  由于每个国家的语言都有属于自己的编码格式，在多语言编辑文本中会出现乱码，这样Unicode应运而生，Unicode就是将这些语言统一到一套编码格式中，通常两个字节表示一个字符，而ASCII是一个字节表示一个字符，这样如果你编译的文本是全英文的，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p></li><li><p>UTF-8<br>  为了解决上述问题，又出现了把Unicode编码转化为<code>可变长编码</code>UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为1-6个字节，英文字母被编码成一个字节，常用汉字被编码成三个字节，如果你编译的文本是纯英文的，那么用UTF-8就会非常节省空间，并且ASCII码也是UTF-8的一部分。</p></li><li><p>三者之间的联系<br>  搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p><ol><li><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码:</p></li><li><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。如下图<br>  <img src="/2024/04/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/code1.png"></p></li><li><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：<br>  <img src="/2024/04/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/code2.png"></p></li></ol></li></ul><h2 id="27-页面置换算法"><a href="#27-页面置换算法" class="headerlink" title="27.页面置换算法"></a>27.页面置换算法</h2><ol><li><p>最佳置换法(OPT)</p><ul><li>最佳置换算法(OPT，Optimal) :每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</li><li>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的</li></ul></li><li><p>先进先出置换算法(FIFO)</p><ul><li><p>先进先出置换算法(FIFO) :每次选择淘汰的页面是最早进入内存的页面 实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面队列的最大长度取决于系统为进程分配了多少个内存块。</p></li><li><p><strong>Belady异常—当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</strong></p></li><li><p>只有FIFO算法会产生Belady异常，而LRU和OPT算法永远不会出现Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差</p></li><li><p>FIFO的性能较差，因为较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出，并且有Belady现象。所谓Belady现象是指：采用FIFO算法时，如果对—个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。</p></li></ul></li><li><p>最近最久未使用置换算法(LRU)</p><ul><li><p>最近最久未使用置换算法(LRU，least recently used) :每次淘汰的页面是最近最久未使用的页面 实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自.上次被访问以来所经历的时间t(该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大)。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p></li><li><p>LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类算法，理论上可以证明，堆栈类算法不可能出现Belady异常。</p></li></ul></li><li><p>时钟置换算法(CLOCK)</p><ul><li><p>最佳置换算法性OPT能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p></li><li><p>所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体，因为算法要循环扫描缓冲区像时钟一样转动。所以叫clock算法。</p></li><li><p>时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used)</p></li><li><p>简单的CLOCK算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰-一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第- - ~轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择–个淘汰页面最多会经过两轮扫描)</p></li></ul></li><li><p>改进型的时钟置换算法</p><ul><li><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过,就不需要执行I&#x2F;O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p></li><li><p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I&#x2F;O操作。这就是改进型的时钟置换算法的思想。修改位&#x3D;0，表示页面没有被修改过;修改位&#x3D;1，表示页面被修改过。</p></li></ul></li></ol><ul><li>总结</li></ul><table><thead><tr><th></th><th>算法规则</th><th>优缺点</th></tr></thead><tbody><tr><td>OPT</td><td>优先淘汰最长时间内不会被访问的页面</td><td>缺页率最小，性能最好;但无法实现</td></tr><tr><td>FIFO</td><td>优先淘汰最先进入内存的页面</td><td>实现简单;但性能很差，可能出现Belady异常</td></tr><tr><td>LRU</td><td>优先淘汰最近最久没访问的页面</td><td>性能很好;但需要硬件支持，算法开销大</td></tr><tr><td>CLOCK (NRU)</td><td>循环扫描各页面 第一轮淘汰访问位&#x3D;0的，并将扫描过的页面访问位改为1。若第-轮没选中，则进行第二轮扫描。</td><td>实现简单，算法开销小;但未考虑页面是否被修改过。</td></tr><tr><td>改进型CLOCK (改进型NRU)</td><td>若用(访问位，修改位)的形式表述，则 第一轮:淘汰(0,0) 第二轮:淘汰(O,1)，并将扫描过的页面访问位都置为0 第三轮:淘汰(O, 0) 第四轮:淘汰(0, 1)</td><td>算法开销较小，性能也不错</td></tr></tbody></table><h2 id="28-Belady异常"><a href="#28-Belady异常" class="headerlink" title="28.Belady异常"></a>28.Belady异常</h2><ol><li><p>LRU为什么不会发生Belady异常？  </p><ul><li><p>实页数增加 —&gt; 能贮存的页数增加 —&gt; 哪些页？—&gt; 访问频率高的页</p></li><li><p>LRU当中替换的是使用频率最低的页，留下的都是使用频率高的页。当实页数增加，能够留下的高频访问的页也就更多，这直接关系到命中率的增加。</p></li></ul></li><li><p>FIFO为什么会发生Belady异常？</p><ul><li><p>实页数增加 —&gt; 能贮存的页数增加 —&gt; 哪些页？—&gt; 后面来的页</p></li><li><p>先进先出的替换算法，完全不考虑使用频率，即使增加了实页数，多贮存的部分接下来常访问可能性也不一定大（看运气），也就并不一定能增加命中率。</p></li></ul></li></ol><h2 id="29-死锁产生原因"><a href="#29-死锁产生原因" class="headerlink" title="29.死锁产生原因"></a>29.死锁产生原因</h2><p>举个例子：两个线程A和B，两个数据1和2。线程A在执行过程中，首先对资源1加锁，然后再去给资源2加锁，但是由于线程的切换，导致线程A没能给资源2加锁。线程切换到B后，线程B先对资源2加锁，然后再去给资源1加锁，由于资源1已经被线程A加锁，因此线程B无法加锁成功，当线程切换为A时，A也无法成功对资源2加锁，由此就造成了线程AB双方相互对一个已加锁资源的等待，死锁产生。</p><p>理论上认为死锁产生有以下四个必要条件，缺一不可：</p><ul><li><p>互斥条件：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。</p></li><li><p>不剥夺条件：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。</p></li><li><p>请求和保持条件：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。</p></li><li><p>循环等待条件：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</p></li></ul><h2 id="30-银行家算法"><a href="#30-银行家算法" class="headerlink" title="30.银行家算法"></a>30.银行家算法</h2><p>银行家算法是一种用于避免死锁（Deadlock）的资源分配和调度算法，最初由Dijkstra在1965年提出。它通过合理地分配和释放资源，避免了进程之间因争夺资源而导致的死锁问题。银行家算法主要用于操作系统中的进程管理和资源分配。</p><p>银行家算法的基本思想是通过检查分配资源的安全性来决定是否允许进程继续运行。它通过维护一个系统资源分配的最大需求矩阵、可用资源向量和已分配资源矩阵，来判断系统当前是否处于安全状态。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 通用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake语法</title>
      <link href="/2024/03/28/CMake%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/03/28/CMake%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="CMake-语法"><a href="#CMake-语法" class="headerlink" title="CMake 语法"></a>CMake 语法</h1><h2 id="CMake-简介"><a href="#CMake-简介" class="headerlink" title="CMake 简介"></a>CMake 简介</h2><h3 id="什么是-CMake"><a href="#什么是-CMake" class="headerlink" title="什么是 CMake"></a>什么是 CMake</h3><pre><code>CMake 是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装（编译过程）。他能够输出各种各样的makefile 或者 project 文件，CMake 的配置文件取名为 CMakeLists.txt。也就是在 CMakeLists.txt 这个文件中写 cmake 代码。 一句话：cmake 就是将多个 cpp、hpp 文件组合构建为一个大工程的语言。</code></pre><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><strong>优点：</strong><ul><li>开源，使用类BSD许可发布。</li><li>跨平台，并可以生成 native 编译配置文件，在 Linux&#x2F;Unix 平台，生成 makefile；在苹果平台可以生成 Xcode；在Windows 平台，可以生成 MSVC 的工程文件。</li><li>能够管理大型项目。</li><li>简化编译构建过程和编译过程。cmake 的工具链非常简单：cmake + make。</li><li>高效率，因为 cmake 在工具链中没有 libtool。</li><li>可扩展，可以为 cmake 编写特定功能的模块，扩展 cmake 功能。</li></ul></li><li><strong>缺点：</strong><ul><li>cmake 只是看起来比较简单，而使用并不简单。</li><li>cmake 编写的过程实际上是编程的过程，每个项目使用一个       </li><li>cmake 跟已有体系配合不是特别的理想，比如 pkgconfig。</li></ul></li></ul><h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><p>在 linux 下使用 CMake 生成 Makefile 并编译的流程如下：</p><ol><li>编写 CMake 配置文件 CMakeLists.txt 。</li><li>在 CMakeLists.txt 文件所在目录创建一个 build 文件夹，然后进入目录。（这一步可以省略，但是生成的中间文件不易清理）</li><li>执行命令<code>cmake PATH</code>或者<code>ccmake PATH</code>生成 Makefile（<code>ccmake</code>和<code>cmake</code>的区别在于前者提供了一个交互式的界面）。其中，<code>PATH</code>是 CMakeLists.txt 所在的目录。</li><li>使用<code>make</code>命令进行编译，使用<code>make install</code>进行安装。</li></ol><h2 id="CMake-实战"><a href="#CMake-实战" class="headerlink" title="CMake 实战"></a>CMake 实战</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>以Ubuntu为例：<br>首先，更新本地的软件包索引，以确保获取最新的可用软件包列表。打开终端，并执行以下命令：</p><pre><code class="bash">sudo apt update</code></pre><p>安装 CMake。执行以下命令：</p><pre><code class="bash">sudo apt install cmake</code></pre><p>安装完成后，你可以通过以下命令验证是否成功安装了 CMake：</p><pre><code class="bash">cmake --version</code></pre><p>该命令会显示安装的 CMake 版本信息。</p><p>通过以上步骤，你应该已经成功在 Ubuntu 上安装了 CMake。</p><h3 id="编译单个源文件"><a href="#编译单个源文件" class="headerlink" title="编译单个源文件"></a>编译单个源文件</h3><p>首先查看一下某个示例的目录结构：</p><pre><code>.├── CMakeLists.txt├── main.cpp└── README.adoc</code></pre><p>在本目录下有三个文件，分别是源文件 main.cpp，cmake 构建规则 CMakeLists.txt 以及说明文件 README.adoc，下面来看看他们的具体内容。</p><pre><code class="C++">#include &lt;iostream&gt;int main(int argc, char *argv[])&#123;   std::cout &lt;&lt; &quot;Hello CMake!&quot; &lt;&lt; std::endl;   return 0;&#125;</code></pre><p>源文件是一个简单的 Hello World。</p><pre><code class="cmake">cmake_minimum_required(VERSION 3.10)    # 设CMake最小版本号project(hello_cmake)    # 设置工程名add_executable($&#123;PROJECT_NAME&#125; main.cpp)# 生成可执行文件</code></pre><p>CMakeLists 中主要包含了三个命令：</p><ul><li><code>cmake_minimum_required(VERSION 3.10)</code>：指定运行此配置文件所需的 CMake 的最低版本。</li><li><code>project (hello_cmake)</code>：设置项目的名称，同时会自动生成 PROJECT_NAME 变量，使用 ${PROJECT_NAME} 即可访问到 hello_cmake。</li><li><code>add_executable(hello_cmake main.cpp)</code>：第一个参数是可执行文件名，第二个参数是要编译的源文件列表。z这里将名为 main.cpp 的源文件编译成一个名称为 hello_cmake 的可执行文件。</li></ul><p>接着我们可以开始构建项目，构建的方法有以下两种：</p><ul><li><strong>内部构建</strong>：直接在源文件目录构建项目，会导致临时文件和源代码放在一起，不好清理。</li><li><strong>外部构建</strong>：创建一个可以位于文件系统上任何位置的构建文件夹。 所有临时构建和目标文件都位于此目录中，以保持源代码树的整洁。</li></ul><p>这里以外部构建为例，此时我们需要新建一个构建文件夹 build，并在该目录下运行 cmake 命令进行构建：</p><pre><code class="bash">#创建并进入build目录mkdir build &amp;&amp; cd build#构建当前目录cmake ..#使用cmake生成的makefile编译得到可执行文件make</code></pre><p>此时在当前目录下，就会生成可执行文件 hello_cmake。将其运行查看是否成功编译：</p><pre><code class="bash">./hello_cmakeHello CMake!</code></pre><h3 id="编译多个源文件"><a href="#编译多个源文件" class="headerlink" title="编译多个源文件"></a>编译多个源文件</h3><h4 id="单个目录下的多个源文件"><a href="#单个目录下的多个源文件" class="headerlink" title="单个目录下的多个源文件"></a>单个目录下的多个源文件</h4><p>首先查看一下本示例的目录结构：</p><pre><code>.├── CMakeLists.txt├── main.cc├── MathFunctions.cc└── MathFunctions.h</code></pre><p>与上个示例不同，本示例在单个目录下有着多个源文件，此时 CMakeLists 如下：</p><pre><code class="cmake"># CMake 最低版本号要求cmake_minimum_required (VERSION 3.10)# 项目信息project (Demo2)# 查找目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable($&#123;PROJECT_NAME&#125; $&#123;DIR_SRCS&#125;)</code></pre><p>在本示例中，为了避免一个个将所有源文件输入，使用了 aux_source_directory 命令。</p><ul><li><code>aux_source_directory</code>：第一个参数是目录的路径，第二个参数是变量名。当我们使用这个命令时，就会将指定目录下的所有源文件保存到指定的变量名中。<br>如果不想使用这种方法，而是向一条条枚举每个变量，可以使用 set 来手动将源文件保存到变量名中：</li></ul><pre><code class="cmake"># CMake 最低版本号要求cmake_minimum_required (VERSION 3.10)# 项目信息project (Demo2)set(DIR_SRCS    MathFunctions.cc    main.cc)# 指定生成目标add_executable($&#123;PROJECT_NAME&#125; $&#123;DIR_SRCS&#125;)</code></pre><h4 id="多个目录下的多个源文件"><a href="#多个目录下的多个源文件" class="headerlink" title="多个目录下的多个源文件"></a>多个目录下的多个源文件</h4><p>首先查看一下本示例的目录结构：</p><pre><code>.├── CMakeLists.txt├── main.cc└── math    ├── CMakeLists.txt    ├── MathFunctions.cc    └── MathFunctions.h</code></pre><p>与上个示例不同，本示例在多个目录下有着多个源文件。在这种情况下，我们需要在每个目录中都编写一个 CMakeLists.txt。这里为了方便，我们可以将 math 里的文件编译为一个静态库再有 main 函数调用。</p><p>首先看看 math 目录下的 CMakeLists.txt，这里主要做的事是将当前目录下的文件编译为一个静态库：</p><pre><code class="cmake"># 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量aux_source_directory(. DIR_LIB_SRCS)# 指定生成 MathFunctions 链接库add_library (MathFunctions $&#123;DIR_LIB_SRCS&#125;)</code></pre><ul><li><code>add_library</code>：用于从某些源文件创建一个库，默认生成在构建文件夹。第一个参数为库名（不需要 lib 前缀，会自动添加），第二个参数用于指定 SHARED（动态库），STATIC（静态库）（如果不写，则通过全局的BUILD_SHARED_LIBS 的 FALSE 或 TRUE 来指定）。第三个参数即为源文件列表。</li></ul><p>接着看看根目录的 CMakeLists.txt：</p><pre><code class="cmake"># CMake 最低版本号要求cmake_minimum_required (VERSION 3.10)# 项目信息project (Demo3)# 查找目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 添加 math 子目录add_subdirectory(math)# 指定生成目标add_executable(Demo $&#123;DIR_SRCS&#125;)# 添加链接库target_link_libraries(Demo MathFunctions)</code></pre><ul><li><code>add_subdirectory</code>：用于表示该项目包含一个子目录，此时会去处理子目录下的 CMakeLists.txt 与源文件。</li><li><code>target_link_libraries</code>：该命令用于指明可执行文件 Demo 需要链接 MathFunctions 库。第一个参数为可执行文件名，第二个参数为访问权限（PUBLIC、PRIVATE、INTERFACE，默认为 PUBLIC），第三个参数为库名（这两个参数可以为多个）。</li></ul><h3 id="导入外部库"><a href="#导入外部库" class="headerlink" title="导入外部库"></a>导入外部库</h3><h4 id="本地导入（find-package）"><a href="#本地导入（find-package）" class="headerlink" title="本地导入（find_package）"></a>本地导入（find_package）</h4><p>首先查看一下本示例的目录结构：</p><pre><code>.├── CMakeLists.txt├── main.cpp└── README.adoc</code></pre><p>这里主要演示如何导入一个本地的第三方库（这里以 boost 为例），接着看看 MakeLists.txt：</p><pre><code class="cmake">cmake_minimum_required(VERSION 3.10)# Set the project nameproject (third_party_include)# find a boost install with the libraries filesystem and system#使用库文件系统和系统查找boost installfind_package(Boost 1.46.1 REQUIRED COMPONENTS filesystem system)#这是第三方库，而不是自己生成的静态动态库# check if boost was foundif(Boost_FOUND)    message (&quot;boost found&quot;)else()    message (FATAL_ERROR &quot;Cannot find Boost&quot;)endif()# Add an executableadd_executable(third_party_include main.cpp)# link against the boost librariestarget_link_libraries(third_party_include PRIVATE Boost::filesystem)</code></pre><p>这里使用<code>find_package</code>命令来在本地搜索对应的第三方库，Boost 代表需要查询的库名称；1.46.1 代表需要库的最低版本；REQUIRED 表示该库是必须的，如果找不到会报错；COMPONENTS 用于检测该库的对应组件是否存在，如果不存在则认为找到的库不满足条件。</p><h4 id="外部导入（FetchContent）"><a href="#外部导入（FetchContent）" class="headerlink" title="外部导入（FetchContent）"></a>外部导入（FetchContent）</h4><p><code>FetchContent</code>是<code>3.11.0</code>版本开始提供的功能，只需要一个<code>URL</code>或者<code>Git仓库</code>即可引入一个库，这里以 GoogleTest 库为例：</p><pre><code class="cmake">cmake_minimum_required(VERSION 3.14)project(my_project)# GoogleTest requires at least C++11set(CMAKE_CXX_STANDARD 11)include(FetchContent)FetchContent_Declare(  googletest  URL https://github.com/google/googletest/archive/609281088cfefc76f9d0ce82e1ff6c30cc3591e5.zip)# For Windows: Prevent overriding the parent project&#39;s compiler/linker settingsset(gtest_force_shared_crt ON CACHE BOOL &quot;&quot; FORCE)FetchContent_MakeAvailable(googletest)</code></pre><p>使用方法：</p><ol><li><code>include(FetchContent) </code>：表示引入 FetchContent。</li><li><code>FetchContent_Declare(第三方库)</code> ：获取第三方库，可以是一个 URL 或者一个 Git 仓库。</li><li><code>FetchContent_MakeAvailable(第三方库)</code> ：将这个第三方库引入项目。</li><li><code>target_link_libraries(主项目 PRIVATE 子模块::子模块) </code>：链接这个第三方库。</li></ol><h3 id="测试与安装"><a href="#测试与安装" class="headerlink" title="测试与安装"></a>测试与安装</h3><p>CMake 也可以指定安装规则，以及添加测试。这两个功能分别可以通过在产生 Makefile 后使用<code>make install</code>和<code>make test</code>来执行。<br>首先查看一下本示例的目录结构：</p><pre><code>.├── CMakeLists.txt├── config.h.in├── License.txt├── main.cc└── math    ├── CMakeLists.txt    ├── MathFunctions.cc    └── MathFunctions.h</code></pre><h4 id="自定义安装规则"><a href="#自定义安装规则" class="headerlink" title="自定义安装规则"></a>自定义安装规则</h4><p>首先查看 math 目录下的 CMakeLists.txt：</p><pre><code class="cmake"># 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量aux_source_directory(. DIR_LIB_SRCS)# 指定生成 MathFunctions 链接库add_library (MathFunctions $&#123;DIR_LIB_SRCS&#125;)# 指定 MathFunctions 库的安装路径install (TARGETS MathFunctions DESTINATION lib)install (FILES MathFunctions.h DESTINATION include)</code></pre><p>这里使用<code>install</code>命令表明了将静态库 MathFunctions 安装到 &#x2F;usr&#x2F;local&#x2F;lib 目录下，将头文件 MathFunctions.h 安装到 &#x2F;usr&#x2F;local&#x2F;include 目录下。</p><p>接着查看根目录的 install 内容：</p><pre><code class="cmake"># 指定安装路径install (TARGETS Demo DESTINATION bin)install (FILES &quot;$&#123;PROJECT_BINARY_DIR&#125;/config.h&quot; DESTINATION include)</code></pre><p>这里将可执行程序 Demo 安装到了 &#x2F;usr&#x2F;local&#x2F;lib 目录下，再将 config.h 安装到 &#x2F;usr&#x2F;local&#x2F;lib 目录下。</p><blockquote><p>&#x2F;usr&#x2F;local&#x2F; 是默认安装的根目录，可以通过修改 CMAKE_INSTALL_PREFIX 变量的值来指定这些文件应该拷贝到哪个根目录</p></blockquote><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>CMake 提供了一个称为<code>CTest</code>的测试工具。我们要做的只是在项目根目录的 CMakeLists 文件中调用一系列的<code>add_test</code>命令。</p><pre><code class="cmake"># 启用测试enable_testing()# 测试程序是否成功运行add_test (test_run Demo 5 2)# 测试帮助信息是否可以正常提示add_test (test_usage Demo)set_tests_properties (test_usage  PROPERTIES PASS_REGULAR_EXPRESSION &quot;Usage: .* base exponent&quot;)# 测试 5 的平方# add_test (test_5_2 Demo 5 2)# set_tests_properties (test_5_2#  PROPERTIES PASS_REGULAR_EXPRESSION &quot;is 25&quot;)# 测试 10 的 5 次方# add_test (test_10_5 Demo 10 5)# set_tests_properties (test_10_5#  PROPERTIES PASS_REGULAR_EXPRESSION &quot;is 100000&quot;)# 测试 2 的 10 次方# add_test (test_2_10 Demo 2 10)# set_tests_properties (test_2_10#  PROPERTIES PASS_REGULAR_EXPRESSION &quot;is 1024&quot;)# 定义一个宏，用来简化测试工作macro (do_test arg1 arg2 result)  add_test (test_$&#123;  arg1&#125;_$&#123;  arg2&#125; Demo $&#123;  arg1&#125; $&#123;  arg2&#125;)  set_tests_properties (test_$&#123;  arg1&#125;_$&#123;  arg2&#125;    PROPERTIES PASS_REGULAR_EXPRESSION $&#123;  result&#125;)endmacro (do_test)# 利用 do_test 宏，测试一系列数据do_test (5 2 &quot;is 25&quot;)do_test (10 5 &quot;is 100000&quot;)do_test (2 10 &quot;is 1024&quot;)</code></pre><ul><li><code>enable_testing</code>：用于启动测试。</li><li><code>add_test</code>：用于添加测试，第一个参数为测试名，第二个参数为可执行程序，剩下的为可执行程序的参数。</li><li><code>set_tests_properties</code>：测试的提示信息。</li><li><code>macro</code>：宏，用于编写一个重复性操作来简化测试用例的编写。</li><li><code>do_test</code>：编写的测试宏。</li></ul><h4 id="生成安装包"><a href="#生成安装包" class="headerlink" title="生成安装包"></a>生成安装包</h4><p>如果想要生成安装包，则需要使用<code>CPack</code>，它是由 CMake 提供的一个工具，专门用于打包。此时需要在 CMakeLists.txt 中添加以下内容：</p><pre><code class="cmake"># 构建一个 CPack 安装包include (InstallRequiredSystemLibraries)set (CPACK_RESOURCE_FILE_LICENSE  &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/License.txt&quot;)set (CPACK_PACKAGE_VERSION_MAJOR &quot;$&#123;Demo_VERSION_MAJOR&#125;&quot;)set (CPACK_PACKAGE_VERSION_MINOR &quot;$&#123;Demo_VERSION_MINOR&#125;&quot;)include (CPack)</code></pre><ul><li><code>include (InstallRequiredSystemLibraries)</code>：导入 InstallRequiredSystemLibraries 模块。</li><li>设置一些 CPack 相关变量。</li><li><code>include (CPack)</code>：导入 CPack 模块。</li></ul><p>接着执行 cmake 和 make 构建工程，此时再执行 cpack 命令即可生成安装包：</p><pre><code class="cmake">#生成二进制安装包cpack -C CPackConfig.cmake#生成源码安装包cpack -C CPackSourceConfig.cmake</code></pre><p>当命令执行成功后，就会在当前目录下生成 <em>.sh、</em>.tar.gz、*.tar.Z 这三个格式的安装包。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmake </tag>
            
            <tag> make </tag>
            
            <tag> 程序构建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++八股文</title>
      <link href="/2024/03/23/C-%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/03/23/C-%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="C-八股文"><a href="#C-八股文" class="headerlink" title="C++八股文"></a>C++八股文</h1><h2 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h2><h3 id="1-1-在main执行之前和之后执行的代码可能是什么？"><a href="#1-1-在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="1.1 在main执行之前和之后执行的代码可能是什么？"></a>1.1 在main执行之前和之后执行的代码可能是什么？</h3><p><strong>main函数执行之前，主要就是初始化系统相关资源：</strong></p><ul><li>设置栈指针</li><li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li><li>将未初始化部分的全局变量赋初值：数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，<code>bool</code>为<code>FALSE</code>，<code>指针</code>为<code>NULL</code>等等，即<code>.bss</code>段的内容</li><li>将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li><li>执行<code>__attribute__((constructor))</code>，与golang的init()函数类似</li></ul><p><strong>main函数完成后：</strong></p><ul><li>全局对象的析构函数</li><li>可以用<code>atexit</code>注册一个函数，它会在<code>main</code>之后执行;</li><li><code>__attribute__((destructor))</code></li></ul><h3 id="1-2-结构体内存对齐问题？"><a href="#1-2-结构体内存对齐问题？" class="headerlink" title="1.2 结构体内存对齐问题？"></a>1.2 结构体内存对齐问题？</h3><ul><li>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</li><li>未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）</li></ul><p>c++11以后引入两个关键字<a href="https://zh.cppreference.com/w/cpp/language/alignas"><code>alignas</code></a>与<a href="https://zh.cppreference.com/w/cpp/language/alignof"><code>alignof</code></a>。其中<code>alignof</code>可以计算出类型的对齐方式，<code>alignas</code>可以指定结构体的对齐方式。但是仍有需要注意的点：</p><ul><li>若<code>alignas</code>小于自然对齐的最小单位，则被忽略。</li><li>如果想使用单字节对齐的方式，使用<code>alignas</code>是无效的。应该使用<code>#pragma pack(push,1)</code>或者使用<code>__attribute__((packed))</code>。</li></ul><p>用法如下：</p><pre><code class="C++">// 无效的指定 因为2小于自然对齐的大小uint32_t(4)struct alignas(2) Info2 &#123;  uint8_t a;  uint32_t b;  uint8_t c;&#125;;</code></pre><h3 id="1-3-指针和引用的区别"><a href="#1-3-指针和引用的区别" class="headerlink" title="1.3 指针和引用的区别"></a>1.3 指针和引用的区别</h3><ul><li>指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名</li><li>指针可以有多级，引用只有一级</li><li>指针可以为空，引用不能为NULL且在定义时必须初始化</li><li>指针在初始化后可以改变指向，而引用在初始化之后不可再改变</li><li>sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</li><li>引用本质是一个指针，同样会占4&#x2F;8字节内存，不过编译器对它进行了一些处理，使得程序认为它不单独占用内存空间；指针是具体变量，需要占用存储空间。</li><li>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</li><li>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</li></ul><h3 id="1-4-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"><a href="#1-4-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？" class="headerlink" title="1.4 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"></a>1.4 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</h3><ul><li>需要操作内存的时候传指针。</li><li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小。</li><li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式。</li></ul><h3 id="1-5-堆和栈的区别"><a href="#1-5-堆和栈的区别" class="headerlink" title="1.5 堆和栈的区别"></a>1.5 堆和栈的区别</h3><ul><li><p>申请方式不同。</p><p>栈由系统自动分配。<br>堆是自己申请和释放的。</p></li><li><p>申请大小限制不同。</p><p>栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。<br>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。<br>栈空间默认是4M, 堆区一般是 1G - 4G</p></li><li><p>申请效率不同。</p><p>栈由系统分配，速度快，不会有碎片。<br>堆由程序员分配，速度慢，且会有碎片。</p></li></ul><h3 id="1-6-栈为什么比堆执行快？"><a href="#1-6-栈为什么比堆执行快？" class="headerlink" title="1.6 栈为什么比堆执行快？"></a>1.6 栈为什么比堆执行快？</h3><ol><li><p>栈内存的快速访问主要是因为它通常位于主存中的相对较小的内存区域，这使得 CPU 缓存（包括一级缓存）中的数据能够快速加载到处理器中。此外，栈内存的顺序访问模式也有助于提高缓存的命中率。    </p></li><li><p>堆内存访问首先要从内存读指针地址，然后再用这个指针地址加偏移量去访问堆内存，这就导致了多一个读指令。另外，堆内存很可能不处于缓存里，尤其是第一次访问，如果再发生缺页中断会导致堆和栈出现巨大的速度差异。</p></li><li><p>堆内存需要做内存申请，这是极为耗时的操作，如果把内存申请的消耗计算在内，那栈内存的综合速度优势就又多了一项。</p></li></ol><h3 id="1-7-区别以下指针类型？"><a href="#1-7-区别以下指针类型？" class="headerlink" title="1.7 区别以下指针类型？"></a>1.7 区别以下指针类型？</h3><pre><code class="C++">int *p[10]int (*p)[10]int *p(int)int (*p)(int)</code></pre><ul><li><p>int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</p></li><li><p>int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</p></li><li><p>int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</p></li><li><p>int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</p></li></ul><h3 id="1-8-new-delete-与-malloc-free的异同"><a href="#1-8-new-delete-与-malloc-free的异同" class="headerlink" title="1.8 new &#x2F; delete 与 malloc &#x2F; free的异同"></a>1.8 new &#x2F; delete 与 malloc &#x2F; free的异同</h3><ul><li><p>相同点</p><ul><li>都可用于内存的动态申请和释放</li></ul></li><li><p>不同点</p><ul><li>前者是C++运算符，后者是C&#x2F;C++语言标准库函数</li><li>new自动计算要分配的空间大小，malloc需要手工计算</li><li>new是类型安全的，malloc不是。例如：</li></ul><pre><code>int *p = new float[2]; //编译错误*p = (int*)malloc(2 * sizeof(double));//编译无错误</code></pre><ul><li>new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者均没有相关调用</li><li>后者需要库文件支持，前者不用</li><li>new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象</li></ul></li></ul><h3 id="1-9-被free回收的内存是立即返还给操作系统吗？"><a href="#1-9-被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="1.9 被free回收的内存是立即返还给操作系统吗？"></a>1.9 被free回收的内存是立即返还给操作系统吗？</h3><ul><li>不是的，被free回收的内存会首先被内存管理系统的自由列表（free list）保存起来。常见的如ptmalloc使用双链表保存内存块，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</li></ul><h3 id="1-10-宏定义和typedef区别？"><a href="#1-10-宏定义和typedef区别？" class="headerlink" title="1.10 宏定义和typedef区别？"></a>1.10 宏定义和typedef区别？</h3><ul><li><p>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</p></li><li><p>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</p></li><li><p>宏不检查类型；typedef会检查数据类型。</p></li><li><p>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</p></li><li><p>注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。</p></li></ul><h3 id="1-11-strlen和sizeof区别？"><a href="#1-11-strlen和sizeof区别？" class="headerlink" title="1.11 strlen和sizeof区别？"></a>1.11 strlen和sizeof区别？</h3><ul><li><p>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</p></li><li><p>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</p></li><li><p>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</p></li></ul><h3 id="1-12-一个指针占多少字节？"><a href="#1-12-一个指针占多少字节？" class="headerlink" title="1.12 一个指针占多少字节？"></a>1.12 一个指针占多少字节？</h3><ul><li><p>在64位的编译环境下，指针的占用大小为8字节；</p></li><li><p>而在32位环境下，指针占用大小为4字节。</p></li><li><p>一个指针占内存的大小跟编译环境有关，而与机器的位数无关。</p></li><li><p>还有疑问的，可以自行打开Visual Studio编译器自己实验一番。</p></li></ul><h3 id="1-13-常量指针和指针常量区别？"><a href="#1-13-常量指针和指针常量区别？" class="headerlink" title="1.13 常量指针和指针常量区别？"></a>1.13 常量指针和指针常量区别？</h3><ul><li><strong>常量指针</strong>是一个指针，读成常量的指针，指向一个只读变量，也就是后面所指明的int const 和 const int，都是一个常量，可以写作：<ul><li>int const *<strong>p</strong></li><li>const int *<strong>p</strong>。</li></ul></li></ul><blockquote><p><strong>常量指针</strong>-&gt;指向常量的指针<br><strong>常量指针</strong>-&gt;不可改变内容，但可以改变指向的地址。 </p></blockquote><ul><li><strong>指针常量</strong>是一个常量，必须初始化，一旦初始化完成，它的值（也就是存放在指针中的地址）就不能在改变了，即不能中途改变指向，如：<ul><li>int *const <strong>p</strong>。<blockquote><p><strong>指针常量</strong>-&gt;常量<br><strong>指针常量</strong>-&gt;不可改变指向的地址，但可以改变地址存放的数据。</p></blockquote></li></ul></li></ul><h3 id="1-13-2-顶层const与底层const"><a href="#1-13-2-顶层const与底层const" class="headerlink" title="1.13.2 顶层const与底层const"></a>1.13.2 顶层const与底层const</h3><ul><li>顶层const：指针本身是一个常量；</li><li>底层const：指针所指对象是一个常量；</li></ul><h3 id="1-14-C-和C语言的区别"><a href="#1-14-C-和C语言的区别" class="headerlink" title="1.14 C++和C语言的区别"></a>1.14 C++和C语言的区别</h3><ul><li><strong>面向对象编程（OOP）</strong>：<br>C++ 是一种支持面向对象编程的语言，它引入了类和对象的概念，以及封装、继承和多态等面向对象的特性。<br>C 语言虽然也可以编写面向对象的代码，但它没有内建的语言特性来支持面向对象编程，因此需要使用结构体和函数来模拟类和对象。</li><li><strong>标准库</strong>：<br>C++ 标准库（STL）提供了许多丰富的数据结构和算法，如向量、列表、映射、排序和搜索等。<br>C 语言的标准库相对较小，只提供了一些基本的数据类型和函数，如整数、字符、字符串和文件处理等。</li><li><strong>内存管理</strong>：<br>C++ 支持动态内存分配和释放，引入了 new 和 delete 运算符用于动态分配和释放内存。<br>C 语言也支持动态内存分配和释放，但是使用的是 malloc() 和 free() 函数。</li><li><strong>异常处理</strong>：<br>C++ 支持异常处理机制，可以使用 try、catch 和 throw 关键字来处理异常情况。<br>C 语言没有内建的异常处理机制，通常通过返回值或错误码来处理异常情况。</li><li><strong>其他特性</strong>：<br>C++ 还引入了许多其他特性，如模板、命名空间、运算符重载和函数重载等，以提高代码的灵活性和可复用性。<br>C 语言相对较简单，更加接近硬件和操作系统，因此更适用于系统级编程和嵌入式开发。</li></ul><p>总的来说，C++ 是在 C 语言基础上发展而来的，它继承了 C 语言的一些特性，并引入了更多的高级特性，如面向对象编程和异常处理等，使得它更加适用于大型项目和复杂的软件开发。</p><h3 id="1-15-C-中struct和class的区别"><a href="#1-15-C-中struct和class的区别" class="headerlink" title="1.15 C++中struct和class的区别"></a>1.15 C++中struct和class的区别</h3><ul><li><p>相同点  </p><p>两者都拥有成员函数、公有和私有部分<br>任何可以使用class完成的工作，同样可以使用struct完成</p></li><li><p>不同点</p><p>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</p><p>class默认是private继承， 而struct默认是public继承</p></li></ul><h3 id="1-16-define宏定义和const的区别"><a href="#1-16-define宏定义和const的区别" class="headerlink" title="1.16 define宏定义和const的区别"></a>1.16 define宏定义和const的区别</h3><p><strong>编译阶段</strong></p><ul><li>define是在编译的<code>预处理阶段</code>起作用，而const是在<code>编译、运行</code>的时候起作用</li></ul><p><strong>安全性</strong></p><ul><li>define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错  </li><li>const常量有数据类型，编译器可以对其进行类型安全检查</li></ul><p><strong>内存占用</strong></p><ul><li>define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表</li></ul><h3 id="1-17-数组名和指针（这里为指向数组首元素的指针）区别？"><a href="#1-17-数组名和指针（这里为指向数组首元素的指针）区别？" class="headerlink" title="1.17 数组名和指针（这里为指向数组首元素的指针）区别？"></a>1.17 数组名和指针（这里为指向数组首元素的指针）区别？</h3><ul><li><p>二者均可通过增减偏移量来访问数组中的元素。</p></li><li><p>数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</p></li><li><p><strong>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</strong></p></li></ul><h3 id="1-18-extern”C”的用法"><a href="#1-18-extern”C”的用法" class="headerlink" title="1.18 extern”C”的用法"></a>1.18 extern”C”的用法</h3><ul><li>为了能够正确的在C++代码中调用C语言的代码：在程序中加上extern “C”后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++。</li></ul><h3 id="1-19-野指针和悬空指针"><a href="#1-19-野指针和悬空指针" class="headerlink" title="1.19 野指针和悬空指针"></a>1.19 野指针和悬空指针</h3><pre><code>都是是指向无效内存区域(这里的无效指的是&quot;不安全不可控&quot;)的指针，访问行为将会导致未定义行为。</code></pre><ul><li><strong>野指针</strong><br>野指针，指的是没有被初始化过的指针</li><li><strong>悬空指针</strong><br>悬空指针，指针最初指向的内存已经被释放了的一种指针。</li></ul><p>使用智能指针可以有效解决问题。</p><h3 id="1-20-C-中的重载、重写（覆盖）和隐藏的区别"><a href="#1-20-C-中的重载、重写（覆盖）和隐藏的区别" class="headerlink" title="1.20 C++中的重载、重写（覆盖）和隐藏的区别"></a>1.20 C++中的重载、重写（覆盖）和隐藏的区别</h3><ol><li><p><strong>重载（overload）</strong><br>  重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是<code>返回类型</code>和<code>函数名</code>相同，<code>参数类型和数目</code>有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个例子：</p></li><li><p><strong>重写（覆盖）（override）</strong><br>  重写指的是在派生类中覆盖基类中的同名函数，重写就是重写函数体，要求基类函数必须是虚函数且：</p><ul><li>与基类的虚函数有相同的参数个数</li><li>与基类的虚函数有相同的参数类型</li><li>与基类的虚函数有相同的返回值类型</li></ul></li><li><p><strong>隐藏（hide）</strong><br>  隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：</p><ul><li>两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。</li></ul><pre><code class="C++">  //父类  class A&#123;  public:      void fun(int a)&#123;      cout &lt;&lt; &quot;A中的fun函数&quot; &lt;&lt; endl;    &#125;  &#125;;  //子类  class B : public A&#123;  public:      //隐藏父类的fun函数      void fun(int a)&#123;      cout &lt;&lt; &quot;B中的fun函数&quot; &lt;&lt; endl;    &#125;  &#125;;  int main()&#123;      B b;      b.fun(2); //调用的是B中的fun函数      b.A::fun(2); //调用A中fun函数      return 0;  &#125;</code></pre><ul><li>两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。</li></ul><pre><code class="C++">  //父类  class A&#123;  public:      virtual void fun(int a)&#123;      cout &lt;&lt; &quot;A中的fun函数&quot; &lt;&lt; endl;    &#125;  &#125;;  //子类  class B : public A&#123;  public:      //隐藏父类的fun函数    virtual void fun(char* a)&#123;      cout &lt;&lt; &quot;A中的fun函数&quot; &lt;&lt; endl;    &#125;  &#125;;  int main()&#123;      B b;      b.fun(2); //报错，调用的是B中的fun函数，参数类型不对      b.A::fun(2); //调用A中fun函数      return 0;  &#125;</code></pre></li></ol><h3 id="1-21-浅拷贝和深拷贝的区别"><a href="#1-21-浅拷贝和深拷贝的区别" class="headerlink" title="1.21 浅拷贝和深拷贝的区别"></a>1.21 浅拷贝和深拷贝的区别</h3><ul><li><p><strong>浅拷贝</strong>  </p><p>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p></li><li><p><strong>深拷贝</strong></p><p>深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。</p></li></ul><h3 id="1-22-内联函数和宏定义的区别"><a href="#1-22-内联函数和宏定义的区别" class="headerlink" title="1.22 内联函数和宏定义的区别"></a>1.22 内联函数和宏定义的区别</h3><ul><li>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。</li><li>内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。</li><li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义<br>内联函数有类型检测、语法判断等功能，而宏没有<blockquote><p>注意：使用<code>inline</code>关键字只是建议编译器内联函数，内联函数是否真的内联还需要编译器判断。</p></blockquote></li></ul><h3 id="1-23-public，protected和private访问和继承权限-public-protected-private的区别？"><a href="#1-23-public，protected和private访问和继承权限-public-protected-private的区别？" class="headerlink" title="1.23 public，protected和private访问和继承权限&#x2F;public&#x2F;protected&#x2F;private的区别？"></a>1.23 public，protected和private访问和继承权限&#x2F;public&#x2F;protected&#x2F;private的区别？</h3><ul><li><p><strong>访问权限</strong></p><ul><li><p>public的变量和函数在类的内部外部都可以访问。</p></li><li><p>protected的变量和函数只能在类的内部和其派生类中访问。</p></li><li><p>private修饰的元素只能在类内访问。</p></li></ul></li><li><p><strong>继承权限</strong></p><ul><li><p>public继承（公有继承）的特点是基类的公有成员和保护成员作为派生类的成员时，都保持原有的状态，而基类的私有成员任然是私有的，不能被这个派生类的子类所访问</p></li><li><p>protected继承（保护继承）的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元函数访问，基类的私有成员仍然是私有的</p></li><li><p>private继承（私有继承）的特点是基类的所有公有成员和保护成员都成为派生类的私有成员，并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承</p></li></ul></li></ul><h3 id="1-24-如何用代码判断大小端存储？"><a href="#1-24-如何用代码判断大小端存储？" class="headerlink" title="1.24 如何用代码判断大小端存储？"></a>1.24 如何用代码判断大小端存储？</h3><ul><li><p>大端存储：字数据的高字节存储在低地址中  –&gt; 高位在前</p></li><li><p>小端存储：字数据的低字节存储在低地址中  –&gt; 高位在后</p><p>使用强制类型转换判断大小端存储</p><pre><code class="C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int a = 0x1234;    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分    char c = (char)(a);    if (c == 0x12)        cout &lt;&lt; &quot;big endian&quot; &lt;&lt; endl;    else if(c == 0x34)        cout &lt;&lt; &quot;little endian&quot; &lt;&lt; endl;&#125;</code></pre></li></ul><h3 id="1-25-volatile、mutable和explicit关键字的用法"><a href="#1-25-volatile、mutable和explicit关键字的用法" class="headerlink" title="1.25 volatile、mutable和explicit关键字的用法"></a>1.25 volatile、mutable和explicit关键字的用法</h3><ol><li><p><strong>volatile</strong><br>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</p></li><li><p><strong>mutable</strong><br>mutable的中文意思是“可变的，易变的”，跟constant（即C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要<code>在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置</code>。</p></li></ol><pre><code class="C++">class person&#123;    int m_A;    mutable int m_B;//特殊变量 在常函数里值也可以被修改public:    void add() const//在函数里不可修改this指针指向的值 常量指针    &#123;        m_A = 10;//错误  不可修改值，this已经被修饰为常量指针        m_B = 20;//正确    &#125;&#125;;</code></pre><pre><code class="C++">class person&#123;public:    int m_A;    mutable int m_B;//特殊变量 在常函数里值也可以被修改&#125;;int main()&#123;    const person p = person();//修饰常对象 不可修改类成员的值    p.m_A = 10;//错误，被修饰了指针常量    p.m_B = 200;//正确，特殊变量，修饰了mutable&#125;</code></pre><ol start="3"><li><p><strong>explicit</strong><br>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显式的方式进行类型转换，注意以下几点：</p><ul><li>explicit 关键字只能用于类内部的构造函数声明上</li><li>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</li></ul></li></ol><h3 id="1-26-C-的异常处理的方法"><a href="#1-26-C-的异常处理的方法" class="headerlink" title="1.26 C++的异常处理的方法"></a>1.26 C++的异常处理的方法</h3><p>在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：</p><ul><li>数组下标越界</li><li>除法计算时除数为0</li><li>动态分配空间时空间不足</li></ul><p>如果不及时对这些异常进行处理，程序多数情况下都会崩溃。</p><p>C++中的异常处理机制主要使用try、throw和catch三个关键字，其在程序中的用法如下：</p><pre><code class="C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    double m = 1, n = 0;    try &#123;        cout &lt;&lt; &quot;before dividing.&quot; &lt;&lt; endl;        if (n == 0)            throw - 1;  //抛出int型异常        else if (m == 0)            throw - 1.0;  //拋出 double 型异常        else            cout &lt;&lt; m / n &lt;&lt; endl;        cout &lt;&lt; &quot;after dividing.&quot; &lt;&lt; endl;    &#125;    catch (double d) &#123;        cout &lt;&lt; &quot;catch (double)&quot; &lt;&lt; d &lt;&lt; endl;    &#125;    catch (...) &#123;        cout &lt;&lt; &quot;catch (...)&quot; &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;finished&quot; &lt;&lt; endl;    return 0;&#125;</code></pre><p>代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。<br><strong>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）。</strong><br>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以<code>在catch里面再throw异常</code>。</p><h3 id="1-27-static的用法和作用？"><a href="#1-27-static的用法和作用？" class="headerlink" title="1.27 static的用法和作用？"></a>1.27 static的用法和作用？</h3><ol><li><p>先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）<br>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</p></li><li><p>static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。</p></li><li><p>static的第三个作用是默认初始化为0（static变量）<br>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。</p></li><li><p>static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；</p></li><li><p>由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问static修饰的类成员；</p></li><li><p>static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this-&gt;vptr-&gt;ctable-&gt;virtual function</p></li></ol><h3 id="1-28-成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？"><a href="#1-28-成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？" class="headerlink" title="1.28 成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"></a>1.28 成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</h3><p>赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化。<br>这两种方式的主要区别在于：</p><ul><li><p>对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。</p></li><li><p>列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。</p></li></ul><h3 id="1-29-有哪些情况必须用到成员列表初始化？作用是什么？"><a href="#1-29-有哪些情况必须用到成员列表初始化？作用是什么？" class="headerlink" title="1.29 有哪些情况必须用到成员列表初始化？作用是什么？"></a>1.29 有哪些情况必须用到成员列表初始化？作用是什么？</h3><ul><li><p><strong>常量成员变量：</strong></p><p>如果类中包含<code>const</code>或者<code>引用类型</code>的成员变量，则必须使用成员列表初始化对它们进行初始化。<br>因为常量成员变量和引用类型成员变量无法在构造函数内部进行赋值，只能通过成员列表初始化来初始化它们。  </p></li><li><p><strong>继承的成员变量：</strong></p><p>如果<code>派生类继承了基类的成员变量，且基类没有默认构造函数</code>，则必须使用成员列表初始化来调用基类的构造函数对基类成员变量进行初始化。  </p></li><li><p><strong>成员对象：</strong></p><p>如果<code>类中包含其他类对象作为成员变量</code>，则最好使用成员列表初始化对这些成员对象进行初始化。<br>这样可以避免在构造函数体内部对成员对象进行默认初始化后再赋值，而直接在构造函数的初始化列表中完成初始化。</p></li></ul><h3 id="1-30-什么是内存泄露，如何检测与避免"><a href="#1-30-什么是内存泄露，如何检测与避免" class="headerlink" title="1.30 什么是内存泄露，如何检测与避免"></a>1.30 什么是内存泄露，如何检测与避免</h3><ul><li><p>内存泄露</p><p>一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了</p></li><li><p>避免内存泄露的几种方式</p><ul><li>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</li><li>一定要将基类的析构函数声明为虚函数</li><li>对象数组的释放一定要用delete []</li><li>有new就有delete，有malloc就有free，保证它们一定成对出现</li></ul></li><li><p>检测工具</p><ul><li>Linux下可以使用Valgrind工具  </li><li>Windows下可以使用CRT库</li></ul></li></ul><h3 id="1-31-对象复用的了解，零拷贝的了解"><a href="#1-31-对象复用的了解，零拷贝的了解" class="headerlink" title="1.31 对象复用的了解，零拷贝的了解"></a>1.31 对象复用的了解，零拷贝的了解</h3><ul><li><p>对象复用：</p><ul><li>对象复用是指在程序执行过程中，重复使用已经创建的对象，而不是频繁地创建新的对象。通过对象复用，可以减少资源的消耗和提高性能。</li><li>对象复用通常适用于那些需要频繁创建和销毁的对象，比如线程池中的线程对象、连接池中的数据库连接等。通过将这些对象创建一次，然后在需要时重复利用，可以避免反复创建对象的开销，提高系统的效率。</li></ul></li><li><p>零拷贝：</p><ul><li>零拷贝是一种优化技术，用于在数据传输过程中减少或消除不必要的数据拷贝操作。通过零拷贝技术，可以提高数据传输的效率和降低系统的负载。</li><li>零拷贝通常应用于文件传输、网络通信等场景中。例如，在网络通信中，零拷贝技术可以避免将数据从用户空间拷贝到内核空间，再从内核空间拷贝到网络缓冲区的过程，而是直接在用户空间和网络缓冲区之间进行数据传输，从而提高了数据传输的效率。</li><li>零拷贝的主要实现有mmap() （内存映射）</li></ul></li></ul><blockquote><p>DMA(Direct Memory Access-直接内存访问)和零拷贝详细介绍 -&gt; <a href="https://zhuanlan.zhihu.com/p/360343446">【linux】图文并茂|彻底搞懂零拷贝（Zero-Copy）技术</a></p></blockquote><h3 id="1-32-C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast"><a href="#1-32-C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast" class="headerlink" title="1.32 C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast &#x2F;dynamic_cast"></a>1.32 C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast &#x2F;dynamic_cast</h3><ul><li><p>reinterpret_cast：</p><ul><li>reinterpret_cast 可以用于将一个指针或引用转换为另一种不同类型的指针或引用。它可以执行任意类型之间的转换，甚至是不兼容的类型。</li><li>reinterpret_cast 对转换的类型没有限制，它不进行类型检查，因此需要谨慎使用。</li><li>reinterpret_cast 主要用于进行底层的类型转换，如指针之间的转换或者将整数类型转换为指针类型等。</li></ul></li><li><p>const_cast：</p><ul><li>const_cast 主要用于去除表达式中的 const 或 volatile 修饰符，以便修改被修饰对象的值。</li><li>const_cast 只能用于去除 const 或 volatile 限定符，不能进行其他类型的转换。</li><li>const_cast 的使用场景通常是在需要对 const 对象进行修改时，或者在调用函数时需要去除函数参数的 const 修饰符。</li></ul></li><li><p>static_cast：</p><ul><li>static_cast 用于执行静态类型转换，可以在编译时进行类型检查，因此比较安全。</li><li>static_cast 可以执行基本类型之间的转换，如整数之间的转换、指针类型之间的转换，以及类之间的上行转换（派生类指针向基类指针的转换）和下行转换（基类指针向派生类指针的转换）。</li><li>static_cast 也可以用于显式调用构造函数和转换构造函数进行类型转换。</li></ul></li><li><p>dynamic_cast：</p><ul><li>dynamic_cast 用于执行动态类型转换，主要用于在运行时进行类型检查和转换，通常用于处理继承关系的类。</li><li>dynamic_cast 只能用于类类型之间的转换，并且其中至少一个类必须具有虚函数。它用于在类层次结构中安全地进行上行转换和下行转换，并且在转换失败时返回 nullptr（对于指针类型）或抛出 std::bad_cast 异常（对于引用类型）。</li></ul></li></ul><h3 id="1-33-写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？"><a href="#1-33-写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？" class="headerlink" title="1.33 写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？"></a>1.33 写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？</h3><p>  coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p><p>  如何使用gdb调试coredump：</p><ul><li>分析core dump：使用调试工具（如gdb）来分析core dump文件。可以通过以下命令来启动gdb并加载core dump文件：  <pre><code class="bash">gdb [可执行文件名] [core文件名]</code></pre></li><li>查看崩溃位置：在gdb中可以使用backtrace命令（简写为bt）来查看程序崩溃时的调用栈，这可以帮助你找到崩溃位置。命令如下：<pre><code class="bash">(gdb) bt</code></pre></li><li>查看变量状态：通过在崩溃位置设置断点，并使用print命令来查看变量的值，可以帮助你理解程序崩溃的原因。例如：<pre><code class="bash">(gdb) break &lt;line_number&gt;(gdb) run(gdb) print &lt;variable_name&gt;</code></pre></li></ul><h3 id="1-34-说说移动构造函数"><a href="#1-34-说说移动构造函数" class="headerlink" title="1.34 说说移动构造函数"></a>1.34 说说移动构造函数</h3><p>移动构造函数是C++11引入的一个特性，它允许在对象的所有权转移时执行高效的资源移动，而不是传统的拷贝。移动构造函数通常用于实现在不再需要源对象的情况下，将其内容“移动”到新创建的对象中，从而避免不必要的内存分配和数据复制。</p><p>移动构造函数的语法如下：</p><pre><code class="c++">class MyClass &#123;public:    // 移动构造函数    MyClass(MyClass&amp;&amp; other) noexcept &#123;        // 在此处执行资源的移动操作        // 将other对象的资源转移到当前对象中    &#125;&#125;;</code></pre><p>在移动构造函数中，参数通常是一个右值引用（通过使用双引号&amp;&amp;），表示将要被移动的对象。关键字<code>noexcept</code>是一个可选的说明符，表示该函数不会抛出异常。这对于某些情况下的优化是有帮助的。</p><p>移动构造函数通常用于以下几种情况：</p><ol><li>当返回临时对象时，避免不必要的拷贝。例如：<pre><code class="c++">MyClass createObject() &#123;    MyClass temp;    // 初始化temp对象    return temp; // 调用移动构造函数而不是拷贝构造函数&#125;</code></pre></li><li>当将一个对象插入容器时，可以使用移动构造函数将对象移入容器中，而不是复制：<pre><code class="c++">std::vector&lt;MyClass&gt; myVector;MyClass obj;myVector.push_back(std::move(obj)); // 使用 std::move 将对象移入容器中</code></pre></li><li>当需要动态分配内存时，可以使用移动语义来避免额外的内存拷贝。</li></ol><h3 id="1-35-C-中将临时变量作为返回值时的处理过程"><a href="#1-35-C-中将临时变量作为返回值时的处理过程" class="headerlink" title="1.35 C++中将临时变量作为返回值时的处理过程"></a>1.35 C++中将临时变量作为返回值时的处理过程</h3><p>首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</p><p>C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit</p><p>由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系</p><p>如果我们需要返回值，一般使用赋值语句就可以了。</p><h3 id="1-36-如何获得结构成员相对于结构开头的字节偏移量"><a href="#1-36-如何获得结构成员相对于结构开头的字节偏移量" class="headerlink" title="1.36 如何获得结构成员相对于结构开头的字节偏移量"></a>1.36 如何获得结构成员相对于结构开头的字节偏移量</h3><p>使用&lt;stddef.h&gt;头文件中的，offsetof宏。</p><pre><code class="C++">#include &lt;cstddef&gt;#include &lt;iostream&gt;struct MyStruct &#123;    int a;    char b;    double c;&#125;;int main() &#123;    std::cout &lt;&lt; &quot;Offset of &#39;a&#39; in MyStruct: &quot; &lt;&lt; offsetof(MyStruct, a) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Offset of &#39;b&#39; in MyStruct: &quot; &lt;&lt; offsetof(MyStruct, b) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Offset of &#39;c&#39; in MyStruct: &quot; &lt;&lt; offsetof(MyStruct, c) &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>输出：</p><pre><code class="sql">Offset of &#39;a&#39; in MyStruct: 0Offset of &#39;b&#39; in MyStruct: 4Offset of &#39;c&#39; in MyStruct: 8</code></pre><h3 id="1-37-怎样判断两个浮点数是否相等？"><a href="#1-37-怎样判断两个浮点数是否相等？" class="headerlink" title="1.37 怎样判断两个浮点数是否相等？"></a>1.37 怎样判断两个浮点数是否相等？</h3><p>对两个浮点数判断大小和是否相等不能直接用&#x3D;&#x3D;来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过<code>相减并与预先设定的精度比较</code>，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。</p><h3 id="1-38-C-的标准库，STL及std的区别"><a href="#1-38-C-的标准库，STL及std的区别" class="headerlink" title="1.38 C++的标准库，STL及std的区别"></a>1.38 C++的标准库，STL及std的区别</h3><ul><li>std（Standard）</li><li>STL（Standard Template Library）  </li><li>STL是标准模板库，是标准库的子集。主要是容器、算法、迭代器。标准库还包括stream，string等，STL大约占了标准库内容得80%</li><li>std是命名空间的名字，目的是为了避免命名空间污染。模板库（包括stl）的设计者，特意在库文件里面加上了命名空间。这样，我们使用者就可以在定义自己的函数时，定义自己的命名空间。然后在自己定义的命名空间作用域范围内，使用我们自己定义的、但可能和标准库里的函数重名的函数。这样就不会有函数冲突了，使用时注意命名空间的作用域就好了！</li><li>模板库（包括stl，stream,string）中的所有名字的使用都得通过std::。</li></ul><h3 id="1-39-C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"><a href="#1-39-C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？" class="headerlink" title="1.39 C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"></a>1.39 C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</h3><p>在 C++ 中，指针参数传递和引用参数传递都可以用于实现函数之间的参数传递，它们之间有一些区别：</p><ol><li>指针参数传递：  <ul><li>指针参数传递是通过将参数声明为指针类型来实现的。在函数内部，可以通过解引用指针来访问参数所指向的对象。</li><li>指针参数传递需要在函数调用时传递指针的地址，因此需要额外的内存空间存储指针地址。（本质上是值传递，它所传递的是一个地址值。）</li><li>指针参数可以为空（即指向空指针），因此需要在函数内部进行空指针检查，以防止出现空指针异常。</li></ul></li><li>引用参数传递：  <ul><li>引用参数传递是通过将参数声明为引用类型来实现的。在函数内部，引用参数直接绑定到传递给函数的对象上，不需要解引用操作。</li><li>引用参数传递不需要额外的内存空间存储地址，因为引用本身就是目标对象的别名。</li><li>引用参数不能为空，因为引用必须引用一个有效的对象。</li></ul></li></ol><p>底层原理：  </p><ul><li>指针参数传递的底层原理是将指针的值（即地址）传递给函数，函数内部通过解引用指针来访问所指向的对象。</li><li>引用参数传递的底层原理是将引用绑定到传递给函数的对象上，因此在函数内部直接操作引用就相当于操作原始对象。</li></ul><p>总的来说，引用参数传递更加简洁和安全，因为它不需要对空指针进行检查，并且在函数调用时不会产生额外的开销。但是在某些情况下，指针参数传递可能更加灵活，例如需要允许空指针传递的情况。</p><h3 id="1-40-类如何实现只能静态分配和只能动态分配"><a href="#1-40-类如何实现只能静态分配和只能动态分配" class="headerlink" title="1.40 类如何实现只能静态分配和只能动态分配"></a>1.40 类如何实现只能静态分配和只能动态分配</h3><ul><li><strong>只能静态分配的类：</strong><br>如果希望类的对象只能在栈上分配，可以通过禁用类的动态内存分配来实现：<ul><li>删除<code>new</code>和<code>delete</code>运算符的重载</li><li>将它们声明为私有成员，以阻止类的用户使用动态内存分配<pre><code class="cpp">class StaticAllocatedClass &#123;public:    // 禁用 new 和 delete 运算符    void* operator new(std::size_t) = delete;    void operator delete(void*) = delete;&#125;;</code></pre></li></ul></li><li><strong>只能动态分配的类：</strong>  <ul><li>如果希望类的对象只能在堆上分配，可以在类中重载<code>new</code>和<code>delete</code>运算符，并将它们设置为私有或者保护成员，以防止用户直接调用。<pre><code class="cpp">class DynamicAllocatedClass &#123;public:    // 重载 new 和 delete 运算符    void* operator new(std::size_t size) &#123;        return ::operator new(size);    &#125;    void operator delete(void* ptr) &#123;        ::operator delete(ptr);    &#125;private:    // 防止直接创建对象    DynamicAllocatedClass() &#123;&#125;&#125;;</code></pre></li></ul></li></ul><h3 id="1-41-知道C-中的组合吗？它与继承相比有什么优缺点吗？"><a href="#1-41-知道C-中的组合吗？它与继承相比有什么优缺点吗？" class="headerlink" title="1.41 知道C++中的组合吗？它与继承相比有什么优缺点吗？"></a>1.41 知道C++中的组合吗？它与继承相比有什么优缺点吗？</h3><p>在面向对象编程中，组合（Composition）是一种将多个类组合在一起创建新的类的方式。在组合关系中，一个类包含另一个类的实例作为其成员变量，这种关系表达了“具有”的关系，而不是“是一个”的关系。</p><p>与继承相比，组合的优缺点如下：</p><ul><li><p>优点：</p><ul><li>灵活性： 组合关系更灵活，因为它不会限制子类必须继承特定的行为或属性，而是通过组合已有的类来实现新的功能。</li><li>松耦合： 组合关系降低了类之间的耦合度，因为类之间的关系更加简单明确，不会引入不必要的依赖。</li><li>封装性： 组合可以带来更好的封装性，因为组合的类可以选择性地暴露其内部成员，对外部隐藏实现细节。</li><li>易于维护： 组合关系使得代码结构更清晰，易于理解和维护。</li></ul></li><li><p>缺点：</p><ul><li>代码重复： 在组合关系中，如果多个类都需要相同的功能或属性，可能会导致代码重复，增加了代码量和维护成本。</li><li>初始化复杂： 当一个类包含多个其他类的实例作为成员变量时，初始化对象可能变得更加复杂。</li><li>性能开销： 在运行时，由于需要额外的内存分配和对象构造，组合关系可能会引入一定的性能开销。</li></ul></li></ul><p>总的来说，组合关系提供了一种更加灵活和松耦合的方式来构建对象，可以避免继承带来的一些问题，但也需要注意代码重复和初始化复杂性等缺点。选择组合还是继承取决于具体的设计需求和问题领域，需要综合考虑各方面的因素来做出合适的选择。</p><h3 id="1-42-函数指针？"><a href="#1-42-函数指针？" class="headerlink" title="1.42 函数指针？"></a>1.42 函数指针？</h3><p>函数指针是指向函数的指针变量，它存储了函数的地址，可以用来间接地调用函数。在 C 和 C++ 中，函数指针的语法如下：</p><pre><code class="cpp">return_type (*pointer_name)(parameter_types);</code></pre><p>函数指针在 C 和 C++ 中具有多种用途，包括但不限于以下几个方面：</p><ul><li><p>回调函数： 函数指针可以作为参数传递给其他函数，从而实现回调函数的机制。通过回调函数，可以在运行时指定需要调用的函数，从而实现灵活的控制流程。这在事件处理、信号处理等场景中非常常见。</p></li><li><p>动态选择函数： 函数指针可以根据不同的条件动态地选择调用不同的函数，从而实现更灵活的程序逻辑。这种技术常用于状态机、策略模式等场景。</p></li><li><p>实现多态性： 在 C++ 中，函数指针可以用于实现简单的多态性，虽然它不如虚函数表那样灵活，但可以实现类似的功能。通过函数指针，可以在运行时选择不同的函数实现，从而实现对象的多态行为。</p></li><li><p>动态加载库函数： 在动态链接库（DLL）和共享对象（SO）中，函数指针可以用于动态加载库函数，从而实现在运行时加载和调用特定库函数的功能。这在插件系统、动态扩展功能等场景中非常有用。</p></li></ul><h3 id="1-43-为什么要进行内存对齐"><a href="#1-43-为什么要进行内存对齐" class="headerlink" title="1.43 为什么要进行内存对齐"></a>1.43 为什么要进行内存对齐</h3><p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.</p><p>现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。</p><p>假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的连续四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.</p><h3 id="1-44-内存对齐规则"><a href="#1-44-内存对齐规则" class="headerlink" title="1.44 内存对齐规则"></a>1.44 内存对齐规则</h3><ul><li>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认<code>#pragma pack(4)</code>，可以通过预编译命令#pragma pack(n)，n &#x3D; 1,2,4,8,16来改变这一系数。</li></ul><p>有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。</p><p>了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：</p><ul><li><p><strong>基本类型的对齐规则：</strong> 基本数据类型在内存中的存储位置通常要求是其自身大小的整数倍。例如，一个字节大小的字符通常需要对齐到地址为1的位置，一个四字节大小的整数通常需要对齐到地址为4的位置。</p></li><li><p><strong>结构体和类的对齐规则：</strong> 结构体和类的对齐规则是其成员中大小最大的成员大小的整数倍。这样做的目的是为了保证结构体或类的成员都能够按照其自身的对齐要求存储，从而保证结构体或类的实例的起始地址是合法的。</p></li><li><p><strong>指针类型的对齐规则：</strong> 指针类型的大小通常与机器的地址长度相等，因此指针类型的对齐规则通常与基本类型的对齐规则相同。</p></li></ul><h3 id="1-45-static变量"><a href="#1-45-static变量" class="headerlink" title="1.45 static变量"></a>1.45 static变量</h3><p>静态变量是在程序执行期间存在且只初始化一次的变量，它的生存周期与程序的运行周期相同。在C和C++中，静态变量可以分为两种类型：</p><ul><li><p>局部静态变量（Static Local Variable）： 在函数内部声明的静态变量称为局部静态变量。这些变量在函数被调用时被创建，在程序的整个生命周期内保持存在，并且只被初始化一次。局部静态变量的作用域仅限于声明它们的函数内部。</p><pre><code class="cpp">void func() &#123;    static int count = 0; // 局部静态变量    count++;    printf(&quot;Count: %d\n&quot;, count);&#125;</code></pre></li><li><p>全局静态变量（Static Global Variable）： 在函数外部声明的静态变量称为全局静态变量。这些变量在程序启动时被创建，在程序的整个生命周期内保持存在，并且只被初始化一次。全局静态变量的作用域为<code>整个文件</code>，对其他文件不可见（除非使用<code>extern</code>关键字进行声明）。</p><pre><code class="cpp">static int globalVar = 5; // 全局静态变量</code></pre></li><li><p>静态变量的特点包括：</p><ul><li>在内存中分配固定的存储空间，存储在静态存储区域。</li><li>生命周期与程序运行周期相同，程序结束时才被销毁。</li><li>未初始化时，默认值为0。</li><li>局部静态变量在函数内部可见，全局静态变量在整个文件内可见。</li><li>静态变量的值在函数调用之间保持不变。</li><li>静态变量在程序中的应用包括：存储全局状态、实现单例模式、记录函数调用次数等。由于静态变量的生存周期和作用域特性，它们通常用于需要持久存储数据的情况。</li></ul></li></ul><h3 id="1-46-extern和static"><a href="#1-46-extern和static" class="headerlink" title="1.46 extern和static"></a>1.46 extern和static</h3><p><code>extern</code>和<code>static</code>都是用来限定变量或函数的作用域和链接属性的关键字，但它们的作用方式有所不同。</p><ul><li><p>extern：</p><ul><li><p>extern 用于声明变量或函数，表示该变量或函数是在其他源文件中定义的，当前源文件中只是进行了声明，实际定义在其他地方。</p></li><li><p>当使用 extern 声明变量时，编译器不会为该变量分配存储空间，只是告诉编译器该变量是在其他地方定义的。</p></li><li><p>extern 声明通常用于在多个源文件中共享全局变量或函数的声明。</p></li></ul><p>例如：</p><pre><code class="cpp">// File1.cppint globalVar = 5; // 定义全局变量// File2.cppextern int globalVar; // 声明全局变量</code></pre></li><li><p>static：</p><ul><li><p>static 用于声明静态变量或函数，限定其作用域为当前文件，在其他文件中无法访问。</p></li><li><p>当使用 static 声明变量或函数时，它们的作用域仅限于当前源文件，对其他源文件不可见。</p></li><li><p>对于全局变量，static 关键字也可以用于限定其链接属性，使其只能在当前文件中访问，称为文件作用域全局变量。</p></li></ul><p>例如：</p><pre><code class="cpp">// File1.cppstatic int localVar = 10; // 声明文件作用域的静态变量// File2.cpp// 在 File2.cpp 中无法访问 localVar</code></pre></li></ul><p>总结：</p><ul><li><p>extern 用于声明外部变量或函数，使得在当前文件中可以引用其他文件中定义的全局变量或函数。</p></li><li><p>static 用于限定变量或函数的作用域为当前文件，使得它们只能在当前文件中可见，对其他文件不可见。</p></li></ul><h3 id="1-47-如何在不使用额外空间的情况下，交换两个数？你有几种方法"><a href="#1-47-如何在不使用额外空间的情况下，交换两个数？你有几种方法" class="headerlink" title="1.47 如何在不使用额外空间的情况下，交换两个数？你有几种方法"></a>1.47 如何在不使用额外空间的情况下，交换两个数？你有几种方法</h3><ol><li>使用加法和减法：<pre><code class="cpp">a = a + b;b = a - b;a = a - b;</code></pre></li><li>使用异或操作：<pre><code class="cpp">a = a ^ b;b = a ^ b;a = a ^ b;</code></pre></li><li>使用加法和位移：<pre><code class="cpp">a = a + b;b = a - b;a = (a - b) &gt;&gt; 1;</code></pre></li><li>使用乘法和除法：<pre><code class="cpp">a = a * b;b = a / b;a = a / b;</code></pre></li></ol><p>这些方法都是在不使用额外空间的情况下，通过数学运算来交换两个数的值。其中，使用异或操作是最常见的方法，因为它既简单又高效。</p><h3 id="1-48-strcpy-和-memcpy-的区别"><a href="#1-48-strcpy-和-memcpy-的区别" class="headerlink" title="1.48 strcpy 和 memcpy 的区别"></a>1.48 strcpy 和 memcpy 的区别</h3><ol><li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 </li><li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 </li><li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li></ol><h3 id="1-49-程序在执行int-main-int-argc-char-argv-时的内存结构"><a href="#1-49-程序在执行int-main-int-argc-char-argv-时的内存结构" class="headerlink" title="1.49 程序在执行int main(int argc, char *argv[])时的内存结构"></a>1.49 程序在执行int main(int argc, char *argv[])时的内存结构</h3><p>参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针</p><p><code>char *</code>指向的内存中，数组的中元素的个数为<code>argc</code>个，第一个参数为<code>程序的名称</code>。</p><h3 id="1-50-volatile关键字的作用？"><a href="#1-50-volatile关键字的作用？" class="headerlink" title="1.50 volatile关键字的作用？"></a>1.50 volatile关键字的作用？</h3><p><code>volatile</code>关键字用于告诉编译器，被 volatile 修饰的变量可能会在程序执行过程中被意外修改，因此编译器不应该对这些变量进行优化。</p><p>具体来说，volatile 关键字的作用包括：</p><ul><li><p><code>防止编译器优化</code>： 声明变量为 volatile 后，编译器会将对该变量的访问、赋值等操作视为有可能受到外部因素影响，因此不会对这些操作进行优化，确保编译后的代码与源代码中的操作顺序一致。</p></li><li><p><code>指示变量可能被多线程或中断处理程序修改</code>： 在多线程或中断处理程序的环境中，某些变量的值可能会被其他线程或中断处理程序修改，而这些修改对于程序的正确执行具有重要影响。通过使用 volatile 关键字，可以告诉编译器这些变量的值可能会在程序执行过程中被修改，因此需要每次访问都重新从内存中读取值，而不是使用缓存中的值。</p></li></ul><p><code>volatile</code>关键字通常在以下情况下使用：</p><ol><li><p><code>硬件操作或内存映射</code>： 当变量代表硬件寄存器或内存映射的状态时，可能会被外部设备或中断处理程序修改。在这种情况下，将变量声明为 volatile 可以确保编译器不会对其进行优化，以防止意外的行为。</p></li><li><p><code>多线程环境下共享变量</code>： 在多线程程序中，共享变量可能会被多个线程同时访问和修改。如果这些变量没有使用同步机制进行保护，那么在读取和写入这些变量时可能会发生竞态条件。在这种情况下，将共享变量声明为 volatile 可以告诉编译器不要对其进行优化，以确保每次访问都是从内存中读取最新值。</p></li><li><p><code>信号处理程序中使用的全局变量</code>： 在信号处理程序中，全局变量的值可能会在程序的正常执行流程之外被修改。为了确保信号处理程序能够正确地读取和修改这些变量，通常会将它们声明为 volatile。</p></li></ol><h3 id="1-51-如果有一个空类，它会默认添加哪些函数？"><a href="#1-51-如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="1.51 如果有一个空类，它会默认添加哪些函数？"></a>1.51 如果有一个空类，它会默认添加哪些函数？</h3><pre><code class="C++">MyClass(); // 缺省构造函数MyClass( const MyClass&amp; ); // 拷贝构造函数~MyClass(); // 析构函数MyClass&amp; operator=( const MyClass&amp; ); // 赋值运算符</code></pre><h3 id="1-52-说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#1-52-说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="1.52 说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>1.52 说一说strcpy、sprintf与memcpy这三个函数的不同之处</h3><ol><li><strong>操作对象不同</strong></li></ol><ul><li><p>strcpy的两个操作对象均为字符串</p></li><li><p>sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串</p></li><li><p>memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</p></li></ul><ol start="2"><li><p><strong>执行效率不同</strong><br>memcpy最高，strcpy次之，sprintf的效率最低。</p></li><li><p><strong>实现功能不同</strong></p></li></ol><ul><li><p>strcpy主要实现字符串变量间的拷贝</p></li><li><p>sprintf主要实现其他数据类型格式到字符串的转化</p></li><li><p>memcpy主要是内存块间的拷贝</p></li></ul><h3 id="1-53-如何阻止一个类被实例化？有哪些方法"><a href="#1-53-如何阻止一个类被实例化？有哪些方法" class="headerlink" title="1.53 如何阻止一个类被实例化？有哪些方法"></a>1.53 如何阻止一个类被实例化？有哪些方法</h3><ol><li><code>将构造函数声明为私有（private）</code>： 将类的构造函数声明为私有，这样外部代码就无法直接调用该构造函数实例化对象。但是需要注意的是，类的静态成员函数仍然可以访问私有构造函数，因此可以在类的静态成员函数中实现对象的创建，从而控制对象的实例化。</li><li><code>删除构造函数的定义</code>： C++11 引入了删除函数的特性，可以通过将构造函数的定义删除来阻止对象的实例化。删除构造函数的定义后，任何尝试调用该构造函数的操作都会导致编译错误。</li><li><code>将构造函数声明为纯虚函数</code>： 将构造函数声明为纯虚函数，这样派生类必须实现自己的构造函数，而基类则无法被实例化。</li></ol><h3 id="1-54-strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#1-54-strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="1.54 strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>1.54 strcpy函数和strncpy函数的区别？哪个函数更安全？</h3><ul><li><code>strcpy</code>：<ul><li>函数原型：char *strcpy(char *dest, const char *src);  </li><li>功能：将源字符串（以空字符结尾）拷贝到目标字符串中，包括空字符。</li><li>安全性：strcpy 不检查目标字符串的长度，如果源字符串比目标字符串长，可能会发生缓冲区溢出，导致未定义的行为。</li></ul></li><li><code>strncpy</code>：<ul><li>函数原型：char *strncpy(char *dest, const char *src, size_t n);</li><li>功能：将源字符串的前 n 个字符拷贝到目标字符串中，如果源字符串长度小于 n，则在目标字符串中用空字符填充剩余部分。</li><li>安全性：相比于 strcpy，strncpy 更安全，因为它可以指定拷贝的最大长度，避免了缓冲区溢出的风险。但需要注意，如果源字符串的长度大于 n，则目标字符串不会以空字符结尾，因此可能需要<code>手动添加空字符</code>。</li></ul></li></ul><p>因此，从安全性的角度来看，strncpy 更安全一些，但需要确保目标字符串足够大以容纳指定长度的内容。另外，使用 strncpy 时应格外小心，确保目标字符串始终以空字符结尾，以避免字符串操作中出现意外行为。</p><h3 id="1-55-写一个比较大小的模板函数"><a href="#1-55-写一个比较大小的模板函数" class="headerlink" title="1.55 写一个比较大小的模板函数"></a>1.55 写一个比较大小的模板函数</h3><pre><code class="C++">template &lt;typename T&gt;T max(T a, T b)&#123;  return a &gt; b ? a : b;&#125;</code></pre><h3 id="1-56-成员函数里memset-this-0-sizeof-this-会发生什么"><a href="#1-56-成员函数里memset-this-0-sizeof-this-会发生什么" class="headerlink" title="1.56 成员函数里memset(this,0,sizeof(*this))会发生什么"></a>1.56 成员函数里memset(this,0,sizeof(*this))会发生什么</h3><p>在成员函数中调用<code>memset(this, 0, sizeof(*this))</code>将会把当前对象所占内存的前<code>sizeof(*this)</code>字节全部设置为零。这样做会将对象的所有成员变量都设置为零值，但这种做法可能会导致一些问题，特别是对于<code>含有虚函数或虚继承的类</code>。</p><p>具体来说，<code>memset</code>函数是用来将一段内存块设置为指定的值的，但它只是简单地按字节设置，对于非 POD（Plain Old Data）类型的对象，这种简单的内存设置可能会导致对象中的某些数据结构被破坏，从而导致程序出错。</p><p>对于含有虚函数的类，调用<code>memset</code>可能会破坏虚<code>函数表（vtable）指针</code>，导致虚函数调用出错。对于含有虚继承的类，调用<code>memset</code>会破坏<code>虚基类指针（vptr）</code>，同样会导致程序出错。</p><p>因此，一般情况下不建议在成员函数中直接使用 memset 来清零对象的内存，而是应该使用更安全的方式来初始化对象的成员变量。</p><h3 id="1-57-C-从代码到可执行程序经历了什么"><a href="#1-57-C-从代码到可执行程序经历了什么" class="headerlink" title="1.57 C++从代码到可执行程序经历了什么"></a>1.57 C++从代码到可执行程序经历了什么</h3><ol><li><p><strong>编写代码</strong>：首先，程序员编写C++源代码，这些代码通常包含在一个或多个源文件中。</p></li><li><p><strong>预处理</strong>：在编译之前，源代码经过预处理器处理。预处理器执行诸如<code>宏替换</code>、<code>条件编译</code>等操作，生成经过预处理的源代码文件。</p></li><li><p><strong>编译</strong>：编译器将预处理后的源代码转换为汇编代码。这个阶段的任务是将高级语言代码转换为机器语言代码，生成相应的目标文件。</p></li><li><p><strong>汇编</strong>：汇编器将汇编代码转换为机器可执行的二进制代码。它将每条汇编指令翻译成机器指令，并生成目标文件。</p></li><li><p><strong>链接</strong>：链接器将生成的目标文件与所需的库文件链接在一起，创建一个完整的可执行程序。它解析程序中使用的符号引用，将它们与符号定义关联起来，并解决外部符号的引用。最终，链接器产生一个可执行文件，其中包含程序的所有指令和数据。</p></li><li><p><strong>优化</strong>：在编译和链接过程中，还可以应用各种优化技术来提高程序的性能和效率。这些优化包括但不限于代码优化、内联函数、循环优化等。</p></li><li><p><strong>生成可执行文件</strong>：经过链接和优化后，最终生成可执行文件，即可以在特定平台上运行的二进制文件。这个可执行文件包含了程序的所有代码和数据，可以直接在计算机上执行。</p></li><li><p><strong>运行程序</strong>：最终，用户可以运行生成的可执行程序，执行程序中定义的操作和功能。</p></li></ol><p>这些步骤通常由编译器和链接器自动完成，用户只需要编写和调试源代码即可。</p><h3 id="1-58-友元函数和友元类"><a href="#1-58-友元函数和友元类" class="headerlink" title="1.58 友元函数和友元类"></a>1.58 友元函数和友元类</h3><p>在C++中，友元函数和友元类是用来提供对类的私有成员的访问权限的机制，它们可以访问类的私有成员，即使这些成员在类的定义中被声明为私有的也可以。它们的区别在于：</p><ul><li>友元函数：友元函数是在类的外部声明的普通函数，可以访问类的所有成员。要声明一个函数为类的友元函数，需要在类的定义中使用 friend 关键字来声明。友元函数并不属于类的成员函数，它们可以通过对象或类名来调用。<pre><code class="cpp">class MyClass &#123;    friend void friendFunction();private:    int privateMember;&#125;;void friendFunction() &#123;    MyClass obj;    obj.privateMember = 10; // 可以访问私有成员&#125;</code></pre></li><li>友元类：友元类是指一个类可以访问另一个类的私有成员。同样地，在类的定义中使用 friend 关键字来声明一个类为友元类。友元类可以访问被声明为友元类的类的所有成员，包括私有成员和保护成员。<pre><code class="cpp">class MyClass &#123;    friend class FriendClass;private:    int privateMember;&#125;;class FriendClass &#123;public:    void accessPrivateMember(MyClass&amp; obj) &#123;        obj.privateMember = 10; // 可以访问私有成员    &#125;&#125;;</code></pre></li></ul><p>友元函数和友元类的使用可以提供更灵活的访问控制，但同时也会破坏了类的封装性，因此应该谨慎使用。</p><h3 id="1-59-自旋锁"><a href="#1-59-自旋锁" class="headerlink" title="1.59 自旋锁"></a>1.59 自旋锁</h3><p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p><h3 id="1-60-为什么C-没有垃圾回收机制？这点跟Java不太一样。"><a href="#1-60-为什么C-没有垃圾回收机制？这点跟Java不太一样。" class="headerlink" title="1.60 为什么C++没有垃圾回收机制？这点跟Java不太一样。"></a>1.60 为什么C++没有垃圾回收机制？这点跟Java不太一样。</h3><ul><li>实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。</li><li>垃圾回收会使得C++不适合进行很多底层的操作。</li></ul><h2 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h2><h3 id="2-1-简要说明C-的内存分区"><a href="#2-1-简要说明C-的内存分区" class="headerlink" title="2.1 简要说明C++的内存分区"></a>2.1 简要说明C++的内存分区</h3><p>C++中的内存分区，分别是堆、栈、自由存储区、全局&#x2F;静态存储区、常量存储区和代码区。  </p><ul><li><p><strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p></li><li><p><strong>堆</strong>：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete。<code>如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</code></p></li><li><p><strong>自由存储区</strong>：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，<code>自由存储区和堆比较像，但不等价</code></p></li><li><p><strong>全局&#x2F;静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，<code>在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</code></p></li><li><p><strong>常量存储区</strong>：这是一块比较特殊的存储区，这里面存放的是常量，<code>不允许修改</code></p></li><li><p><strong>代码区</strong>：存放函数体的二进制代码</p></li></ul><h3 id="2-2-什么是内存池，如何实现"><a href="#2-2-什么是内存池，如何实现" class="headerlink" title="2.2 什么是内存池，如何实现"></a>2.2 什么是内存池，如何实现</h3><p>内存池（Memory Pool） 是一种内存分配方式。通常我们习惯直接使用new、malloc 等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。</p><pre><code class="cpp">// 内存池#include &quot;list&quot;class MemoryPool&#123;private:    std::list&lt;char*&gt; m_blocks;    unsigned int m_bloackNum;public:    MemoryPool(size_t size, unsigned int num)&#123;        m_bloackNum = num;        for(unsigned int i = 0; i &lt; num; ++i)&#123;            m_blocks.push_back(new char[size]);        &#125;    &#125;    ~MemoryPool()&#123;        for(auto b : m_blocks)&#123;            delete[] b;            b = nullptr;        &#125;    &#125;    char* allocate()&#123;        if(m_blocks.empty())&#123;            throw std::bad_alloc();        &#125;        char* b = m_blocks.front();        m_blocks.pop_front();        return b;    &#125;    void deallocate(void* block)&#123;        m_blocks.push_back(static_cast&lt;char*&gt;(block));    &#125;&#125;;</code></pre><h3 id="2-3-几个this指针的易混问题"><a href="#2-3-几个this指针的易混问题" class="headerlink" title="2.3 几个this指针的易混问题"></a>2.3 几个this指针的易混问题</h3><ul><li><p><strong>this指针是什么时候创建的？</strong><br>this在成员函数的开始执行前构造，在成员的执行结束后清除。</p></li><li><p><strong>this指针存放在何处？堆、栈、全局变量，还是其他？</strong><br>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。</p></li><li><p><strong>每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</strong><br>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。</p></li></ul><h3 id="2-4-内存泄漏的后果？如何监测？解决方法？"><a href="#2-4-内存泄漏的后果？如何监测？解决方法？" class="headerlink" title="2.4 内存泄漏的后果？如何监测？解决方法？"></a>2.4 内存泄漏的后果？如何监测？解决方法？</h3><ul><li>后果<br>只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种症状：性能下降到内存逐渐用完，导致另一个程序失败；  </li><li>如何监测<br>使用专门的内存泄漏检测工具，例如Valgrind、AddressSanitizer(ASan)、LeakSanitizer等，这些工具能够帮助检测程序中的内存泄漏问题，并给出详细的报告和堆栈信息。<ul><li>使用 -g 编译选项开启符号信息生成，然后使用Valgrind执行测试<br><img src="/2024/03/23/C-%E5%85%AB%E8%82%A1%E6%96%87/debug001.png"></li><li>编译时使用<code>-fsanitize=address</code>选项来开启<code>AddressSanitizer</code><pre><code class="bash">g++ -fsanitize=address -g your_code.cpp -o your_executable</code></pre>或使用<code>-fsanitize=leak</code>选项来开启<code>LeakSanitizer</code><br><img src="/2024/03/23/C-%E5%85%AB%E8%82%A1%E6%96%87/debug002.png"><br><img src="/2024/03/23/C-%E5%85%AB%E8%82%A1%E6%96%87/debug003.png"></li></ul></li><li>解决方法<br>智能指针。代码审查。</li></ul><h4 id="2-4-1-使用-g-选项编译程序有什么作用"><a href="#2-4-1-使用-g-选项编译程序有什么作用" class="headerlink" title="2.4.1.使用 -g 选项编译程序有什么作用"></a>2.4.1.使用 -g 选项编译程序有什么作用</h4><p>使用 -g 选项编译程序的作用是生成调试信息（debug information），这些调试信息包含了源代码和目标代码之间的映射关系，以及变量名、函数名等符号信息。具体来说，-g 选项会将调试信息嵌入到可执行文件中，以便在程序执行时能够进行调试和分析。</p><p>主要作用包括：</p><ol><li><p>源代码和目标代码映射关系：调试信息可以帮助调试器将源代码的行号和目标代码的地址进行映射，从而在调试过程中能够准确地定位到源代码的位置。这样可以更方便地进行断点设置、单步调试等操作。</p></li><li><p>变量名、函数名等符号信息：调试信息中包含了变量名、函数名等符号信息，使得调试器能够识别和显示这些符号，从而更容易地理解程序的结构和逻辑。</p></li><li><p>错误信息定位：当程序发生错误时，调试信息可以帮助调试器准确地定位到错误的源代码位置，从而更容易地进行错误排查和修复。</p></li><li><p>内存检测工具支持：一些内存检测工具（如 Valgrind 的 Memcheck）需要在调试信息的基础上进行分析和检测，因此编译时需要使用 -g 选项生成调试信息。</p></li></ol><h3 id="2-5-在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#2-5-在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="2.5 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>2.5 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h3><p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</p><blockquote><p><strong>为什么是不可预期的问题？</strong><br>delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p></blockquote><h3 id="2-6-如果在类的析构函数中调用delete-this，会发生什么？"><a href="#2-6-如果在类的析构函数中调用delete-this，会发生什么？" class="headerlink" title="2.6 如果在类的析构函数中调用delete this，会发生什么？"></a>2.6 如果在类的析构函数中调用delete this，会发生什么？</h3><p>可能会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p><h3 id="2-7-请说一下以下几种情况下，下面几个类的大小各是多少？"><a href="#2-7-请说一下以下几种情况下，下面几个类的大小各是多少？" class="headerlink" title="2.7 请说一下以下几种情况下，下面几个类的大小各是多少？"></a>2.7 请说一下以下几种情况下，下面几个类的大小各是多少？</h3><pre><code class="cpp">class A &#123;&#125;;int main()&#123;  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1;  A a;   cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1;  return 0;&#125;/*空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。*/</code></pre><pre><code class="cpp">class A &#123; virtual void Fun()&#123;&#125; &#125;;int main()&#123;  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器);  A a;   cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器);  return 0;&#125;// 因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节</code></pre><pre><code class="cpp">class A &#123; static int a; &#125;;int main()&#123;  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1;  A a;   cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1;  return 0;&#125;// 静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</code></pre><pre><code class="cpp">class A &#123; int a; &#125;;int main()&#123;  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4;  A a;   cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4;  return 0;&#125;</code></pre><h3 id="2-8-类对象的大小受哪些因素影响？"><a href="#2-8-类对象的大小受哪些因素影响？" class="headerlink" title="2.8 类对象的大小受哪些因素影响？"></a>2.8 类对象的大小受哪些因素影响？</h3><ul><li><p>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</p></li><li><p>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</p></li><li><p>虚函数的话，会在类对象插入vptr指针，加上指针大小；</p></li><li><p>当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。</p></li></ul><h2 id="三、C-11新标准"><a href="#三、C-11新标准" class="headerlink" title="三、C++11新标准"></a>三、C++11新标准</h2><h3 id="3-1-C-11有哪些新特性？"><a href="#3-1-C-11有哪些新特性？" class="headerlink" title="3.1 C++ 11有哪些新特性？"></a>3.1 C++ 11有哪些新特性？</h3><ul><li>nullptr替代 NULL</li><li>引入了 auto 和 decltype 这两个关键字实现了类型推导</li><li>基于范围的 for 循环for(auto&amp; i : res){}</li><li>类和结构体的中初始化列表</li><li>Lambda 表达式（匿名函数）</li><li>std::forward_list（单向链表）</li><li>右值引用和move语义</li><li>…</li></ul><h3 id="3-2-智能指针的原理、常用的智能指针及实现"><a href="#3-2-智能指针的原理、常用的智能指针及实现" class="headerlink" title="3.2 智能指针的原理、常用的智能指针及实现"></a>3.2 智能指针的原理、常用的智能指针及实现</h3><ul><li><p><strong>原理</strong><br>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源</p></li><li><p><strong>常用的智能指针</strong>  </p><ul><li><p><strong>unique_ptr</strong><br>它是一种独占所有权的智能指针，即它不能被复制或拷贝。当unique_ptr被销毁时，它所指向的对象会被自动释放。这使得unique_ptr非常适合管理动态分配的单个对象。</p></li><li><p><strong>shared_ptr</strong><br>它是一种共享所有权的智能指针，可以被多个shared_ptr共享同一个对象。它使用引用计数来跟踪指向对象的指针数量，并在没有指针指向对象时自动释放对象。当最后一个shared_ptr销毁时，对象会被释放。</p></li><li><p><strong>weak_ptr</strong><br>它是一种弱引用的智能指针，用于解决shared_ptr的循环引用问题。weak_ptr可以从shared_ptr创建，但不会增加引用计数。因此，它不会阻止对象的销毁。通常在需要访问shared_ptr所管理的对象，但又不需要拥有所有权时使用。</p></li><li><p><strong>auto_ptr（C++11之前）</strong><br>它是早期版本的C++标准中提供的智能指针，类似于unique_ptr，但具有一些缺陷，并在C++11中被std::unique_ptr取代。auto_ptr没有明确定义的行为来处理拷贝和赋值操作，因此容易导致问题。</p></li></ul></li><li><p><strong>智能指针shared_ptr代码实现</strong></p></li></ul><pre><code class="cpp">template&lt;typename T&gt;class SharedPtr&#123;public:    SharedPtr(T* ptr = NULL):_ptr(ptr), _pcount(new int(1))    &#123;&#125;    SharedPtr(const SharedPtr&amp; s):_ptr(s._ptr), _pcount(s._pcount)&#123;        (*_pcount)++;    &#125;    SharedPtr&lt;T&gt;&amp; operator=(const SharedPtr&amp; s)&#123;        if (this != &amp;s)        &#123;            if (--(*(this-&gt;_pcount)) == 0)            &#123;                delete this-&gt;_ptr;                delete this-&gt;_pcount;            &#125;            _ptr = s._ptr;            _pcount = s._pcount;            (*_pcount)++;        &#125;        return *this;    &#125;    T&amp; operator*()    &#123;        return *(this-&gt;_ptr);    &#125;    T* operator-&gt;()    &#123;        return this-&gt;_ptr;    &#125;    ~SharedPtr()    &#123;        --(*(this-&gt;_pcount));        if (*(this-&gt;_pcount) == 0)        &#123;            delete _ptr;            _ptr = NULL;            delete _pcount;            _pcount = NULL;        &#125;    &#125;private:    T* _ptr;    int* _pcount;//指向引用计数的指针&#125;;</code></pre><h3 id="3-3-lambda函数"><a href="#3-3-lambda函数" class="headerlink" title="3.3 lambda函数"></a>3.3 lambda函数</h3><pre><code class="cpp">[capture-list] (parameter-list) -&gt; return-type &#123;    // 函数体&#125;</code></pre><ul><li>capture-list：捕获列表，用于捕获外部变量。可以是值传递方式（[var]）或引用传递方式（[&amp;var]）。还可以使用[&#x3D;]表示以值传递方式捕获所有外部变量，或使用[&amp;]表示以引用传递方式捕获所有外部变量。</li><li>parameter-list：参数列表，与普通函数的参数列表类似。</li><li>return-type：返回类型，可以省略，编译器会根据返回语句自动推断返回类型。</li><li>{}：函数体，与普通函数的函数体类似。</li></ul><pre><code class="cpp">#include &lt;iostream&gt;int main() &#123;    // Lambda表达式求两个数的和    auto sum = [](int a, int b) -&gt; int &#123;        return a + b;    &#125;;    // 调用lambda表达式    int result = sum(3, 4);    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; result &lt;&lt; std::endl;    return 0;&#125;</code></pre><h3 id="3-4-shared-ptr的循环引用问题"><a href="#3-4-shared-ptr的循环引用问题" class="headerlink" title="3.4 shared_ptr的循环引用问题"></a>3.4 shared_ptr的循环引用问题</h3><p>当两个对象相互引用并使用<code>shared_ptr</code>时，就会形成循环引用。例如，考虑一个简单的场景：</p><pre><code class="cpp">#include &lt;memory&gt;#include &lt;iostream&gt;class B; // 前置声明class A &#123;public:    std::shared_ptr&lt;B&gt; b_ptr;    A() &#123; std::cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; std::endl; &#125;    ~A() &#123; std::cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; std::endl; &#125;&#125;;class B &#123;public:    std::shared_ptr&lt;A&gt; a_ptr;    B() &#123; std::cout &lt;&lt; &quot;B constructor&quot; &lt;&lt; std::endl; &#125;    ~B() &#123; std::cout &lt;&lt; &quot;B destructor&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123;    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;();    std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;();        a-&gt;b_ptr = b;    b-&gt;a_ptr = a;    return 0;&#125;</code></pre><p>在这个例子中，类 <code>A</code> 拥有一个指向类 <code>B</code> 的 <code>shared_ptr</code>，而类 <code>B</code> 拥有一个指向类 <code>A</code> 的 <code>shared_ptr</code>。这样就形成了循环引用。</p><p>为了避免循环引用，我们可以改用 <code>weak_ptr</code> 来解决这个问题：</p><pre><code class="cpp">#include &lt;memory&gt;#include &lt;iostream&gt;class B; // 前置声明class A &#123;public:    std::shared_ptr&lt;B&gt; b_ptr;    A() &#123; std::cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; std::endl; &#125;    ~A() &#123; std::cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; std::endl; &#125;&#125;;class B &#123;public:    std::weak_ptr&lt;A&gt; a_weak_ptr;  // 使用 weak_ptr    B() &#123; std::cout &lt;&lt; &quot;B constructor&quot; &lt;&lt; std::endl; &#125;    ~B() &#123; std::cout &lt;&lt; &quot;B destructor&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123;    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;();    std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;();        a-&gt;b_ptr = b;    b-&gt;a_weak_ptr = a;  // 使用 weak_ptr    return 0;&#125;</code></pre><p>通过将类 <code>B</code> 中指向类 <code>A</code> 的指针改为 <code>weak_ptr</code>，我们成功地避免了循环引用问题。</p><h2 id="四、STL"><a href="#四、STL" class="headerlink" title="四、STL"></a>四、STL</h2><h3 id="4-1-什么是STL"><a href="#4-1-什么是STL" class="headerlink" title="4.1 什么是STL"></a>4.1 什么是STL</h3><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p><ul><li>算法包括排序，复制等常用算法，以及不同容器特定的算法。</li><li>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</li><li>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。</li></ul><h3 id="4-2-使用智能指针管理内存资源，RAII是怎么回事？"><a href="#4-2-使用智能指针管理内存资源，RAII是怎么回事？" class="headerlink" title="4.2 使用智能指针管理内存资源，RAII是怎么回事？"></a>4.2 使用智能指针管理内存资源，RAII是怎么回事？</h3><p>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。<br>因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</p><p>智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。<br>毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</p><h3 id="4-3-迭代器：-it、it-哪个好，为什么"><a href="#4-3-迭代器：-it、it-哪个好，为什么" class="headerlink" title="4.3 迭代器：++it、it++哪个好，为什么"></a>4.3 迭代器：++it、it++哪个好，为什么</h3><p>前置返回一个引用，后置返回一个对象</p><ul><li>++i实现代码为：</li></ul><pre><code class="cpp">int&amp; operator++()&#123;  *this += 1;  return *this;&#125; </code></pre><p>前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低</p><ul><li>i++实现代码为：</li></ul><pre><code class="cpp">int operator++(int)                 &#123;  int temp = *this;                     ++*this;                         return temp;                  &#125; </code></pre><p>对于大多数现代编译器来说，在合适的情况下，它们可能会对代码进行优化，包括将后置自增 it++ 转换为前置自增 ++it。但是，这种优化是否发生取决于编译器的实现以及优化级别。</p><h3 id="4-4-右值"><a href="#4-4-右值" class="headerlink" title="4.4 右值"></a>4.4 右值</h3><p>C++11引入了右值引用，用来支持移动语义和完美转发。</p><ol><li>移动语义：传统的复制操作需要额外的时间和空间，而有了移动语义后，可以直接将资源（如内存）从一个对象转移到另一个对象，而不必创建并删除临时对象。这对于大对象或者拥有独占所有权资源的对象特别有用。例如，unique_ptr和std::vector等STL容器就利用了移动语义实现了高效的操作。</li><li>完美转发：在函数模板中，我们想把参数原封不动地传递给其他函数。由于传参可能存在值传递、左值引用、常量左值引用、右值引用等情况，为了保证参数的属性和类型不发生变化，我们需要使用std::forward实现完美转发。</li></ol><p>右值引用主要用于两种场景：一是对象的移动（Move），二是万能引用（Forwarding Reference）。对于第一种情况，它是为了解决对象的复制效率问题；对于第二种情况，则是为了实现参数的完美传递，避免不必要的拷贝。</p><h3 id="4-5-简单说一下traits技法"><a href="#4-5-简单说一下traits技法" class="headerlink" title="4.5 简单说一下traits技法"></a>4.5 简单说一下traits技法</h3><p>Traits 技法是一种在编程中使用的模式，用于实现泛型编程和类型参数化。它的基本思想是将类型的某些特性（或特征）提取出来，并将其定义为独立的类或结构体，然后通过模板或泛型编程技术将这些特性与具体的类型进行关联。</p><p>Traits 技法的主要目的是将类型的行为和属性与类型本身解耦，使得代码更具灵活性和可重用性。通过定义一组通用的接口或函数，可以将这些接口或函数应用于不同的类型，而无需对每种类型都进行单独的实现。</p><p>在 C++ 中，Traits 技法通常通过模板编程来实现。可以定义一组模板类或结构体，用于描述类型的特性，然后在模板函数或模板类中使用这些特性。通过特化或偏特化，可以针对不同类型提供不同的实现，从而实现更高级的泛型编程。</p><p>例如，在 C++ 中，STL 中的迭代器就是一种典型的 Traits 技法的应用。迭代器通过一组接口描述了迭代器的特性，然后通过模板函数和模板类来处理不同类型的迭代器，而无需知道具体的迭代器类型。这种设计使得算法可以与任何支持相应接口的迭代器一起使用，从而提高了代码的灵活性和可重用性。</p><h3 id="4-6-STL的两级空间配置器"><a href="#4-6-STL的两级空间配置器" class="headerlink" title="4.6 STL的两级空间配置器"></a>4.6 STL的两级空间配置器</h3><p>STL（Standard Template Library）的空间配置器是用于在堆上分配内存的组件，它们被用来支持STL容器（如vector、list、map等）的内存管理。STL中的空间配置器通常包括单级空间配置器和双级空间配置器。</p><p>双级空间配置器由两部分组成：</p><ol><li><p>第一级空间配置器（第一级分配器）：使用malloc和free等全局内存分配函数来分配内存。这一级的分配器适用于大块内存的分配，它通过调用全局的malloc和free函数来分配和释放内存，通常是通过模板参数指定的分配策略来实现。</p></li><li><p>第二级空间配置器（第二级分配器）：由于第一级空间配置器在处理小块内存时效率较低，因此第二级空间配置器通常会对小块内存进行优化，它通常使用内存池等技术来管理和分配小块内存，以提高内存分配和释放的效率。</p></li></ol><p>双级空间配置器的设计可以在大块内存和小块内存之间取得平衡，从而在不同大小的内存分配场景中提供更好的性能和效率。这种设计使得STL容器在不同的内存分配场景下都能够有效地工作，并且具有较好的性能表现。</p><h3 id="4-7-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"><a href="#4-7-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素" class="headerlink" title="4.7 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"></a>4.7 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素</h3><ul><li><p><strong>vector数据结构</strong>  </p><ul><li>vector和<code>数组</code>类似，拥有一段连续的内存空间，并且起始地址不变。因此能高效的进行随机存取，时间复杂度为o(1);但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。</li><li>当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。连续存储结构：vector是可以实现动态增长的对象数组，支持对数组高效率的访问和在数组尾端的删除和插入操作，在中间和头部删除和插入相对不易，需要挪动大量的数据。</li><li>它与数组最大的区别就是vector不需程序员自己去考虑容量问题，库里面本身已经实现了容量的动态增长，而数组需要程序员手动写入扩容函数进形扩容。</li></ul></li><li><p><strong>list数据结构</strong>  </p><ul><li>list是由<code>双向链表</code>实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);但由于链表的特点，能高效地进行插入和删除。非连续存储结构：list是一个双链表结构，支持对链表的双向遍历。每个节点包括三个信息：元素本身，指向前一个元素的节点（prev）和指向下一个元素的节点（next）。因此list可以高效率的对数据元素任意位置进行访问和插入删除等操作。由于涉及对额外指针的维护，所以开销比较大。<br>区别：</li></ul></li></ul><p>vector的随机访问效率高，但在插入和删除时（不包括尾部）需要挪动数据，不易操作。<br>list的访问要遍历整个链表，它的随机访问效率低。但对数据的插入和删除操作等都比较方便，改变指针的指向即可。</p><p>从遍历上来说，list是单向的，vector是双向的。<br>vector中的迭代器在使用后就失效了，而list的迭代器在使用之后还可以继续使用。<br>int mySize &#x3D; vec.size();vec.at(mySize -2);</p><p>list不提供随机访问，所以不能用下标直接访问到某个位置的元素，要访问list里的元素只能遍历，不过你要是只需要访问list的最后N个元素的话，可以用<code>反向迭代器</code>来遍历</p><h3 id="4-8-reserve与resize"><a href="#4-8-reserve与resize" class="headerlink" title="4.8 reserve与resize"></a>4.8 reserve与resize</h3><p>在 C++ 中，reserve() 和 resize() 是与标准库中的容器（例如 vector、list、deque 等）相关的两个重要函数，它们的作用如下：</p><ul><li><p><strong>reserve():</strong><br>这个函数用于预留容器的存储空间，但不改变容器的大小。预留的存储空间可以用来避免容器在添加新元素时频繁地重新分配内存，从而提高性能。reserve() 函数的参数是要预留的元素个数。如果当前容器的容量小于指定的元素个数，reserve() 函数会分配额外的内存空间以容纳指定数量的元素。</p></li><li><p><strong>resize():</strong><br>这个函数用于更改容器中元素的数量。当调用 resize() 时，如果指定的大小比当前大小小，则容器中的元素数量会减少到指定大小；如果指定的大小比当前大小大，则容器会扩展以容纳额外的元素。如果容器扩展，新添加的元素将以容器元素的默认值进行初始化。</p></li></ul><blockquote><p>在调用 reserve() 函数之后，如果你直接访问预留的空间，将会导致未定义行为，因为这些空间并没有被初始化为有效的元素。</p></blockquote><h3 id="4-9-STL迭代器如何实现"><a href="#4-9-STL迭代器如何实现" class="headerlink" title="4.9 STL迭代器如何实现"></a>4.9 STL迭代器如何实现</h3><ol><li><p>迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。</p></li><li><p>迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与-&gt;运算符，以及++、–等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。</p></li><li><p>最常用的迭代器的相应型别有五种：value type、difference type、pointer、reference、iterator catagoly;</p></li></ol><h3 id="4-10-map插入方式有哪几种？"><a href="#4-10-map插入方式有哪几种？" class="headerlink" title="4.10 map插入方式有哪几种？"></a>4.10 map插入方式有哪几种？</h3><ol><li>用insert函数插入pair数据：</li></ol><pre><code class="cpp">mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;)); </code></pre><ol start="2"><li>用insert函数插入value_type数据：</li></ol><pre><code class="cpp">mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));</code></pre><ol start="3"><li>在insert函数中使用make_pair()函数：</li></ol><pre><code class="cpp">mapStudent.insert(make_pair(1, &quot;student_one&quot;)); </code></pre><ol start="4"><li>用数组方式插入数据：</li></ol><pre><code class="cpp">mapStudent[1] = &quot;student_one&quot;; </code></pre><h3 id="4-20-map中-与find的区别？"><a href="#4-20-map中-与find的区别？" class="headerlink" title="4.20 map中[]与find的区别？"></a>4.20 map中[]与find的区别？</h3><ul><li><p>map的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。</p></li><li><p>map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。</p></li></ul><h3 id="4-21-STL中list与deque之间的区别"><a href="#4-21-STL中list与deque之间的区别" class="headerlink" title="4.21 STL中list与deque之间的区别"></a>4.21 STL中list与deque之间的区别</h3><p>STL（标准模板库）中的list（双向链表）和deque（双端队列）是两种不同的容器，它们有以下区别：</p><ul><li><p>底层数据结构：</p><ul><li>list：<br>采用双向链表作为底层数据结构。每个节点包含数据以及指向前驱节点和后继节点的指针。</li><li>deque：<br>采用分段数组（双端队列）作为底层数据结构。它由多个较小的数组块组成，每个数组块都包含一定数量的元素，并通过指针连接起来，形成一个逻辑上的双端队列。</li></ul></li><li><p>访问元素的效率：</p><ul><li>list：<br>由于采用链表结构，list在任意位置插入或删除元素的效率都很高，为O(1)。但是，随机访问元素的效率较低，为O(n)，因为需要遍历链表找到指定位置的元素。</li><li>deque：<br>由于采用分段数组结构，deque支持高效的随机访问，其时间复杂度为O(1)。同时，deque还支持在两端进行快速插入和删除操作，时间复杂度也为O(1)。</li></ul></li><li><p>内存分配方式：</p><ul><li>list：<br>由于采用链表结构，每次插入或删除元素时都需要动态分配内存，因此在频繁插入或删除大量元素时，可能会产生较多的内存分配和释放操作，导致性能下降。</li><li>deque：<br>由于采用分段数组结构，内存是分块预先分配的，因此在插入或删除元素时不需要频繁进行内存分配和释放操作，性能相对较好。</li></ul></li><li><p>空间占用：</p><ul><li>list：<br>由于每个节点都需要额外的指针来指向前驱节点和后继节点，因此相比于deque，list的空间占用通常更大。</li><li>deque：<br>由于采用分段数组结构，每个数组块的大小是固定的，因此deque的空间占用更为灵活，不会产生额外的指针开销。</li></ul></li></ul><p>根据以上区别，选择使用list还是deque取决于你的具体需求。如果需要频繁进行插入和删除操作，且不关心随机访问的效率，可以选择list；如果需要支持高效的随机访问，并且在两端进行快速插入和删除操作，可以选择deque。</p><h3 id="4-22-STL中的allocator、deallocator"><a href="#4-22-STL中的allocator、deallocator" class="headerlink" title="4.22 STL中的allocator、deallocator"></a>4.22 STL中的allocator、deallocator</h3><p>第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器；</p><p>第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块；</p><p>空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间；</p><p>空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存。</p><h3 id="4-23-常见容器性质总结？"><a href="#4-23-常见容器性质总结？" class="headerlink" title="4.23 常见容器性质总结？"></a>4.23 常见容器性质总结？</h3><p>1.vector 底层数据结构为数组 ，支持快速随机访问</p><p>2.list 底层数据结构为双向链表，支持快速增删</p><p>3.deque 底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问</p><p>deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:</p><p>[堆1] –&gt; [堆2] –&gt;[堆3] –&gt; …</p><p>每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.</p><p>4.stack 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</p><p>5.queue 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）</p><p>6.priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</p><p>7.set 底层数据结构为红黑树，有序，不重复</p><p>8.multiset 底层数据结构为红黑树，有序，可重复</p><p>9.map 底层数据结构为红黑树，有序，不重复</p><p>10.multimap 底层数据结构为红黑树，有序，可重复</p><p>11.unordered_set 底层数据结构为hash表，无序，不重复</p><p>12.unordered_multiset 底层数据结构为hash表，无序，可重复</p><p>13.unordered_map 底层数据结构为hash表，无序，不重复</p><p>14.unordered_multimap 底层数据结构为hash表，无序，可重复</p><h3 id="4-24-说一下STL每种容器对应的迭代器"><a href="#4-24-说一下STL每种容器对应的迭代器" class="headerlink" title="4.24 说一下STL每种容器对应的迭代器"></a>4.24 说一下STL每种容器对应的迭代器</h3><p>| 容器    |迭代器 |<br>| —     |—   |<br>| vector、deque  | 随机访问迭代器 |<br>| stack、queue、priority_queue  | 无 |<br>| list、(multi)set&#x2F;map  | 双向迭代器 |<br>| unordered_(multi)set&#x2F;map、forward_list  | 前向迭代器 |</p><h3 id="4-25-STL中迭代器失效的情况有哪些？"><a href="#4-25-STL中迭代器失效的情况有哪些？" class="headerlink" title="4.25 STL中迭代器失效的情况有哪些？"></a>4.25 STL中迭代器失效的情况有哪些？</h3><p>以vector为例：</p><p>插入元素：</p><ol><li><p>尾后插入：size &lt; capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size &#x3D;&#x3D; capacity时，所有迭代器均失效（需要重新分配空间）。</p></li><li><p>中间插入：中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size &#x3D;&#x3D; capacity时，所有迭代器均失效。</p></li></ol><p>删除元素：</p><ol><li><p>尾后删除：只有尾迭代失效。</p></li><li><p>中间删除：删除位置之后所有迭代失效。</p></li></ol><p>deque 和 vector 的情况类似,</p><p>而list双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器;</p><p>map&#x2F;set等关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器 mmp.erase(iter++);</p><p>unordered_(hash) 迭代器意义不大, rehash之后, 迭代器应该也是全部失效.</p><h3 id="4-26-hashtable中解决冲突有哪些方法？"><a href="#4-26-hashtable中解决冲突有哪些方法？" class="headerlink" title="4.26 hashtable中解决冲突有哪些方法？"></a>4.26 hashtable中解决冲突有哪些方法？</h3><p><strong>记住前三个：</strong></p><ul><li><p>线性探测<br>使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位</p></li><li><p>开链<br>每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中</p></li><li><p>再散列<br>发生冲突时使用另一种hash函数再计算一个地址，直到不冲突</p></li><li><p>二次探测<br>使用hash函数计算出的位置如果已经有元素占用了，按照$1^2$、$2^2$、$3^2$…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测</p></li><li><p>公共溢出区<br>一旦hash函数计算的结果相同，就放入公共溢出区</p></li></ul><h2 id="五、其余问题"><a href="#五、其余问题" class="headerlink" title="五、其余问题"></a>五、其余问题</h2><h3 id="5-1-C-多态"><a href="#5-1-C-多态" class="headerlink" title="5.1 C++多态"></a>5.1 C++多态</h3><p>C++中，多态性主要通过两种方式实现：编译时多态（静态多态）和运行时多态（动态多态）。这两种多态的机制、特点和用途有所不同。</p><ul><li>编译时多态（静态多态）:<br>编译时多态是在程序编译阶段实现的多态性。主要通过函数重载、运算符重载和模板来实现。</li></ul><p>函数重载: 同一个作用域内存在多个同名函数，但它们的参数类型或数量不同。根据调用时实际传递的参数类型和数量，编译器决定调用哪个函数。<br>运算符重载: 允许定义或重新定义大部分C++内置的运算符，使得它们可以根据操作数的类型执行不同的操作。<br>编译时多态的决策是在编译时做出的，因此它不支持在运行时根据对象的实际类型来选择相应的成员函数。</p><ul><li>运行时多态（动态多态）: 运行时多态是在程序运行阶段实现的多态性。它主要通过虚函数和继承来实现。</li></ul><p>虚函数: 通过在基类中声明虚函数，允许派生类中重写该函数。当通过基类的指针或引用调用虚函数时，实际执行的是与指针或引用所指对象的实际类型相对应的函数版本。<br>抽象类和纯虚函数: 抽象类至少包含一个纯虚函数。纯虚函数在基类中没有实现，派生类必须重写这个函数。抽象类不能被实例化。</p><h3 id="5-2-什么时候的析构函数必须写成虚函数"><a href="#5-2-什么时候的析构函数必须写成虚函数" class="headerlink" title="5.2 什么时候的析构函数必须写成虚函数"></a>5.2 什么时候的析构函数必须写成虚函数</h3><p>一般情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。这样做是为了当<code>用一个基类的指针删除一个派生类的对象时</code>，派生类的析构函数会被调用。 </p><p>当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有<code>当一个类被用来作为基类的时候</code>，才把析构函数写成虚函数。</p><h3 id="5-3-构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"><a href="#5-3-构造函数能否声明为虚函数或者纯虚函数，析构函数呢？" class="headerlink" title="5.3 构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"></a>5.3 构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</h3><ul><li>析构函数：  <ul><li>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。<br>只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</li><li>析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。</li></ul></li><li>构造函数：  <ul><li>根据《effective C++》的条款09：绝不在构造和析构过程中调用虚函数可知，在构造函数中虽然可以调用虚函数，但是强烈建议不要这样做。因为基类的构造的过程中，虚函数不能算作是虚函数。若构造函数中调用虚函数，可能会导致不确定行为的发生.</li><li>虚函数对应一个vtable(虚函数表)，类中存储一个vptr指向这个vtable。如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数。</li></ul></li></ul><h3 id="5-4-目标文件存储结构"><a href="#5-4-目标文件存储结构" class="headerlink" title="5.4 目标文件存储结构"></a>5.4 目标文件存储结构</h3><table><thead><tr><th>段</th><th>功能</th></tr></thead><tbody><tr><td>File Header</td><td>文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）</td></tr><tr><td>.text section</td><td>代码段，执行语句编译成的机器代码</td></tr><tr><td>.data section</td><td>数据段，已初始化的全局变量和局部静态变量</td></tr><tr><td>.bss section</td><td>BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）</td></tr><tr><td>.rodata section</td><td>只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量</td></tr><tr><td>.comment section</td><td>注释信息段，存放编译器版本信息</td></tr><tr><td>.note.GNU-stack section</td><td>堆栈提示段</td></tr></tbody></table><blockquote><p>其他段略</p></blockquote><h3 id="5-5-基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#5-5-基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="5.5 基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>5.5 基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h3><ul><li>C++中<code>虚函数表</code>位于<code>只读数据段（.rodata）</code>，也就是C++内存模型中的<code>常量区</code></li><li>而<code>虚函数</code>则位于<code>代码段（.text）</code>，也就是C++内存模型中的<code>代码区</code>。</li><li>在构造函数执行时会对虚表指针进行初始化，并且存在对象<code>内存布局的最前面</code>。</li></ul><h3 id="5-6-模板函数和模板类的特例化"><a href="#5-6-模板函数和模板类的特例化" class="headerlink" title="5.6 模板函数和模板类的特例化"></a>5.6 模板函数和模板类的特例化</h3><ul><li><p>引入原因：<br>编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</p></li><li><p>定义：<br>对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上</p></li></ul><p>（1）模板函数特例化</p><p>必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对&lt;&gt;，表明将原模板的所有模板参数提供实参，举例如下：</p><pre><code class="cpp">template&lt;typename T&gt; //模板函数int compare(const T &amp;v1,const T &amp;v2)&#123;    if(v1 &gt; v2) return -1;    if(v2 &gt; v1) return 1;    return 0;&#125;//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个Ttemplate&lt;&gt; int compare(const char* const &amp;v1,const char* const &amp;v2)&#123;    return strcmp(p1,p2);&#125;</code></pre><ul><li><p>本质<br>特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用特例化版本（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。</p></li><li><p>注意<br>模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</p></li></ul><p>（2）类模板特例化</p><p>原理类似函数模板，<strong>不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。</strong>对类进行特例化时，仍然用template&lt;&gt;表示是一个特例化版本，例如：</p><pre><code class="cpp">template&lt;&gt;class hash&lt;sales_data&gt;&#123;    size_t operator()(sales_data&amp; s);    //里面所有T都换成特例化类型版本sales_data    //按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。&#125;;</code></pre><p>类模板的部分特例化</p><p>不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)</p><p>特例化类中的部分成员</p><p>可以特例化类中的部分成员函数而不是整个类，举个例子：</p><pre><code class="cpp">template&lt;typename T&gt;class Foo&#123;    void Bar();    void Barst(T a)();&#125;;template&lt;&gt;void Foo&lt;int&gt;::Bar()&#123;    //进行int类型的特例化处理    cout &lt;&lt; &quot;我是int型特例化&quot; &lt;&lt; endl;&#125;Foo&lt;string&gt; fs;Foo&lt;int&gt; fi;//使用特例化fs.Bar();//使用的是普通模板，即Foo&lt;string&gt;::Bar()fi.Bar();//特例化版本，执行Foo&lt;int&gt;::Bar()//Foo&lt;string&gt;::Bar()和Foo&lt;int&gt;::Bar()功能不同</code></pre><h3 id="5-7-模板定义和实现可不可以不写在一个文件里面？为什么？"><a href="#5-7-模板定义和实现可不可以不写在一个文件里面？为什么？" class="headerlink" title="5.7 模板定义和实现可不可以不写在一个文件里面？为什么？"></a>5.7 模板定义和实现可不可以不写在一个文件里面？为什么？</h3><p>模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着**编译器在当时不为它分配存储空间(没有具体的函数时不会对模板实例化)**，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p><p>定义一个类一般都是在头文件中进行类声明，在cpp文件中实现，但使用模板时应注意目前的C++编译器还无法分离编译，最好将实现代码和声明代码均放在头文件中。如：</p><pre><code class="cpp">// test.htemplate &lt;class T&gt;class CTest&#123;  public:          T&amp; GetValue();        protected:  T m_Value;&#125;; // test.cpptemplate &lt;class T&gt;T&amp; CTest&lt;T&gt;::GetValue()&#123;       return m_Value;  &#125;</code></pre><p>在这儿test.cpp中的内容应放在test.h中，否则在生成最终可执行程序时就会出现错误(在链接时会出错)。因为<code>在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现</code>，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。</p><h3 id="5-8-构造函数、析构函数、虚函数可否声明为内联函数"><a href="#5-8-构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="5.8 构造函数、析构函数、虚函数可否声明为内联函数"></a>5.8 构造函数、析构函数、虚函数可否声明为内联函数</h3><p>首先，将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。</p><blockquote><p>register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率</p></blockquote><p>构造函数和析构函数声明为内联函数是没有意义的</p><p>《Effective C++》中所阐述的是：将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请&#x2F;释放内存，构造&#x2F;析构对象等），致使构造函数&#x2F;析构函数并不像看上去的那么精简。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。</p><p>将虚函数声明为inline，要分情况讨论</p><p>有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联呢？</p><p>上述观点看似正确，其实不然，如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当用对象调用虚函数（此时不具有多态性）时，就内联展开</p><p>综上，当是<code>指向派生类的指针（多态性）</code>调用声明为inline的虚函数时，不会内联展开；当是<code>对象本身调用虚函数</code>时，会内联展开，当然前提依然是函数并不复杂的情况下。</p><h3 id="5-9-C-模板是什么，你知道底层怎么实现的？"><a href="#5-9-C-模板是什么，你知道底层怎么实现的？" class="headerlink" title="5.9 C++模板是什么，你知道底层怎么实现的？"></a>5.9 C++模板是什么，你知道底层怎么实现的？</h3><ul><li><p>编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</p></li><li><p>这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</p></li></ul><h3 id="5-10-构造函数和析构函数可以调用虚函数吗，为什么"><a href="#5-10-构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="5.10 构造函数和析构函数可以调用虚函数吗，为什么"></a>5.10 构造函数和析构函数可以调用虚函数吗，为什么</h3><p>在C++中，提倡不在构造函数和析构函数中调用虚函数；</p><p>构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；</p><p>因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；</p><p>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</p><h3 id="5-11-如何解决菱形继承"><a href="#5-11-如何解决菱形继承" class="headerlink" title="5.11 如何解决菱形继承"></a>5.11 如何解决菱形继承</h3><p>使用虚继承：</p><p>虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。 如:类D继承自类B1、B2，而类B1、B2都继 承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为虚拟继承，而A就成了虚拟基类,虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。</p><p>虚继承的特点是，在任何派生类中的virtual基类总用同一个（共享）对象表示，</p><h3 id="5-12-将字符串“hello-world”从开始到打印到屏幕上的全过程"><a href="#5-12-将字符串“hello-world”从开始到打印到屏幕上的全过程" class="headerlink" title="5.12 将字符串“hello world”从开始到打印到屏幕上的全过程?"></a>5.12 将字符串“hello world”从开始到打印到屏幕上的全过程?</h3><ol><li><p>用户告诉操作系统执行HelloWorld程序（通过键盘输入等）</p></li><li><p>操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。</p></li><li><p>操作系统：创建一个新进程，将HelloWorld可执行文件映射到该进程结构，表示由该进程执行helloworld程序。</p></li><li><p>操作系统：为helloworld程序设置cpu上下文环境，并跳到程序开始处。</p></li><li><p>执行helloworld程序的第一条指令，发生缺页异常</p></li><li><p>操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序</p></li><li><p>helloword程序执行puts函数（系统调用），在显示器上写一字符串</p></li><li><p>操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程</p></li><li><p>操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区</p></li><li><p>视频硬件将像素转换成显示器可接收和一组控制数据信号</p></li><li><p>显示器解释信号，激发液晶屏</p></li><li><p>OK，我们在屏幕上看到了HelloWorld</p></li></ol><h3 id="5-13-为什么拷贝构造函数必须传引用不能传值？"><a href="#5-13-为什么拷贝构造函数必须传引用不能传值？" class="headerlink" title="5.13 为什么拷贝构造函数必须传引用不能传值？"></a>5.13 为什么拷贝构造函数必须传引用不能传值？</h3><p>拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。</p><h3 id="5-14-虚函数的调用关系"><a href="#5-14-虚函数的调用关系" class="headerlink" title="5.14 虚函数的调用关系"></a>5.14 虚函数的调用关系</h3><p>this -&gt; vptr -&gt; vtable -&gt;virtual function</p><h3 id="5-15-说一说你了解到的移动构造函数？"><a href="#5-15-说一说你了解到的移动构造函数？" class="headerlink" title="5.15 说一说你了解到的移动构造函数？"></a>5.15 说一说你了解到的移动构造函数？</h3><ol><li><p>有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</p></li><li><p>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；</p></li><li><p>C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；</p></li><li><p>与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作；</p></li></ol><pre><code class="cpp">Example6 (Example6&amp;&amp; x) : ptr(x.ptr)   &#123;    x.ptr = nullptr;  &#125;  // move assignment  Example6&amp; operator= (Example6&amp;&amp; x)   &#123;   delete ptr;    ptr = x.ptr;   x.ptr=nullptr;    return *this;&#125;</code></pre><h3 id="5-16-哪些函数不能是虚函数？把你知道的都说一说"><a href="#5-16-哪些函数不能是虚函数？把你知道的都说一说" class="headerlink" title="5.16 哪些函数不能是虚函数？把你知道的都说一说"></a>5.16 哪些函数不能是虚函数？把你知道的都说一说</h3><ol><li><p>构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；</p></li><li><p>内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；</p></li><li><p>静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。</p></li><li><p>友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</p></li><li><p>普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。</p></li></ol><h3 id="5-17-什么是纯虚函数，与虚函数的区别"><a href="#5-17-什么是纯虚函数，与虚函数的区别" class="headerlink" title="5.17 什么是纯虚函数，与虚函数的区别"></a>5.17 什么是纯虚函数，与虚函数的区别</h3><ul><li><p>虚函数和纯虚函数区别？<br>虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。</p></li><li><p>纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。</p></li><li><p>纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“&#x3D;0”。</p></li><li><p>既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。</p></li><li><p>一个类中如果有纯虚函数的话，称其为抽象类。抽象类不能用于实例化对象，否则会报错。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象。</p></li></ul><h3 id="5-18-DLL劫持"><a href="#5-18-DLL劫持" class="headerlink" title="5.18 DLL劫持"></a>5.18 DLL劫持</h3><p>DLL 劫持（DLL hijacking）是一种安全漏洞，利用该漏洞，攻击者可以将恶意 DLL 文件伪装成系统或应用程序所需的 DLL 文件，并放置在系统搜索路径中，以便在程序运行时被加载并执行恶意代码。</p><p>攻击者通常利用以下几种方法进行 DLL 劫持：</p><ol><li><strong>将恶意 DLL 放置在可被系统搜索到的目录中</strong>：攻击者可以将恶意 DLL 文件放置在系统搜索路径中的一个或多个目录中，例如程序所在目录、当前工作目录、系统目录（如 System32）或者应用程序目录等。当程序启动时，系统会按照一定的搜索顺序查找并加载所需的 DLL 文件，如果发现了恶意 DLL，就会加载并执行其中的恶意代码。</li><li><strong>利用缺陷的搜索顺序</strong>：有些程序在加载 DLL 文件时存在搜索顺序上的缺陷，例如优先从当前工作目录加载 DLL 文件而不是系统目录。攻击者可以利用这种缺陷，将恶意 DLL 文件放置在当前工作目录下，并等待程序启动时被加载执行。</li><li><strong>利用自定义环境变量</strong>：攻击者可以利用自定义的环境变量来修改程序的搜索路径，从而加载恶意 DLL 文件。例如，攻击者可以通过修改 PATH 环境变量，将恶意 DLL 文件所在的目录添加到系统搜索路径中。</li></ol><p>为了防止 DLL 劫持攻击，可以采取以下几种措施：</p><ol><li><strong>使用绝对路径加载 DLL 文件</strong>：在程序中明确指定 DLL 文件的绝对路径，而不是依赖系统搜索路径。这样可以确保程序只加载所需的 DLL 文件，并避免加载恶意 DLL 文件。</li><li><strong>加强权限控制</strong>：限制用户对系统目录和应用程序目录的写入权限，防止恶意 DLL 文件被放置在系统搜索路径中。<br>更新程序：及时更新程序，修复可能存在的 DLL 劫持漏洞。一些程序已经针对 DLL 劫持进行了修复，并提供了安全更新。</li><li><strong>使用数字签名</strong>：对 DLL 文件进行数字签名，确保文件的完整性和来源可信。程序在加载 DLL 文件时可以验证其数字签名，以确保文件未被篡改。<br>启用安全策略：在操作系统和应用程序中启用相应的安全策略，限制恶意代码的执行。例如，使用应用程序白名单、启用应用程序沙盒等。</li></ol><p>通过采取以上措施，可以有效地防止 DLL 劫持攻击，并保护系统和应用程序的安全。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2024/03/22/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/03/22/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p>由于md文件同一个效果可能有不同写法，我只记录下我喜欢的用法，方便后续查询使用。</p><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><pre><code class="txt"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h2 id="二、段落样式"><a href="#二、段落样式" class="headerlink" title="二、段落样式"></a>二、段落样式</h2><h3 id="2-1-换行"><a href="#2-1-换行" class="headerlink" title="2.1 换行"></a>2.1 换行</h3><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用<code>两个以上空格加上回车</code>。<br>而在<code>换行基础上加一个回车</code>或者直接<code>两次回车</code>会导致空出一行。</p><h3 id="2-2-字体"><a href="#2-2-字体" class="headerlink" title="2.2 字体"></a>2.2 字体</h3><p>Markdown 可以使用<code>*</code>或者<code>_</code>切换字体<br>示例如下：</p><pre><code class="txt">*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___</code></pre><h3 id="2-3-分隔线"><a href="#2-3-分隔线" class="headerlink" title="2.3 分隔线"></a>2.3 分隔线</h3><p>你可以在一行中用<code>三个以上的星号、减号、底线</code>来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><pre><code class="txt">**** * ******- - -----------</code></pre><h3 id="2-4-删除线"><a href="#2-4-删除线" class="headerlink" title="2.4 删除线"></a>2.4 删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线<code>~~</code>即可，实例如下：</p><pre><code class="txt">~~BAIDU.COM~~</code></pre><p>效果：<del>BAIDU.COM</del></p><h3 id="2-5-下划线"><a href="#2-5-下划线" class="headerlink" title="2.5 下划线"></a>2.5 下划线</h3><p>下划线可以通过HTML的<code>&lt;u&gt;</code>标签来实现：</p><pre><code class="txt">&lt;u&gt;带下划线文本&lt;/u&gt;</code></pre><p>效果：<u>带下划线文本</u></p><h2 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h2><p>Markdown 支持有序列表和无序列表。</p><h3 id="3-1-无序列表"><a href="#3-1-无序列表" class="headerlink" title="3.1 无序列表"></a>3.1 无序列表</h3><p>无序列表使用<code>星号(*)</code>、<code>加号(+)</code>或是<code>减号(-)</code>作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><pre><code class="txt">* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>效果如下：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><h3 id="3-2-有序列表"><a href="#3-2-有序列表" class="headerlink" title="3.2 有序列表"></a>3.2 有序列表</h3><p>有序列表使用数字并加上 . 号来表示，如：</p><pre><code class="txt">1. 第一项2. 第二项3. 第三项</code></pre><p>效果如下：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="3-3-列表嵌套"><a href="#3-3-列表嵌套" class="headerlink" title="3.3 列表嵌套"></a>3.3 列表嵌套</h3><p>列表嵌套只需在子列表中的选项前面添加两个或四个空格即可：</p><pre><code class="txt">1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><p>效果如下：</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h2 id="四、区块"><a href="#四、区块" class="headerlink" title="四、区块"></a>四、区块</h2><h3 id="4-1-区块使用"><a href="#4-1-区块使用" class="headerlink" title="4.1 区块使用"></a>4.1 区块使用</h3><p>Markdown 区块引用是在段落开头使用<code>&gt;</code>符号 ，然后后面紧跟<code>一个空格</code>符号：</p><pre><code class="txt">&gt; 区块引用</code></pre><p>效果如下：</p><blockquote><p>Tips：在vscode里面使用markdown的时候，可以拆分编辑器，一边预览，一边写作。</p></blockquote><h3 id="4-2-区块嵌套"><a href="#4-2-区块嵌套" class="headerlink" title="4.2 区块嵌套"></a>4.2 区块嵌套</h3><p>另外区块是可以嵌套的，一个<code>&gt;</code>符号是最外层，两个<code>&gt;</code>符号是第一层嵌套，以此类推：</p><pre><code class="txt">&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><p>效果如下：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h3 id="4-3-区块与列表"><a href="#4-3-区块与列表" class="headerlink" title="4.3 区块与列表"></a>4.3 区块与列表</h3><p>区块中使用列表<br>区块中使用列表实例如下：</p><pre><code class="txt">&gt; 区块中使用列表&gt; 1. 第一项&gt; + 第一项</code></pre><p>效果如下：</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li></ol><ul><li>第一项</li></ul></blockquote><h2 id="五、代码"><a href="#五、代码" class="headerlink" title="五、代码"></a>五、代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（&#96;），例如：</p><pre><code class="txt">`printf()` 函数</code></pre><p>效果如下：<br><code>printf()</code> 函数</p><p>你也可以用<code>```</code>包裹一段代码，并指定一种语言（也可以不指定）<br>例如指定为javascript：<br><code> ```javascript</code><br><code>代码块</code><br><code>```</code><br>效果如下：</p><pre><code class="javascript">$(document).ready(function () &#123;    alert(&#39;RUNOOB&#39;);&#125;);</code></pre><h2 id="六、链接"><a href="#六、链接" class="headerlink" title="六、链接"></a>六、链接</h2><h3 id="6-1-直接链接"><a href="#6-1-直接链接" class="headerlink" title="6.1 直接链接"></a>6.1 直接链接</h3><pre><code class="txt">&lt;链接地址&gt;</code></pre><p>效果：<br><a href="https://hualog.dns.navy/">https://hualog.dns.navy</a></p><h3 id="6-2-别名链接"><a href="#6-2-别名链接" class="headerlink" title="6.2 别名链接"></a>6.2 别名链接</h3><pre><code class="txt">[链接名称](链接地址)</code></pre><p>效果：<a href="https://hualog.dns.navy/">花落阁</a></p><h3 id="6-3-高级链接"><a href="#6-3-高级链接" class="headerlink" title="6.3 高级链接"></a>6.3 高级链接</h3><p>如果一个链接被多次使用，我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><pre><code class="txt">这个链接用 hualog 作为网址变量 [花落阁][hualog]然后在文档的结尾为变量赋值（网址）[hualog]: https://hualog.dns.navy</code></pre><p>效果：<br>这个链接用 hualog 作为网址变量 <a href="https://hualog.dns.navy/">花落阁</a></p><h2 id="七、图片"><a href="#七、图片" class="headerlink" title="七、图片"></a>七、图片</h2><p>Markdown 图片语法格式如下：</p><pre><code class="txt">![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)</code></pre><p>效果如下：<br><img src="/2024/03/22/Markdown%E8%AF%AD%E6%B3%95/cat.jpg" alt="元宝 图标"></p><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的<code>&lt;img&gt;</code>标签。</p><pre><code class="html">&lt;img src=&quot;/img/cat.jpg&quot; width=&quot;50%&quot;&gt;</code></pre><img src="/2024/03/22/Markdown%E8%AF%AD%E6%B3%95/cat.jpg" width="50%"><h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><h3 id="8-1-初始表格"><a href="#8-1-初始表格" class="headerlink" title="8.1 初始表格"></a>8.1 初始表格</h3><p>语法格式如下：</p><pre><code class="txt">|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><p>效果如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><h3 id="8-2-表格对齐方式"><a href="#8-2-表格对齐方式" class="headerlink" title="8.2 表格对齐方式"></a>8.2 表格对齐方式</h3><p>我们可以设置表格的对齐方式：</p><p><code>-:</code>设置内容和标题栏居右对齐。<br><code>:-</code>设置内容和标题栏居左对齐。<br><code>:-:</code>设置内容和标题栏居中对齐。<br>实例如下：</p><pre><code class="txt">| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: ||   x   |   x   |   x    ||   x   |   x   |   x    |</code></pre><p>效果：</p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">x</td><td align="right">x</td><td align="center">x</td></tr><tr><td align="left">x</td><td align="right">x</td><td align="center">x</td></tr></tbody></table><h2 id="九、高级技巧"><a href="#九、高级技巧" class="headerlink" title="九、高级技巧"></a>九、高级技巧</h2><h3 id="9-1-支持的-HTML-元素"><a href="#9-1-支持的-HTML-元素" class="headerlink" title="9.1 支持的 HTML 元素"></a>9.1 支持的 HTML 元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等 ，如：</p><pre><code class="txt">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre><p>效果：<br>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h3 id="9-2-转义"><a href="#9-2-转义" class="headerlink" title="9.2 转义"></a>9.2 转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><pre><code class="txt">**文本加粗** \*\* 正常显示星号 \*\*</code></pre><p>效果：<br><strong>文本加粗</strong><br>** 正常显示星号 **</p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code class="txt">\   反斜线`   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号</code></pre><h3 id="9-3-公式"><a href="#9-3-公式" class="headerlink" title="9.3 公式"></a>9.3 公式</h3><p>Markdown Preview Enhanced 使用 KaTeX 或者 MathJax 来渲染数学表达式。</p><p>KaTeX 拥有比 MathJax 更快的性能，但是它却少了很多 MathJax 拥有的特性。你可以查看 KaTeX supported functions&#x2F;symbols 来了解 KaTeX 支持那些符号和函数。</p><pre><code class="txt">$...$ 或者 \(...\) 中的数学表达式将会在行内显示。$$...$$ 或者 \[...\] 或者 ```math 中的数学表达式将会在块内显示。</code></pre><p>例如：</p><pre><code class="txt">$f(x) = sin(x) + cos(x)$$$f(x) = sin(x) + cos(x)$$</code></pre><p>行内：<br>$f(x) &#x3D; sin(x) + cos(x)$<br>块内：<br>$$f(x) &#x3D; sin(x) + cos(x)$$</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> md </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
