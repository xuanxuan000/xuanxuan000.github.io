<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++设计模式</title>
      <link href="/2024/05/06/C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/05/06/C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="C-设计模式"><a href="#C-设计模式" class="headerlink" title="C++设计模式"></a>C++设计模式</h1><h2 id="面对对象中的设计原则"><a href="#面对对象中的设计原则" class="headerlink" title="面对对象中的设计原则"></a>面对对象中的设计原则</h2><h3 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h3><p>SOLID 是面向对象设计的五个核心原则的首字母缩写。每个原则都是指导良好设计的重要指南。</p><ul><li><p>**单一职责原则 (Single Responsibility Principle, SRP)**：<br>一个类应该只有一个明确的职责。换句话说，一个类应该只有一个导致其变化的原因。这有助于减少类的复杂性，并提高代码的可维护性和测试性。</p></li><li><p>**开放封闭原则 (Open&#x2F;Closed Principle, OCP)**：<br>软件实体（如类、模块、函数等）应该对扩展开放，对修改封闭。这意味着代码应该可以通过添加新功能进行扩展，而不需要修改现有代码，从而减少了因代码变更引发的错误风险。</p></li><li><p>**里氏替换原则 (Liskov Substitution Principle, LSP)**：<br>子类应该可以替换其基类而不破坏程序的正确性。这确保了继承关系的合理性，避免了因为继承层次结构的不一致而导致的错误。<br>  即：<br>  <code>子类可以扩展父类的功能，但不能改变父类原有的功能。</code></p></li><li><p>**接口隔离原则 (Interface Segregation Principle, ISP)**：<br>客户端不应该被迫实现它们不使用的接口。应当为特定的功能定义更小的接口，而不是一个包含过多方法的庞大接口。这减少了不必要的耦合，并提高了接口的可用性。<br>  即：<br>  <code>使用多个专门的接口，而不使用单一的总接口</code></p></li><li><p><strong>依赖倒置原则 (Dependency Inversion Principle, DIP)<strong>：<br><strong>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</strong>；</strong>抽象不应该依赖于细节，细节应该依赖于抽象</strong>。这强调了通过接口或抽象类建立模块之间的联系，而不是直接依赖于具体实现。</p><ul><li>传统的自顶向下设计<br>  <img src="/2024/05/06/C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE01.png"></li><li>依赖倒置原则<br>  <img src="/2024/05/06/C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE02.png"></li></ul></li></ul><h3 id="其他设计原则"><a href="#其他设计原则" class="headerlink" title="其他设计原则"></a>其他设计原则</h3><p>除了 SOLID 原则，还有其他一些重要的面向对象设计原则：</p><ul><li><p>**迪米特法则 (Law of Demeter, LoD)**：<br>一个对象应该对其他对象有尽可能少的了解。即，避免过多的直接对象关系，减少对象之间的耦合。</p></li><li><p>**组合优于继承 (Composition over Inheritance)**：<br>在设计系统时，优先考虑使用组合来扩展功能，而不是过度依赖继承。组合可以提供更大的灵活性和更低的耦合度。</p></li><li><p>**防御式编程 (Defensive Programming)**：<br>编写代码时，考虑潜在的异常情况，并确保代码在异常情况下不会崩溃。这有助于提高代码的鲁棒性和稳定性。</p></li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><pre><code class="C++">class Singleton&#123;public:    // 获取单例实例的静态成员函数    static Singleton&amp; getInstance()&#123;        static Singleton inst;        return inst;    &#125;    // 删除拷贝构造函数和赋值运算符，防止复制和赋值    Singleton(const Singleton&amp;) = delete;    Singleton&amp; operator=(const Singleton&amp;) = delete;private:    // 私有化构造函数，防止外部创建实例    Singleton() &#123;&#125;    // 私有化析构函数，确保单例对象在程序结束时被正确销毁    ~Singleton() &#123;&#125;&#125;</code></pre><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><p>在不暴露对象创建细节的情况下，根据输入参数创建对象</p><p>缺点：</p><ul><li>创建新的产品需要修改工厂方法，不符合开放封闭原则</li></ul><pre><code class="C++">// 产品基类class Product &#123;public:    virtual void use() = 0; // 虚函数&#125;;// 具体产品 Aclass ProductA : public Product &#123;public:    void use() override &#123;        std::cout &lt;&lt; &quot;Using Product A\n&quot;;    &#125;&#125;;// 具体产品 Bclass ProductB : public Product &#123;public:    void use() override &#123;        std::cout &lt;&lt; &quot;Using Product B\n&quot;;    &#125;&#125;;// 简单工厂类class SimpleFactory &#123;public:    std::unique_ptr&lt;Product&gt; createProduct(const std::string&amp; type) &#123;        if (type == &quot;A&quot;) &#123;            return std::make_unique&lt;ProductA&gt;();        &#125; else if (type == &quot;B&quot;) &#123;            return std::make_unique&lt;ProductB&gt;();        &#125; else &#123;            return nullptr;        &#125;    &#125;&#125;;int main() &#123;    SimpleFactory factory;    auto productA = factory.createProduct(&quot;A&quot;);    if (productA) &#123;        productA-&gt;use(); // 输出：Using Product A    &#125;    auto productB = factory.createProduct(&quot;B&quot;);    if (productB) &#123;        productB-&gt;use(); // 输出：Using Product B    &#125;    return 0;&#125;</code></pre><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>实现对象的<strong>延迟创建</strong>或动态选择，具体工厂中可以做别的操作</p><p>2抽象2具体，新增产品与工厂不需要改变代码，<strong>解决了简单工厂开闭原则的问题</strong></p><pre><code class="C++">// 产品基类class Product &#123;public:    virtual void use() = 0; // 虚函数&#125;;// 具体产品 Aclass ProductA : public Product &#123;public:    void use() override &#123;        std::cout &lt;&lt; &quot;Using Product A\n&quot;;    &#125;&#125;;// 具体产品 Bclass ProductB : public Product &#123;public:    void use() override &#123;        std::cout &lt;&lt; &quot;Using Product B\n&quot;;    &#125;&#125;;// 工厂方法接口class Factory &#123;public:    virtual std::unique_ptr&lt;Product&gt; createProduct() = 0; // 工厂方法&#125;;// 具体工厂 Aclass FactoryA : public Factory &#123;public:    std::unique_ptr&lt;Product&gt; createProduct() override &#123;        return std::make_unique&lt;ProductA&gt;();    &#125;&#125;;// 具体工厂 Bclass FactoryB : public Factory &#123;public:    std::unique_ptr&lt;Product&gt; createProduct() override &#123;        return std::make_unique&lt;ProductB&gt;();    &#125;&#125;;int main() &#123;    FactoryA factoryA;    auto productA = factoryA.createProduct();    productA-&gt;use(); // 输出：Using Product A    FactoryB factoryB;    auto productB = factoryB.createProduct();    productB-&gt;use(); // 输出：Using Product B    return 0;&#125;</code></pre><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><p>当系统需要创建一组相关或相互依赖的对象时，确保它们的一致性和正确性，避免直接依赖于具体类</p><p>抽象工厂的结构（2抽象2具体，基于工厂方法增加了组合复杂度）：</p><ul><li>抽象工厂接口：定义一系列用于创建产品的方法，每个方法对应一个产品类型。</li><li>具体工厂类：实现抽象工厂接口，具体负责创建特定类型的产品。</li><li>抽象产品接口：定义每个产品的接口。</li><li>具体产品类：实现抽象产品接口，提供具体产品的功能。</li></ul><pre><code class="C++">// 抽象产品接口class Chair &#123;public:    virtual void sit() = 0;&#125;;class Table &#123;public:    virtual void use() = 0;&#125;;// 具体产品class ModernChair : public Chair &#123;public:    void sit() override &#123;        std::cout &lt;&lt; &quot;Sitting on a modern chair.\n&quot;;    &#125;&#125;;class VictorianChair : public Chair &#123;public:    void sit() override &#123;        std::cout &lt;&lt; &quot;Sitting on a Victorian chair.\n&quot;;    &#125;&#125;;class ModernTable : public Table &#123;public:    void use() override &#123;        std::cout &lt;&lt; &quot;Using a modern table.\n&quot;;    &#125;&#125;;class VictorianTable : public Table &#123;public:    void use() override &#123;        std::cout &lt;&lt; &quot;Using a Victorian table.\n&quot;;    &#125;&#125;;// 抽象工厂接口class FurnitureFactory &#123;public:    virtual std::unique_ptr&lt;Chair&gt; createChair() = 0;    virtual std::unique_ptr&lt;Table&gt; createTable() = 0;&#125;;// 具体工厂class ModernFurnitureFactory : public FurnitureFactory &#123;public:    std::unique_ptr&lt;Chair&gt; createChair() override &#123;        return std::make_unique&lt;ModernChair&gt;();    &#125;    std::unique_ptr&lt;Table&gt; createTable() override &#123;        return std::make_unique&lt;ModernTable&gt;();    &#125;&#125;;class VictorianFurnitureFactory : public FurnitureFactory &#123;public:    std::unique_ptr&lt;Chair&gt; createChair() override &#123;        return std::make_unique&lt;VictorianChair&gt;();    &#125;    std::unique_ptr&lt;Table&gt; createTable() override &#123;        return std::make_unique&lt;VictorianTable&gt;();    &#125;&#125;;int main() &#123;    std::unique_ptr&lt;FurnitureFactory&gt; factory;    factory = std::make_unique&lt;ModernFurnitureFactory&gt;();    auto chair = factory-&gt;createChair();    auto table = factory-&gt;createTable();    chair-&gt;sit();  // 输出：Sitting on a modern chair.    table-&gt;use();  // 输出：Using a modern table.    factory = std::make_unique&lt;VictorianFurnitureFactory&gt;();    chair = factory-&gt;createChair();    table = factory-&gt;createTable();    chair-&gt;sit();  // 输出：Sitting on a Victorian chair.    table-&gt;use();  // 输出：Using a Victorian table.    return 0;&#125;</code></pre><h4 id="工厂方法与抽象工厂主要区别"><a href="#工厂方法与抽象工厂主要区别" class="headerlink" title="工厂方法与抽象工厂主要区别"></a>工厂方法与抽象工厂主要区别</h4><ul><li><p>工厂方法模式 主要用于创建单一类型的产品，通常是通过继承让子类来决定具体创建的产品类型。</p></li><li><p>抽象工厂模式 用于创建一系列相关或相互依赖的产品，提供多个工厂方法来创建不同类型的产品。具体工厂通过实现抽象工厂接口，提供具体的创建逻辑。</p></li></ul><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式（Observer Pattern） 是一种行为型设计模式，允许对象之间建立一种一对多的依赖关系。当一个对象的状态发生变化时，所有依赖它的对象都会收到通知并自动更新。这个模式通常用于事件驱动的系统、数据绑定、发布订阅机制等。</p><p>观察者模式的关键角色：</p><ul><li><p>主题（Subject）：也称为发布者（Publisher），它维护了一组观察者，并提供注册、注销观察者的方法，以及通知所有观察者的方法。</p></li><li><p>观察者（Observer）：也称为订阅者（Subscriber），它定义了接收通知的方法。观察者通过注册到主题，接收主题的状态变化通知。</p></li><li><p>通知方法：在观察者模式中，通常使用一个方法来通知所有观察者状态的变化。</p></li></ul><p>观察者模式的应用场景：</p><ul><li>当一个对象的状态变化需要通知其他对象时。</li><li>当希望松散耦合的设计，让对象之间的依赖关系最小化时。</li><li>当需要一种广播机制，允许对象间的事件传播时。</li></ul><pre><code class="C++">// 抽象观察者class Observer &#123;public:    virtual void update(float temperature) = 0;  // 接收更新的方法    virtual ~Observer() = default;&#125;;// 主题类class Subject &#123;public:    void addObserver(std::shared_ptr&lt;Observer&gt; observer) &#123;        observers.push_back(observer);  // 注册观察者    &#125;    void removeObserver(std::shared_ptr&lt;Observer&gt; observer) &#123;        observers.erase(            std::remove(observers.begin(), observers.end(), observer),            observers.end());  // 注销观察者    &#125;    void notifyObservers(float temperature) &#123;        for (auto&amp; observer : observers) &#123;            observer-&gt;update(temperature);  // 通知所有观察者        &#125;    &#125;private:    std::vector&lt;std::shared_ptr&lt;Observer&gt;&gt; observers;  // 观察者列表&#125;;// 具体观察者class Display : public Observer &#123;public:    void update(float temperature) override &#123;  // 实现更新方法        std::cout &lt;&lt; &quot;Temperature updated: &quot; &lt;&lt; temperature &lt;&lt; &quot;°C\n&quot;;    &#125;&#125;;// 主程序int main() &#123;    // 创建主题和观察者    auto weatherStation = std::make_shared&lt;Subject&gt;();    auto display1 = std::make_shared&lt;Display&gt;();    auto display2 = std::make_shared&lt;Display&gt;();    // 注册观察者    weatherStation-&gt;addObserver(display1);    weatherStation-&gt;addObserver(display2);    // 通知观察者    weatherStation-&gt;notifyObservers(25.0f);  // 所有观察者收到更新    // 注销一个观察者    weatherStation-&gt;removeObserver(display2);    // 再次通知观察者    weatherStation-&gt;notifyObservers(26.0f);  // 只有一个观察者收到更新    return 0;&#125;</code></pre><ul><li><p><strong>使用回调函数也是实现观察者模式的一种简洁而直接的方式</strong></p></li><li><p><strong>观察者模式与发布&#x2F;订阅模式</strong></p><p>  有读者可能认为MQTT协议的运行机制就是观察者模式，其实不然。</p><ul><li><p>观察者模式 是一种行为型设计模式，定义了对象之间的一对多关系。在这个模式中，”主题”（Subject）负责维护一个观察者列表，并在状态改变时通知所有观察者。观察者只关心从主题接收通知。</p></li><li><p>发布&#x2F;订阅模式（Publish&#x2F;Subscribe）允许发布者向一个主题发布消息，订阅者可以订阅这个主题并接收相关消息。与观察者模式不同的是，<strong>发布者和订阅者之间没有直接的耦合。它们通过中间层（如 MQTT 的 “Broker”）进行通信</strong>。</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 常识类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT多线程与线程池</title>
      <link href="/2024/05/05/QT%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2024/05/05/QT%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/wanghongyang/p/14902679.html">https://www.cnblogs.com/wanghongyang/p/14902679.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GDB使用说明</title>
      <link href="/2024/05/05/GDB%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2024/05/05/GDB%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="GDB-常用指令"><a href="#GDB-常用指令" class="headerlink" title="GDB 常用指令"></a>GDB 常用指令</h1><p>在使用 GDB（GNU Debugger）调试程序时，了解常用指令有助于快速解决问题、分析代码并找出错误。以下是一些 GDB 常用指令，涵盖了启动、断点设置、单步执行、变量查看、堆栈分析、错误追踪等方面。</p><ul><li>启动和加载程序<ul><li>启动 GDB：gdb .&#x2F;my_program，用指定的程序启动 GDB。</li><li>加载核心转储文件：gdb .&#x2F;my_program core，用于调试崩溃后生成的核心转储文件。</li></ul></li><li>运行和停止程序<ul><li>运行程序：run，启动程序。如果需要传递命令行参数，可以在后面加上参数列表：run arg1 arg2。</li><li>停止程序：使用 Ctrl+C 可以中断程序的运行，让 GDB 进入调试模式。</li><li>继续运行：continue 或 c，继续运行程序，直到下一个断点或异常。</li><li>重启程序：run，在 GDB 内部重新启动程序。</li></ul></li><li>断点设置与管理<ul><li>设置断点：break 或 b，用于设置断点。可以指定行号、函数名或文件名：</li><li>b 25 在第 25 行设置断点。</li><li>b main 在 main 函数设置断点。</li><li>查看断点：info breakpoints 或 i b，列出当前所有断点。</li><li>删除断点：delete 或 d，可以删除一个或多个断点。例如，d 1 删除第一个断点。</li><li>启用&#x2F;禁用断点：enable 或 disable，用于启用或禁用特定断点。</li></ul></li><li>单步执行和检查状态<ul><li>单步执行：step 或 s，单步进入函数内部。</li><li>逐行执行：next 或 n，逐行执行但不进入函数内部。</li><li>跳过函数：finish，跳过当前函数，返回调用它的上下文。</li><li>检查当前位置：where 或 bt，查看调用栈，追踪程序位置。</li></ul></li><li>查看变量和内存<ul><li>查看变量：print 或 p，用于显示变量的值。例如，p x 显示变量 x 的值。</li><li>查看内存：x，检查内存内容。可以指定格式和范围。</li><li>x&#x2F;10x 0x7ff… 显示从指定内存地址开始的 10 个字的十六进制值。</li><li>查看局部变量：info locals，列出当前作用域中的所有局部变量。</li><li>查看全局变量：info variables，列出所有全局变量。</li></ul></li><li>分析堆栈和错误<ul><li>查看调用栈：backtrace 或 bt，显示调用栈，帮助追踪函数调用顺序。</li><li>切换栈帧：frame 或 f，切换到特定栈帧以查看其上下文。</li><li>查看异常：当程序崩溃时，GDB 通常会显示错误信息。使用 bt 可以查看崩溃前的调用栈。</li></ul></li><li>其他实用命令<ul><li>重新编译和调试：在 GDB 中使用 make 可以重新编译程序，然后继续调试。</li><li>设置条件断点：b 25 if x &gt; 5，在满足条件时断点触发。</li><li>查看源码：list 或 l，显示源码行。</li><li>查看已加载库：info shared，查看所有加载的共享库。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang八股文</title>
      <link href="/2024/05/04/Golang%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/05/04/Golang%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Golang八股文"><a href="#Golang八股文" class="headerlink" title="Golang八股文"></a>Golang八股文</h1><h2 id="一、Go语言编程"><a href="#一、Go语言编程" class="headerlink" title="一、Go语言编程"></a>一、Go语言编程</h2><h3 id="1-1-make-和-new-的区别"><a href="#1-1-make-和-new-的区别" class="headerlink" title="1.1 make 和 new 的区别"></a>1.1 make 和 new 的区别</h3><ul><li>接收参数个数不一样：new() 只接收一个参数，而 make() 可以接收多个参数</li><li>返回类型不一样：new() 返回一个指针，而 make() 返回类型和它接收的第一个参数类型一样</li><li>应用场景不一样：make() 专门用来为 slice、map、chan 这样的引用类型分配内存并作初始化，而 new() 用来为其他类型分配内存。</li></ul><h3 id="1-2-切片和数组的比较"><a href="#1-2-切片和数组的比较" class="headerlink" title="1.2 切片和数组的比较"></a>1.2 切片和数组的比较</h3><p>切片的数据结构</p><pre><code class="Go">type slice struct &#123;    array unsafe.Pointer    len int    cap int&#125;</code></pre><p>切片的结构体由3部分构成，Pointer 是指向一个<code>数组的指针</code>，len 代表当前切片的<code>长度</code>，cap 是当前切片的<code>容量</code>。cap 总是大于等于 len 的。</p><ul><li>长度和容量：<ul><li>数组的长度是固定的，在声明时需要指定长度，并且不能动态改变。数组的声明方式为 [长度]类型，例如 [5]int 表示一个包含 5 个整数的数组。</li><li>切片的长度可以动态改变，它是对底层数组的一个视图，可以根据需要动态调整其长度。切片的声明方式为 []类型，例如 []int 表示一个整数切片。</li></ul></li><li>传递和拷贝：<ul><li>数组在传递给函数或赋值给其他变量时会 进行<strong>值拷贝</strong>，即创建一个完全相同的新数组。</li><li>切片在传递给函数或赋值给其他变量时是<strong>引用传递</strong>，即传递的是切片的引用（底层数组的引用），修改切片会影响到原始切片和底层数组。</li></ul></li><li>底层数组：<ul><li>数组是一个固定长度的数据结构，它在内存中是连续存储的。</li><li>切片是一个动态长度的数据结构，它本质上是对底层数组的一个视图，通过指向底层数组的指针、长度和容量来表示切片。</li></ul></li></ul><h3 id="1-3-for-range-陷阱"><a href="#1-3-for-range-陷阱" class="headerlink" title="1.3 for range 陷阱"></a>1.3 for range 陷阱</h3><p>我之前写边缘网关项目的时候也遇到过：</p><p>在 Go 中，使用 for range 循环遍历切片、数组、映射等数据结构时，循环体中的变量可能会因为引用同一个内存地址而产生意想不到的行为。</p><p>切片&#x2F;数组：for range 会创建循环变量的拷贝，每次循环更新拷贝。因此，如果你取循环变量的地址，地址保持不变，因为你取的是循环变量的地址，而不是数据本身的地址。要避免这个问题，可以在循环体内创建变量的拷贝。<br>示例：避免地址变化导致的问题。</p><pre><code class="go">names := []string&#123;&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;&#125;// 这里会引发问题，因为 `name` 变量的地址固定pointers := []*string&#123;&#125;for _, name := range names &#123;  pointers = append(pointers, &amp;name)&#125;// 解决办法：创建变量的独立拷贝for _, name := range names &#123;  n := name  pointers = append(pointers, &amp;n)&#125;</code></pre><p>解决办法：  </p><ol><li>创建变量的独立拷贝</li><li>使用指针作为成员（不推荐，指针的使用可能增加内存管理的复杂性，可能导致内存泄漏。）</li></ol><h3 id="1-4-三种引号区别"><a href="#1-4-三种引号区别" class="headerlink" title="1.4 三种引号区别"></a>1.4 三种引号区别</h3><ul><li>单引号用于表示单个字符，类型是 rune。</li><li>双引号用于表示字符串，支持转义字符，类型是 string。</li><li>反引号用于表示原始字符串，不支持转义字符，保留原样，类型也是 string。<blockquote><p><code>rune</code>是 Go 语言中的一种数据类型，代表一个 Unicode 码点。它是一种特殊类型的整数，实际是 Go 的内置类型<code>int32</code>的别名。</p></blockquote></li></ul><h3 id="1-5-函数与方法"><a href="#1-5-函数与方法" class="headerlink" title="1.5 函数与方法"></a>1.5 函数与方法</h3><p>方法就是成员函数</p><h3 id="1-6-子切片导致的内存泄漏问题"><a href="#1-6-子切片导致的内存泄漏问题" class="headerlink" title="1.6 子切片导致的内存泄漏问题"></a>1.6 子切片导致的内存泄漏问题</h3><p>子切片可能导致内存泄露，因为它们可能引用了较大的底层数组。为了避免这个问题，<strong>确保在不需要引用底层数组时显式复制数据，并在不需要时释放切片。合理使用切片和定期监控内存是防止内存泄露的有效方法</strong>。</p><h3 id="1-7-Golang如何高效地拼接字符串？"><a href="#1-7-Golang如何高效地拼接字符串？" class="headerlink" title="1.7 Golang如何高效地拼接字符串？"></a>1.7 Golang如何高效地拼接字符串？</h3><p>在 Go 语言中，字符串是不可变的，所以<strong>直接使用 + 运算符拼接字符串可能导致性能问题</strong>，尤其是在大量拼接操作时。高效拼接字符串的方法包括使用<code>strings.Builder</code>、<code>bytes.Buffer</code> 和 <code>join</code> 等方式。这些方法在拼接大量字符串时比 + 运算符更有效。</p><ul><li>strings.Builder 是 Go 语言专为高效拼接字符串设计的工具。它可以动态分配内存，并在内部使用可变缓冲区来避免不必要的字符串复制。</li><li>特点：<ul><li>适合在循环中拼接字符串。</li><li>内部使用动态缓冲区，减少内存分配。</li></ul></li></ul><pre><code class="go">import (    &quot;strings&quot;)func efficientConcat(parts []string) string &#123;    var builder strings.Builder        for _, part := range parts &#123;        builder.WriteString(part) // 拼接字符串    &#125;        return builder.String() // 最后返回拼接结果&#125;</code></pre><ul><li>bytes.Buffer 类似于 strings.Builder，但主要用于操作字节。它适合在需要处理字节流或跨字符串和字节之间转换时使用。</li><li>特点：<ul><li>可以用于拼接字符串和字节。</li><li>在处理混合类型数据时表现良好。</li></ul></li></ul><pre><code class="go">import (    &quot;bytes&quot;)func bufferConcat(parts []string) string &#123;    var buffer bytes.Buffer        for _, part := range parts &#123;        buffer.WriteString(part) // 拼接字符串    &#125;        return buffer.String() // 最后返回拼接结果&#125;</code></pre><ul><li><p>strings.Join 是一个方便的函数，用于将字符串切片拼接成一个字符串，使用指定的分隔符。它适合在需要用特定字符分隔字符串时使用。</p></li><li><p>特点：</p><ul><li>可以用指定的分隔符拼接字符串。</li><li>对于拼接字符串切片，效率高。</li></ul></li></ul><pre><code class="go">import (    &quot;strings&quot;)func joinConcat(parts []string) string &#123;    return strings.Join(parts, &quot;, &quot;) // 用逗号和空格拼接&#125;</code></pre><p><strong>直接使用 + 运算符拼接字符串可能导致性能问题，因为每次拼接都会创建新的字符串，并复制内容。</strong></p><h3 id="1-8-Golang中2-个-interface-可以比较吗？"><a href="#1-8-Golang中2-个-interface-可以比较吗？" class="headerlink" title="1.8 Golang中2 个 interface 可以比较吗？"></a>1.8 Golang中2 个 interface 可以比较吗？</h3><p>在 Go 中，两个 interface 是否可比较取决于它们指向的底层类型。可以比较两个空接口，或者两个指向同一对象的接口。不可比较的类型，如切片、映射和函数，不能用于接口比较。如果尝试比较不可比较的接口，会引发运行时panic。在比较接口之前，确保它们的底层类型是可比较的，避免潜在的错误和panic。</p><h3 id="1-9-Golang-中-init-函数"><a href="#1-9-Golang-中-init-函数" class="headerlink" title="1.9 Golang 中 init() 函数"></a>1.9 Golang 中 init() 函数</h3><ul><li>自动执行：init() 不需要手动调用，会在包加载时自动执行。</li><li>没有参数和返回值：init() 不能接受参数，也没有返回值。</li><li>每个包可以有多个：一个包可以包含多个 init() 函数，按照源文件中的顺序执行。</li><li>执行顺序：init() 的执行顺序取决于包的导入顺序和依赖关系。</li></ul><h3 id="1-10-Golang的Map可以边遍历边删除元素吗？"><a href="#1-10-Golang的Map可以边遍历边删除元素吗？" class="headerlink" title="1.10 Golang的Map可以边遍历边删除元素吗？"></a>1.10 Golang的Map可以边遍历边删除元素吗？</h3><p>在 Go 中，边遍历 Map 边删除元素可能导致未定义行为或运行时恐慌。为了确保安全，建议先收集要删除的键，然后在第二个循环中删除这些键，或使用新的 Map 进行替换。这样可以避免边遍历边删除导致的问题，确保 Map 的稳定性和正确性。</p><h3 id="1-11-Golang的float类型可以作为Map的key吗？"><a href="#1-11-Golang的float类型可以作为Map的key吗？" class="headerlink" title="1.11 Golang的float类型可以作为Map的key吗？"></a>1.11 Golang的float类型可以作为Map的key吗？</h3><p>虽然 Go 允许 float 类型作为 Map 的键，但由于浮点数的精度和比较不稳定，不建议将其作为 Map 的键。推荐使用整数或字符串作为 Map 的键，以确保稳定性和可预测性。如果必须使用 float 类型作为键，请注意可能的精度问题，并确保足够的测试来验证行为的一致性。</p><h3 id="1-12-Golang中Map的数据结构是什么？"><a href="#1-12-Golang中Map的数据结构是什么？" class="headerlink" title="1.12 Golang中Map的数据结构是什么？"></a>1.12 Golang中Map的数据结构是什么？</h3><p>在Go语言中，map是一种键值对数据结构。它是一种<strong>哈希表实现</strong>，所以它是无序的。允许您通过键来快速检索、插入和删除值。map的键和值可以是各种类型，但键的类型必须是可以比较的类型，以支持哈希计算和键比较操作。常见的可比较类型包括整数、字符串、指针、接口、数组和结构体（条件是结构体的所有字段也必须是可比较的）。</p><p>值得注意的是，map在Go中是无序的，每次迭代的顺序可能不同。此外，map在并发情况下并不是线程安全的。如果需要并发访问map，可以使用同步机制，如锁或其他并发安全的数据结构，比如<code>sync.Map</code>。</p><h3 id="1-13-Golang中函数返回局部变量的指针是否安全？"><a href="#1-13-Golang中函数返回局部变量的指针是否安全？" class="headerlink" title="1.13 Golang中函数返回局部变量的指针是否安全？"></a>1.13 Golang中函数返回局部变量的指针是否安全？</h3><p>在 Go 语言中，函数返回局部变量的指针是安全的。这是因为 Go 具有<strong>智能的内存管理和逃逸分析机制</strong>，它确保在返回指针或引用时，指向的变量不会在返回后被释放或无效。</p><p>局部变量指针的逃逸分析<br>当函数返回局部变量的指针时，Go 的编译器会执行逃逸分析。逃逸分析的目的是确定变量的生命周期。如果一个局部变量的地址被返回给外部，它的内存将不会分配在栈上，而是分配在堆上，这样即使函数结束，该变量也不会被销毁。</p><blockquote><p>逃逸分析（Escape Analysis）是一种在<code>编译阶段</code>进行的静态分析技术，用于确定程序中变量的作用域和生命周期，特别是判断变量是保留在栈上还是堆上。通过逃逸分析，编译器可以决定变量在程序执行过程中是否需要逃逸到堆上分配，从而影响内存分配和垃圾收集的效率。<br>如果变量在函数或代码块内的生命周期结束后仍可能被引用，则这个变量需要在堆上分配，确保它在函数返回后仍然有效。这种情况称为<code>逃逸到堆</code>。如果变量只在当前函数或代码块内使用，不会被外部引用，则可以在栈上分配。这样做更高效，因为栈分配和释放的成本较低。<br>可以使用 go build -gcflags “-m” 来查看 Go 编译器的逃逸分析结果。这个命令会显示哪些变量逃逸到堆上，以及编译器对变量内存分配的决策过程。这对于理解编译器的内存管理策略以及优化代码性能非常有帮助。</p></blockquote><p><strong>小心内存泄漏</strong><br>虽然返回局部变量的指针是安全的，但需要注意的是，如果不适当地管理指针，可能导致内存泄漏。例如，当指针引用了一个很大的数据块，并且这个数据块不再需要时，没有将指针设置为 nil 或让它超出作用域，可能导致内存没有被释放。这可能会造成程序消耗大量的内存资源。</p><h3 id="1-14-Golang中两个-nil-可能不相等吗？"><a href="#1-14-Golang中两个-nil-可能不相等吗？" class="headerlink" title="1.14 Golang中两个 nil 可能不相等吗？"></a>1.14 Golang中两个 nil 可能不相等吗？</h3><p>在 Go 语言中，通常情况下，两个 nil 是相等的。但在接口比较时，如果<strong>接口的静态类型不同</strong>，即使动态值都是 nil，它们也可能不相等。理解这个特性对于接口编程和处理多态性非常重要。</p><h3 id="1-15-Golang的切片作为函数参数是值传递还是引用传递？"><a href="#1-15-Golang的切片作为函数参数是值传递还是引用传递？" class="headerlink" title="1.15 Golang的切片作为函数参数是值传递还是引用传递？"></a>1.15 Golang的切片作为函数参数是值传递还是引用传递？</h3><p>在 Go 中，切片作为函数参数是值传递的，但由于切片内部结构的特性，这种传递行为类似于引用传递。<strong>切片的长度和容量是值传递的部分</strong>，而<strong>指向底层数组的指针是共享的</strong>。因此，切片作为参数传递时，改变其内容可能影响原始切片。</p><h3 id="1-16-Golang中哪些不能作为map类型的key？"><a href="#1-16-Golang中哪些不能作为map类型的key？" class="headerlink" title="1.16 Golang中哪些不能作为map类型的key？"></a>1.16 Golang中哪些不能作为map类型的key？</h3><p>在 Go 中，map 的键必须是可比较的，因此<code>切片</code>、<code>映射</code>、<code>函数</code>等不可比较的类型不能用作 map 键。可作为 map 键的类型包括基础类型、数组、结构体（所有字段可比较）、指针等。理解这一点可以避免在使用 map 时遇到编译错误。</p><h3 id="1-17-Golang中nil-map-和空-map-有何不同？"><a href="#1-17-Golang中nil-map-和空-map-有何不同？" class="headerlink" title="1.17 Golang中nil map 和空 map 有何不同？"></a>1.17 Golang中nil map 和空 map 有何不同？</h3><p>nil map 和 空 map 的主要区别在于，nil map 未初始化，不能添加或修改元素，而空 map 已初始化，可以进行添加、修改和删除操作。在实际应用中，应根据需求来选择适当的 map 类型。</p><h3 id="1-18-Golang的Map中删除一个-key，它的内存会释放么？"><a href="#1-18-Golang的Map中删除一个-key，它的内存会释放么？" class="headerlink" title="1.18 Golang的Map中删除一个 key，它的内存会释放么？"></a>1.18 Golang的Map中删除一个 key，它的内存会释放么？</h3><p>在 Go 语言中，当您从 map 中删除一个键时，map 的内存管理是自动处理的，但删除键并不一定会立即释放相应的内存。以下是关于 Go 中 map 删除键和内存管理的详细解释。</p><h3 id="1-19-Golang-调用函数传入结构体时，应该传值还是指针？"><a href="#1-19-Golang-调用函数传入结构体时，应该传值还是指针？" class="headerlink" title="1.19 Golang 调用函数传入结构体时，应该传值还是指针？"></a>1.19 Golang 调用函数传入结构体时，应该传值还是指针？</h3><p>传递结构体到函数时，传值和传指针都有各自的用例。了解具体需求，综合考虑性能和数据一致性，是选择传值还是传指针的关键。</p><h3 id="1-20-哪些数据结构默认引用传递？"><a href="#1-20-哪些数据结构默认引用传递？" class="headerlink" title="1.20 哪些数据结构默认引用传递？"></a>1.20 哪些数据结构默认引用传递？</h3><p>切片、Map、通道、函数等数据类型是默认以引用传递的。</p><h3 id="1-21-Golang-中解析-tag-是怎么实现的？"><a href="#1-21-Golang-中解析-tag-是怎么实现的？" class="headerlink" title="1.21 Golang 中解析 tag 是怎么实现的？"></a>1.21 Golang 中解析 tag 是怎么实现的？</h3><pre><code class="go">type Person struct &#123;    Name string `json:&quot;name&quot;` // 使用标签指定 JSON 字段名称    Age  int    `json:&quot;age&quot;`&#125;</code></pre><p>在 Go 语言中，标签提供了一种在结构体字段上存储元数据的方法，可以通过<strong>反射</strong>在运行时解析这些标签。使用反射可以获取结构体的字段信息，并根据需要提取和解析标签内容。这种机制在 Go 中非常有用，特别是在需要自定义序列化&#x2F;反序列化、验证或其他基于元数据的操作时。</p><h3 id="1-22-Golang-sync-Map-的用法？"><a href="#1-22-Golang-sync-Map-的用法？" class="headerlink" title="1.22 Golang sync.Map 的用法？"></a>1.22 Golang sync.Map 的用法？</h3><p>无需显式初始化，可以直接声明并使用<br>Store Load Delete</p><h3 id="1-23-Go的Struct能不能⽐较？"><a href="#1-23-Go的Struct能不能⽐较？" class="headerlink" title="1.23 Go的Struct能不能⽐较？"></a>1.23 Go的Struct能不能⽐较？</h3><p>在 Go 语言中，结构体可以比较，但前提是所有字段都必须是可比较的类型。</p><ul><li>对于可比较的结构体，可以使用 &#x3D;&#x3D; 和 !&#x3D; 操作符直接比较。</li><li>对于不可比较的结构体，可能需要自定义比较逻辑或确保结构体字段都是可比较的类型。</li></ul><h3 id="1-24-解释Go语言什么是负载因子"><a href="#1-24-解释Go语言什么是负载因子" class="headerlink" title="1.24 解释Go语言什么是负载因子?"></a>1.24 解释Go语言什么是负载因子?</h3><p>负载因子是哈希表中存储的元素数量与哈希表中可用存储位置数量之比。通常用公式来表示：</p><pre><code>负载因子=哈希表中的元素数量/哈希表的容量 </code></pre><p>在 Go 中，哈希表的主要应用之一是 map。当创建 map 时，通常指定初始容量。随着元素的添加，哈希表会根据负载因子进行自动扩容或调整。</p><p>负载因子的作用<br>负载因子用于衡量哈希表的效率和性能。负载因子影响以下几个方面：</p><ul><li>查找性能：  <ul><li>负载因子越低，哈希表的冲突越少，查找性能越高。</li><li>负载因子越高，可能导致哈希表中的冲突增加，查找性能下降。</li></ul></li><li>空间效率：  <ul><li>负载因子较低时，哈希表可能浪费大量空间，因为许多存储位置未被使用。</li><li>负载因子较高时，哈希表利用率更高，但可能增加冲突和查找时间。</li></ul></li><li>自动扩容：  <ul><li>当负载因子超过特定阈值时，哈希表可能自动扩容。扩容时，哈希表会增加容量，并将现有元素重新分配到新的存储位置。这可以减少冲突并提高查找性能。</li></ul></li></ul><h3 id="1-25-unsafe-Pointer"><a href="#1-25-unsafe-Pointer" class="headerlink" title="1.25 unsafe.Pointer"></a>1.25 unsafe.Pointer</h3><ul><li>通用指针：unsafe.Pointer 是一种特殊的非类型化指针，用于与 Go 的类型安全系统交互。它可以转换为其他类型的指针，也可以从其他指针类型转换过来。</li><li>内存操作：unsafe.Pointer 通常用于与底层内存操作相关的场景，允许绕过 Go 的类型系统。</li><li>强制转换：unsafe.Pointer 允许指针之间的强制转换，但这样的操作需要谨慎，因为它绕过了类型安全。</li></ul><h3 id="1-26-简述Golang空结构体-struct-的使用"><a href="#1-26-简述Golang空结构体-struct-的使用" class="headerlink" title="1.26 简述Golang空结构体 struct{} 的使用"></a>1.26 简述Golang空结构体 struct{} 的使用</h3><p>在 Go 语言中，空结构体 struct{} 是一种非常轻量级的结构体，没有字段和方法。虽然看似没有功能，但它有几个有用的用途，通常与节省内存、信号传递、标签等相关。以下是空结构体在 Go 中的常见使用场景和用途：</p><ol><li><p>内存优化<br>空结构体不占用额外的内存空间。在 Go 中，空结构体实例的大小通常为零字节，因为它没有字段。这使得空结构体在需要存储标志或标记的场景中非常有用。</p></li><li><p>用作集合中的值<br>在 Go 中，映射（map）通常用于实现集合（Set）。使用空结构体作为映射的值可以有效地创建一个不重复的键集合，而不会浪费额外的内存。</p></li></ol><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    set := make(map[string]struct&#123;&#125;) // 使用空结构体作为值，创建一个集合    set[&quot;apple&quot;] = struct&#123;&#125;&#123;&#125;        // 添加元素    set[&quot;banana&quot;] = struct&#123;&#125;&#123;&#125;        if _, exists := set[&quot;apple&quot;]; exists &#123;        fmt.Println(&quot;Apple is in the set&quot;) // 检查集合中是否存在元素    &#125;&#125;</code></pre><p>在这个例子中，map[string]struct{} 表示一个字符串集合，使用空结构体作为值。这样做比使用其他非空值更节省内存。</p><ol start="3"><li>通道通信<br>空结构体常用于通道传递信号。这通常用于 Goroutine 之间的同步，不需要额外的数据信息。</li></ol><pre><code class="go">package mainimport &quot;fmt&quot;func main() &#123;    done := make(chan struct&#123;&#125;) // 使用空结构体通道    go func() &#123;        // 做一些工作        fmt.Println(&quot;Goroutine started&quot;)        done &lt;- struct&#123;&#125;&#123;&#125; // 发送完成信号    &#125;()    &lt;-done // 接收完成信号    fmt.Println(&quot;Main goroutine resumed&quot;)&#125;</code></pre><p>在这个例子中，chan struct{} 用于 Goroutine 之间的同步。空结构体作为信号传递，不需要携带额外的信息。</p><p>1.3 用作占位符<br>空结构体也可以用于占位符或标记。在某些设计中，这可能用于标记特定的状态或属性，而无需存储额外数据。</p><pre><code class="go">package mainimport &quot;fmt&quot;// 用作状态标记type State struct &#123;    isCompleted struct&#123;&#125; // 标记完成状态&#125;func main() &#123;    s := State&#123;&#125;    s.isCompleted = struct&#123;&#125;&#123;&#125; // 标记为已完成    fmt.Println(&quot;State is completed:&quot;, s.isCompleted != struct&#123;&#125;&#123;&#125;)&#125;</code></pre><p>在这个例子中，空结构体作为标记，表明某个状态已完成。</p><h3 id="1-27-string-类型的值可以修改吗？"><a href="#1-27-string-类型的值可以修改吗？" class="headerlink" title="1.27 string 类型的值可以修改吗？"></a>1.27 string 类型的值可以修改吗？</h3><p>在 Go 语言中，string 类型是不可变的，一旦创建，不能直接修改内容。如果需要更改字符串的内容，通常需要创建一个新的字符串。可以通过字符串拼接、子串操作、转换为字节切片等方式来创建新的字符串。理解字符串的不可变性有助于避免在 Go 中使用字符串时出现意外行为。</p><h3 id="1-28-Switch-中如何强制执行下一个-case-代码块？"><a href="#1-28-Switch-中如何强制执行下一个-case-代码块？" class="headerlink" title="1.28 Switch 中如何强制执行下一个 case 代码块？"></a>1.28 Switch 中如何强制执行下一个 case 代码块？</h3><p>Go 语言中的<code>fallthrough</code>关键字用于强制执行 switch 语句中的下一个 case。它可以在某些情况下实现类似 C 或 Java 中的 “fallthrough” 行为，但只支持无条件跳转。这意味着一旦使用 fallthrough，会立即跳转到下一个 case。</p><h3 id="1-29-解析-JSON-数据时，默认将数值当做哪种类型？"><a href="#1-29-解析-JSON-数据时，默认将数值当做哪种类型？" class="headerlink" title="1.29 解析 JSON 数据时，默认将数值当做哪种类型？"></a>1.29 解析 JSON 数据时，默认将数值当做哪种类型？</h3><p>在 Go 语言中，解析 JSON 数据时，默认情况下，数值被视为<code>float64</code>类型。这是因为 JSON 格式的数值可以包含整数和浮点数，而 float64 可以兼容这些情况。</p><h3 id="1-30-如何从-panic-中恢复？"><a href="#1-30-如何从-panic-中恢复？" class="headerlink" title="1.30 如何从 panic 中恢复？"></a>1.30 如何从 panic 中恢复？</h3><p>recover 是 Go 的内建函数，用于从 panic 中恢复。recover 只能在 defer 函数中使用，它允许您处理 panic 并继续执行其他代码。</p><p>关键点</p><ul><li><p>只能在 defer 中使用：recover 只有在 defer 函数中调用时才有效。如果在非 defer 的上下文中调用，它返回 nil 并不起作用。</p></li><li><p>用于从 panic 中恢复：当 panic 发生时，Go 会沿堆栈向上寻找 defer 语句。如果找到一个包含 recover 的 defer，它会调用 recover 并停止堆栈展开。</p></li><li><p>继续执行：在调用 recover 并成功捕获 panic 后，程序会继续执行 defer 后的代码，而不是继续展开堆栈。</p></li></ul><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;errors&quot;)func main() &#123;    defer func() &#123;        if r := recover(); r != nil &#123;            fmt.Println(&quot;Recovered from panic:&quot;, r) // 恢复并打印 panic 信息        &#125;    &#125;()    fmt.Println(&quot;Start&quot;)    panic(errors.New(&quot;Something went wrong&quot;)) // 触发 panic    fmt.Println(&quot;This line won&#39;t execute&quot;)   // 因为发生了 panic&#125;</code></pre><p>在这个例子中，panic 发生时，defer 中的 recover 成功捕获 panic，然后继续执行其他代码。输出将是：</p><pre><code class="go">StartRecovered from panic: Something went wrong</code></pre><h3 id="1-31-阐述-Printf-、Sprintf-、Fprintf-函数的区别用法是什么？"><a href="#1-31-阐述-Printf-、Sprintf-、Fprintf-函数的区别用法是什么？" class="headerlink" title="1.31 阐述 Printf()、Sprintf()、Fprintf()函数的区别用法是什么？"></a>1.31 阐述 Printf()、Sprintf()、Fprintf()函数的区别用法是什么？</h3><ul><li>Printf() 用于将格式化的字符串输出到标准输出，通常是控制台。</li><li>Sprintf() 返回格式化后的字符串，而不是直接输出，适合需要保存或进一步处理的场景。</li><li><strong>Fprintf()</strong> 将格式化的字符串输出到指定的 Writer，如文件、网络连接、缓冲区等，适用于需要定制输出目的地的场景。</li></ul><h3 id="1-32-类型断言"><a href="#1-32-类型断言" class="headerlink" title="1.32 类型断言"></a>1.32 类型断言</h3><p>在 Go 语言中，类型断言是一种将接口值转换为特定类型的机制。它可以用于安全地检查接口的具体类型，并在需要时将其转换为具体类型。</p><pre><code class="go">func main() &#123;    var x interface&#123;&#125; = 42 // 接口值    s, ok := x.(string)   // 断言为 string 类型    if ok &#123;        fmt.Println(&quot;String:&quot;, s)    &#125; else &#123;        fmt.Println(&quot;Not a string&quot;) // 输出: Not a string    &#125;&#125;</code></pre><h3 id="1-33-静态类型声明的好处"><a href="#1-33-静态类型声明的好处" class="headerlink" title="1.33 静态类型声明的好处"></a>1.33 静态类型声明的好处</h3><pre><code class="go">var x int = 42 // 显式声明类型为 int</code></pre><ul><li>类型安全：编译时检查类型，减少运行时错误。</li><li>性能优化：因为类型在编译时确定，编译器可以进行更多优化。</li><li>代码可读性：明确的类型声明提高了代码的可读性和可维护性。</li></ul><h3 id="1-34-可变参数"><a href="#1-34-可变参数" class="headerlink" title="1.34 可变参数"></a>1.34 可变参数</h3><pre><code class="go">// 定义一个可变参数的函数func sum(nums ...int) int &#123;    total := 0    for _, num := range nums &#123;        total += num // 累加所有参数    &#125;    return total&#125;</code></pre><ul><li>可变参数的位置：在参数列表中，可变参数必须是最后一个参数，因为它会接收所有剩余的参数。</li><li>使用切片展开：当使用切片作为可变参数时，需要使用 … 将切片展开。</li><li>可变参数的类型：在定义可变参数时，需要指定其类型。例如，…int 表示可变数量的整数。</li><li>避免混淆：在函数接受多种类型的参数时，确保可变参数的位置和传递方式不会引起混淆。</li></ul><h3 id="1-35-Golang导入包时，为什么可能使用-或-导入-举例说明"><a href="#1-35-Golang导入包时，为什么可能使用-或-导入-举例说明" class="headerlink" title="1.35 Golang导入包时，为什么可能使用_ 或 .导入? 举例说明"></a>1.35 Golang导入包时，为什么可能使用<code>_</code> 或 <code>.</code>导入? 举例说明</h3><ul><li><p>使用 ‘_’ 导入时，表示只导入包以执行其初始化代码，而不使用该包中的任何标识符。这样做的主要目的是<strong>触发包的 init() 函数或其他初始化行为，而不需要使用包的具体内容</strong>。</p></li><li><p>使用 ‘.’ 导入时，表示将包中的标识符直接引入当前命名空间。这意味着可以使用包中的标识符，而不需要通过包名进行引用。这种导入方式被认为是不好的实践，因为它可能导致命名冲突或代码可读性下降。</p></li></ul><h3 id="1-36-Golang中的接口类型是否支持像Java那样的多继承？"><a href="#1-36-Golang中的接口类型是否支持像Java那样的多继承？" class="headerlink" title="1.36 Golang中的接口类型是否支持像Java那样的多继承？"></a>1.36 Golang中的接口类型是否支持像Java那样的多继承？</h3><p>在 Go 语言中，接口类型不支持像 Java 或 C++ 那样的多继承概念。Java 中的多继承通常指的是类可以继承多个其他类，或者接口可以继承多个其他接口。在 Go 中，虽然没有类的概念，但接口可以嵌入其他接口，这是一种类似多继承的机制，但并不完全相同。</p><p><strong>接口嵌入示例</strong></p><pre><code class="go">package mainimport &quot;fmt&quot;// 定义两个简单的接口type Speaker interface &#123;    Speak() string&#125;type Walker interface &#123;    Walk() string&#125;// 定义一个嵌入其他接口的接口type Person interface &#123;    Speaker    Walker&#125;// 定义一个结构体，实现嵌入接口type Human struct&#123;&#125;func (h Human) Speak() string &#123;    return &quot;I am speaking&quot;&#125;func (h Human) Walk() string &#123;    return &quot;I am walking&quot;&#125;func main() &#123;    var p Person = Human&#123;&#125;    fmt.Println(p.Speak()) // 输出: &quot;I am speaking&quot;    fmt.Println(p.Walk())  // 输出: &quot;I am walking&quot;&#125;</code></pre><h3 id="1-37-Golang中的sync包是什么？如何使用？"><a href="#1-37-Golang中的sync包是什么？如何使用？" class="headerlink" title="1.37 Golang中的sync包是什么？如何使用？"></a>1.37 Golang中的sync包是什么？如何使用？</h3><p>sync 包提供了 Go 语言中常用的同步原语，用于确保并发环境中的线程安全和数据一致性。<br>常用的有：</p><ul><li>互斥锁（Mutex）</li><li>读写锁（RWMutex）</li><li>等待组（WaitGroup）</li><li>Map</li></ul><h3 id="1-38-Go-调度器-MPG模型"><a href="#1-38-Go-调度器-MPG模型" class="headerlink" title="1.38 Go 调度器 MPG模型"></a>1.38 Go 调度器 MPG模型</h3><p>多对一 动态变化</p><p>Go 调度器由以下核心组件组成：</p><ul><li>M：代表操作系统线程（OS Thread），用于运行 Goroutine。</li><li>P：代表处理器（Processor），控制 Goroutine 的执行。每个 P 绑定一个操作系统线程 M，负责调度 Goroutine 的执行。</li><li>G：代表 Goroutine，是 Go 的并发单元。<br><img src="/2024/05/04/Golang%E5%85%AB%E8%82%A1%E6%96%87/MPG.png"></li></ul><h3 id="1-39-CSP模型"><a href="#1-39-CSP模型" class="headerlink" title="1.39 CSP模型"></a>1.39 CSP模型</h3><p><strong>管道通信</strong> 实现并发同步Communicating Sequential Process</p><p>严格来说，CSP 是一门形式语言（类似于 ℷ calculus），用于描述并发系统中的互动模式，也因此成为一众面向并发的编程语言的理论源头，并衍生出了 Occam&#x2F;Limbo&#x2F;Golang…<br>而具体到编程语言，如Golang，其实只用到了 CSP 的很小一部分，即理论中的 Process&#x2F;Channel（对应到语言中的 goroutine&#x2F;channel）：这两个并发原语之间没有从属关系， Process 可以订阅任意个 Channel，Channel 也并不关心是哪个 Process 在利用它进行通信；Process 围绕 Channel 进行读写，形成一套有序阻塞和可预测的并发模型。</p><h3 id="1-40-简述Go-语言中-cap-函数可以作用于那些内容？"><a href="#1-40-简述Go-语言中-cap-函数可以作用于那些内容？" class="headerlink" title="1.40 简述Go 语言中 cap 函数可以作用于那些内容？"></a>1.40 简述Go 语言中 cap 函数可以作用于那些内容？</h3><p>在 Go 语言中，cap 函数可以作用于<code>切片</code>、<code>数组</code>和<code>通道</code>，返回它们的容量。容量是数据结构在扩展前可以容纳的最大元素数量。</p><ul><li>对于切片，容量可以大于其长度；</li><li>对于数组，容量与长度相同；</li><li>对于通道，容量是通道的缓冲区大小。</li></ul><h3 id="1-41-简述go-convey-是什么？一般用来做什么？"><a href="#1-41-简述go-convey-是什么？一般用来做什么？" class="headerlink" title="1.41 简述go convey 是什么？一般用来做什么？"></a>1.41 简述go convey 是什么？一般用来做什么？</h3><p>GoConvey 是 Go 语言中的一个用于编写和执行单元测试的测试框架。与标准的 Go 测试库相比，GoConvey 提供了一种更直观和简洁的方式来编写测试，并支持行为驱动开发（BDD）的风格。它提供了用于组织和描述测试的工具，以及内置的测试服务器来展示测试结果。</p><h3 id="1-42-闭包"><a href="#1-42-闭包" class="headerlink" title="1.42 闭包"></a>1.42 闭包</h3><p>在 Go 中，闭包主要体现在匿名函数中。匿名函数可以捕获其外部作用域中的变量，并在不同的上下文中保留这些变量的状态。</p><p>示例：简单闭包</p><pre><code class="go">func main() &#123;    // 定义一个变量    x := 10        // 定义一个闭包，捕获 x    increment := func() int &#123;        x++ // 增加 x 的值        return x    &#125;    // 每次调用闭包，x 都会增加    fmt.Println(increment()) // 输出: 11    fmt.Println(increment()) // 输出: 12    fmt.Println(increment()) // 输出: 13&#125;</code></pre><ul><li><p>闭包的特点</p><ul><li><p>捕获环境变量：闭包可以捕获其创建时的外部作用域中的变量，并在不同的上下文中使用这些变量。</p></li><li><p>状态保持：闭包可以保持变量的状态，这在某些情况下非常有用，如计数器、累加器等。</p></li><li><p>匿名函数：闭包通常通过匿名函数实现，但不一定是匿名函数。关键是捕获变量的作用域。</p></li></ul></li><li><p>闭包的应用场景<br>闭包在 Go 中有多种应用场景，包括但不限于：</p><ul><li><p>计数器：使用闭包实现计数器，每次调用闭包时增加计数。</p></li><li><p>延迟计算：闭包可以用于延迟计算，在需要时再执行。</p></li><li><p>函数作为参数：闭包可以作为参数传递给其他函数，提供更灵活的行为。</p></li></ul></li><li><p>闭包的注意事项</p><ul><li><p>变量作用域：闭包捕获的变量是外部作用域中的变量，因此在多 Goroutine 场景中要小心变量的共享状态。</p></li><li><p>内存管理：闭包会保留捕获的变量，如果变量过多或生命周期过长，可能会增加内存使用。</p></li><li><p>闭包的副作用：由于闭包可以改变外部变量的状态，因此在使用闭包时要注意可能的副作用。</p></li></ul></li></ul><h2 id="二、Go机制原理"><a href="#二、Go机制原理" class="headerlink" title="二、Go机制原理"></a>二、Go机制原理</h2><h3 id="2-1-Golang-uint-类型溢出问题？"><a href="#2-1-Golang-uint-类型溢出问题？" class="headerlink" title="2.1 Golang uint 类型溢出问题？"></a>2.1 Golang uint 类型溢出问题？</h3><p>在 Go 语言中，uint 类型溢出是无符号整数的固有问题。当无符号整数的值超过其最大值时，它会绕回最小值。理解溢出问题的原因和解决方法有助于在 Go 中编写健壮且安全的代码。防止溢出需要显式检查、使用大容量类型和错误处理等方法。</p><pre><code class="go">func safeAdd(a, b uint8) (uint8, error) &#123;    if a &gt; 255-b &#123;        return 0, errors.New(&quot;Overflow occurred&quot;)    &#125;    return a + b, nil&#125;func main() &#123;    result, err := safeAdd(250, 10)    if err != nil &#123;        fmt.Println(&quot;Error:&quot;, err) // 输出: &quot;Overflow occurred&quot;    &#125; else &#123;        fmt.Println(&quot;Result:&quot;, result)    &#125;&#125;</code></pre><h3 id="2-2-Golang中什么是协程泄露-Goroutine-Leak-？"><a href="#2-2-Golang中什么是协程泄露-Goroutine-Leak-？" class="headerlink" title="2.2 Golang中什么是协程泄露(Goroutine Leak)？"></a>2.2 Golang中什么是协程泄露(Goroutine Leak)？</h3><p>Goroutine 泄露是指 Goroutine 未按预期结束而持续运行，占用系统资源。防止 Goroutine 泄露需要:</p><ul><li>确保 Goroutine 正常结束</li><li>使用 context 包实现超时取消</li><li>正确处理通道操作（close(ch)）等</li></ul><h3 id="2-3-Go-语言的局部变量分配在栈上还是堆上？"><a href="#2-3-Go-语言的局部变量分配在栈上还是堆上？" class="headerlink" title="2.3 Go 语言的局部变量分配在栈上还是堆上？"></a>2.3 Go 语言的局部变量分配在栈上还是堆上？</h3><p>Go 语言中的局部变量分配在栈上还是堆上取决于逃逸分析。如果变量在函数返回后没有外部引用，编译器通常会将其分配到栈上。如果变量可能在函数返回后仍然被引用，编译器会将其分配到堆上。</p><h3 id="2-4-阐述-Go-的-select-的特性？"><a href="#2-4-阐述-Go-的-select-的特性？" class="headerlink" title="2.4 阐述 Go 的 select 的特性？"></a>2.4 阐述 Go 的 select 的特性？</h3><ul><li>多通道选择：select 可以监控多个通道，并根据通道的状态进行选择。Go 运行时会监控这些通道的状态，确保选择操作的正确性。</li><li>等待队列：每个通道都有一个等待队列，当 Goroutine 执行 select 时，它会被添加到等待队列中。运行时会确保当通道变得可用时，正确唤醒等待队列中的 Goroutine。</li><li><strong>随机选择</strong>：如果 select 中有多个通道可用，Go 运行时会随机选择一个进行操作。这种随机选择确保 select 操作的公平性，避免通道的偏向和不平衡。</li></ul><h3 id="2-5-Golang字符串转成byte数组，会发生内存拷贝吗？"><a href="#2-5-Golang字符串转成byte数组，会发生内存拷贝吗？" class="headerlink" title="2.5 Golang字符串转成byte数组，会发生内存拷贝吗？"></a>2.5 Golang字符串转成byte数组，会发生内存拷贝吗？</h3><p>在 Go 语言中，将字符串转换为字节数组（[]byte）<strong>会发生内存拷贝</strong>。这意味着一个新的字节数组会被创建，其中包含与原始字符串相同的数据。这种内存拷贝在转换过程中是必然的，<strong>因为字符串在 Go 中是不可变的，而字节数组是可变的</strong>。</p><h3 id="2-6-对已经关闭的的chan进行读写，会怎么样？为什么？"><a href="#2-6-对已经关闭的的chan进行读写，会怎么样？为什么？" class="headerlink" title="2.6 对已经关闭的的chan进行读写，会怎么样？为什么？"></a>2.6 对已经关闭的的chan进行读写，会怎么样？为什么？</h3><ul><li>读取一个已经关闭的通道：  <ul><li>当你从一个关闭的通道中读取数据时，如果通道里有剩余的数据，你会读取到这些数据。</li><li>如果通道已经没有数据了，读取操作会立即返回零值，并且通道的第二个返回值将是 false，表示通道已关闭。例如，读取一个 chan int 类型的通道，如果通道为空且已关闭，你会得到 0 和 false。</li></ul></li></ul><p><strong>读取一个关闭的通道是安全的，也不会引发 panic。</strong></p><ul><li>写入一个已经关闭的通道:<ul><li>当你尝试写入一个已经关闭的通道时，会引发 panic。这是因为在关闭后，通道不再接受任何新的数据。</li><li>因此，在写入通道之前，务必确认通道没有被关闭。这可以通过同步机制来确保，或者通过捕获 panic 进行错误处理。</li></ul></li></ul><h3 id="2-7-Golang的内存模型中为什么⼩对象多了会造成GC压⼒？如何解决？"><a href="#2-7-Golang的内存模型中为什么⼩对象多了会造成GC压⼒？如何解决？" class="headerlink" title="2.7 Golang的内存模型中为什么⼩对象多了会造成GC压⼒？如何解决？"></a>2.7 Golang的内存模型中为什么⼩对象多了会造成GC压⼒？如何解决？</h3><p>在 Golang 中，小对象的数量增多会导致垃圾回收（GC）压力增加。主要原因包括以下几点：</p><ol><li><p>对象的创建与销毁<br>每个对象的创建和销毁都会产生管理成本。当大量小对象被创建和销毁时，垃圾回收器需要处理更多的对象，这意味着更频繁的垃圾回收过程。</p></li><li><p>垃圾回收的工作<br>垃圾回收器的主要任务是清理不再需要的内存。Go 的垃圾回收器使用一种标记-清除的算法，在每次垃圾回收过程中，垃圾回收器需要：</p><ul><li><strong>标记：遍历整个堆，标记所有存活的对象。</strong></li><li><strong>清除：释放未标记的内存。</strong></li></ul><p> 当有大量小对象时，标记和清除的过程会更频繁且成本更高，因为垃圾回收器需要处理更多的对象并跟踪更多的引用。</p></li><li><p>增加的堆碎片<br>大量小对象的创建和销毁可能导致堆内存的碎片化。碎片化增加了内存的非连续性，导致垃圾回收器在清除内存时更难以找到可以合并的大块空闲内存。碎片化通常需要更多的 GC 迭代来保持堆的效率。</p></li><li><p>并发与暂停时间<br>Go 的垃圾回收器设计为并发运行，但在某些阶段需要短暂暂停整个程序。例如，在标记阶段，垃圾回收器需要确保堆上的对象不再改变，导致某些暂停。当小对象很多时，标记阶段可能需要更长时间，增加了程序的暂停时间。</p></li><li><p>高速对象分配<br>当程序频繁分配和释放小对象时，这些操作会在堆上产生较多的压力。较频繁的分配操作可能导致堆的快速增长，而这反过来会触发更多的垃圾回收周期。</p></li></ol><p>缓解 GC 压力的策略</p><ul><li>对象重用：尽可能重用对象，避免频繁的创建和销毁。</li><li>减少对象分配：避免过多的小对象分配，考虑使用缓冲池或临时缓存。</li><li>优化垃圾回收：根据需要调整 GC 的参数，如 GOGC，以减少垃圾回收的频率。</li></ul><h3 id="2-8-Golang-的-GC的触发条件？"><a href="#2-8-Golang-的-GC的触发条件？" class="headerlink" title="2.8 Golang 的 GC的触发条件？"></a>2.8 Golang 的 GC的触发条件？</h3><p>Go 的垃圾回收器是自适应的，会根据<code>程序的运行情况</code>、<code>堆的大小和存活率</code>等多种因素自动调整触发条件。这种机制确保了 GC 在保持高效垃圾回收的同时，尽量减少对程序性能的影响。</p><h3 id="2-9-Go中的锁有哪些-？"><a href="#2-9-Go中的锁有哪些-？" class="headerlink" title="2.9 Go中的锁有哪些 ？"></a>2.9 Go中的锁有哪些 ？</h3><ol><li>互斥锁</li><li>读写锁</li><li>一次性锁（Once）<br>sync.Once<br>Once 确保某段代码只会执行一次，通常用于初始化操作或单例模式。<br>使用 Do() 方法，传入要执行的函数，保证该函数只会被执行一次。<pre><code class="go">var once sync.Oncevar config map[string]stringfunc initializeConfig() &#123;    once.Do(func() &#123;        config = make(map[string]string)        // 初始化配置    &#125;)&#125;</code></pre></li><li>条件变量（Cond）<br>sync.Cond<br>条件变量用于实现基于条件的同步，允许 Goroutine 在某个条件满足时继续执行。<br>条件变量通常与 Mutex 结合使用，用于实现复杂的同步逻辑。<br>具有 Wait(), Signal(), 和 Broadcast() 等方法，用于控制等待和唤醒 Goroutine。<pre><code class="go">var mu sync.Mutexvar cond = sync.NewCond(&amp;mu)var ready = falsefunc worker() &#123;    mu.Lock()    defer mu.Unlock()        for !ready &#123;        cond.Wait() // 等待条件满足    &#125;        // 执行工作&#125;func setReady() &#123;    mu.Lock()    ready = true    cond.Signal() // 唤醒一个等待的 Goroutine    mu.Unlock()&#125;</code></pre></li><li>等待组（WaitGroup）<br>sync.WaitGroup<br>等待组用于等待一组 Goroutine 完成，可以用于同步 Goroutine 的结束。<br>使用 Add() 指定等待的 Goroutine 数量，Done() 表示一个 Goroutine 完成，Wait() 等待所有 Goroutine 完成。<pre><code class="go">var wg sync.WaitGroupfunc worker() &#123;    defer wg.Done() // 标记 Goroutine 完成    // 执行工作&#125;func main() &#123;    wg.Add(2) // 期望等待两个 Goroutine    go worker()    go worker()    wg.Wait() // 等待所有 Goroutine 完成&#125;</code></pre></li></ol><h3 id="2-10-Channel是同步的还是异步的？"><a href="#2-10-Channel是同步的还是异步的？" class="headerlink" title="2.10 Channel是同步的还是异步的？"></a>2.10 Channel是同步的还是异步的？</h3><p>Go 中的通道（Channel）可以是同步的，也可以是异步的，取决于通道的缓冲机制和容量设置。</p><h3 id="2-11-简述Goroutine和线程的区别？"><a href="#2-11-简述Goroutine和线程的区别？" class="headerlink" title="2.11 简述Goroutine和线程的区别？"></a>2.11 简述Goroutine和线程的区别？</h3><ol><li>轻量级 vs. 重量级<ul><li>Goroutine 是轻量级的<ul><li>Goroutine 是 Go 语言中的一种协程，它在启动和运行时的开销非常小。每个 Goroutine 只需几 KB 的初始内存，运行时能根据需要自动扩展和收缩。</li></ul></li><li>线程是重量级的<ul><li>操作系统线程需要较大的内存和资源，通常启动一个线程需要几 MB 的内存，并且会消耗更多的操作系统资源。</li></ul></li></ul></li><li>调度模型<ul><li>Goroutine 使用用户态调度<ul><li>Go 运行时包含一个用户态的调度器，负责在多个操作系统线程上调度和运行 Goroutine。这个调度器可以更灵活地管理 Goroutine，并且不依赖操作系统的调度机制。</li></ul></li><li>线程使用内核态调度<ul><li>操作系统线程由内核调度，调度机制取决于操作系统。由于内核调度器的复杂性，线程的调度成本通常更高。</li></ul></li></ul></li><li>并发数量<ul><li>Goroutine 可以大量创建<ul><li>由于 Goroutine 的轻量级特性，Go 应用可以同时运行数以千计甚至数百万个 Goroutine，适合高度并发的应用场景。</li></ul></li><li>线程的数量受限<ul><li>线程由于其高开销和资源限制，无法像 Goroutine 那样大量创建。通常一个应用创建数百个线程就可能遇到性能和资源问题。</li></ul></li></ul></li><li>数据共享和通信<ul><li>Goroutine 倾向于使用通道进行通信<ul><li>Go 倡导 “不要通过共享内存来通信，而是通过通信来共享内存”。Goroutine 之间使用通道进行通信，这种机制有助于避免数据竞争。</li></ul></li><li>线程通常使用锁和共享内存<ul><li>线程之间经常通过共享内存和锁进行同步，这种方式更容易引发数据竞争和死锁等问题。</li></ul></li></ul></li><li>并行性与并发性<ul><li>Goroutine 适合并发<ul><li>Goroutine 的轻量级和用户态调度使其适合并发编程，特别是在 I&#x2F;O 密集型和高延迟操作中。</li></ul></li><li>线程适合并行<ul><li>线程的重量级特性和内核态调度使其适合 CPU 密集型任务，可以充分利用多核 CPU 的并行能力。</li></ul></li></ul></li><li>错误处理<ul><li>Goroutine 的错误隔离<ul><li>Goroutine 的错误不会影响其他 Goroutine。当一个 Goroutine 出现 panic 时，其他 Goroutine 可以继续运行。</li></ul></li><li>线程的错误影响<ul><li>当一个线程出错时，可能影响整个进程，尤其是在未捕获异常的情况下。</li></ul></li></ul></li></ol><h3 id="2-12-介绍下golang的atomic包"><a href="#2-12-介绍下golang的atomic包" class="headerlink" title="2.12 介绍下golang的atomic包"></a>2.12 介绍下golang的atomic包</h3><p>Golang 的 sync&#x2F;atomic 包提供了一组用于实现原子操作的工具，这些操作可以确保在并发环境中安全地更新和读取简单变量类型，而不需要使用互斥锁。原子操作可以在并发环境中避免数据竞争，是构建无锁数据结构和实现线程安全操作的关键工具。</p><ul><li><p>原子操作的作用</p><ul><li>原子操作确保某个操作在执行过程中不会被其他操作中断。这意味着在并发环境中，原子操作能够保证操作的完整性和一致性。sync&#x2F;atomic 包中的原子操作通常用于对简单数据类型的原子性更新、读取和比较。</li></ul></li><li><p>sync&#x2F;atomic 支持的原子操作</p><ol><li>原子性读取和写入</li></ol><ul><li>读取操作<ul><li>LoadInt32, LoadInt64, LoadUint32, LoadUint64, LoadPointer, LoadUintptr: 以原子方式读取变量的当前值。</li></ul></li><li>写入操作<ul><li>StoreInt32, StoreInt64, StoreUint32, StoreUint64, StorePointer, StoreUintptr: 以原子方式将值写入变量。</li></ul></li></ul><ol start="2"><li>原子性加法和减法</li></ol><ul><li>加法操作<ul><li>AddInt32, AddInt64, AddUint32, AddUint64: 以原子方式将变量增加特定值。</li></ul></li><li>减法操作<ul><li>AddInt32 等同于减负数，但没有显式减法操作。</li></ul></li></ul><ol start="3"><li>原子性比较和交换（CAS）</li></ol><ul><li>CompareAndSwapInt32, CompareAndSwapInt64, CompareAndSwapUint32, CompareAndSwapUint64, CompareAndSwapPointer: 以原子方式比较变量的当前值，如果等于期望值，则替换为新的值。</li></ul><ol start="4"><li>原子性交换</li></ol><ul><li>SwapInt32, SwapInt64, SwapUint32, SwapUint64, SwapPointer: 以原子方式将变量的值替换为新值，并返回旧值。</li></ul></li><li><p>使用 sync&#x2F;atomic 的场景</p><ul><li>无锁计数器: 使用 Add 或 CompareAndSwap 实现线程安全的计数器。</li><li>条件性更新: 使用 CAS 在特定条件下更新变量。</li><li>无锁数据结构: 构建无锁队列、堆栈等复杂数据结构。</li><li>原子性标志: 使用原子操作实现简单的标志变量，以避免数据竞争。</li></ul></li><li><p>sync&#x2F;atomic 的限制</p><ul><li>简单数据类型: sync&#x2F;atomic 仅支持简单的标量类型（如整数、指针、布尔等），不适用于复杂数据结构。</li><li>ABA 问题: CAS 操作可能导致 ABA 问题，需要额外处理。</li><li>高竞争环境: 在高竞争环境中，使用原子操作可能导致自旋和性能下降。</li></ul></li></ul><h3 id="2-13-简述Go中CAS算法？"><a href="#2-13-简述Go中CAS算法？" class="headerlink" title="2.13 简述Go中CAS算法？"></a>2.13 简述Go中CAS算法？</h3><p>CAS（Compare and Swap）算法是一种常用的原子操作算法，通常用于在多线程或并发环境中实现无锁操作。CAS 算法提供了一种确保原子性的方法，可以用于避免竞争条件和数据不一致的问题。Go 语言通过 sync&#x2F;atomic 包提供了对 CAS 操作的支持。</p><ol><li><p>CAS 算法的概念<br>CAS 是一种原子性操作，其核心思想是“比较并交换”。在 CAS 操作中，会对某个共享变量执行以下步骤：</p><ul><li>比较（Compare）：检查共享变量的当前值是否等于期望值。</li><li>交换（Swap）：如果当前值等于期望值，则将其更改为新的值。</li><li>如果当前值不等于期望值，操作失败，通常会返回当前的实际值。</li></ul><p> CAS 允许在并发环境中进行原子性的变量更新，而不使用传统的锁机制。</p></li><li><p>Go 中的 CAS 操作<br>Go 语言中的 sync&#x2F;atomic 包提供了多种 CAS 操作，用于对简单数据类型（如整数、布尔值、指针等）进行原子操作。主要操作包括：</p><ul><li>CompareAndSwapInt32, CompareAndSwapInt64：对 32 位和 64 位整数进行 CAS 操作。</li><li>CompareAndSwapUint32, CompareAndSwapUint64：对 32 位和 64 位无符号整数进行 CAS 操作。</li><li>CompareAndSwapPointer：对指针类型进行 CAS 操作。</li><li>CompareAndSwapUintptr：对 uintptr 类型进行 CAS 操作。</li></ul></li><li><p>CAS 的使用场景</p><ul><li>无锁计数器：通过 CAS 实现线程安全的计数器，而不使用锁。</li><li>锁的实现：一些锁的实现可以通过 CAS 操作来避免竞争条件。</li><li>原子变量更新：在多线程环境中，CAS 允许安全地更新共享变量。</li></ul></li><li><p>CAS 的优缺点</p><ul><li>优点<ul><li>无锁：CAS 不需要使用锁，避免了锁的开销和潜在的死锁问题。</li><li>高效：CAS 操作通常比锁更高效，因为它是原子性的，避免了上下文切换。</li></ul></li><li>缺点<ul><li>ABA 问题：CAS 中可能发生 ABA 问题，即变量经过多次变化后又恢复原值，但状态已改变。这个问题在某些场景下需要额外处理。</li><li>自旋：CAS 失败时，可能需要不断重试（自旋），在高竞争环境中可能导致性能问题。</li></ul></li></ul></li><li><p>CAS 的示例</p></li></ol><pre><code class="go">import (    &quot;sync/atomic&quot;)var counter int32func increment() &#123;    for &#123;        current := atomic.LoadInt32(&amp;counter) // 读取当前值        newValue := current + 1              // 计算新的值        if atomic.CompareAndSwapInt32(&amp;counter, current, newValue) &#123; // 尝试更新            break // 更新成功，退出循环        &#125;    &#125;&#125;</code></pre><p>在这个示例中，increment 函数尝试增加 counter，并通过 CAS 确保在多线程环境中是原子性的。</p><h3 id="2-14-Go函数中为什么会发⽣内存泄露？"><a href="#2-14-Go函数中为什么会发⽣内存泄露？" class="headerlink" title="2.14 Go函数中为什么会发⽣内存泄露？"></a>2.14 Go函数中为什么会发⽣内存泄露？</h3><p>在 Go 中，内存泄露可能由于以下原因导致：</p><ul><li>无意保留引用：对象的引用在程序中意外保留，垃圾回收器无法回收它们。</li><li>循环引用：多个对象相互引用，导致垃圾回收器无法释放它们。</li><li>未关闭的通道或 Goroutine：通道未关闭或 Goroutine 无法正常退出，导致资源被占用。</li><li>未关闭的文件或资源：文件、数据库连接等资源未关闭，导致泄露。</li><li>全局变量或缓存：全局变量或缓存中保留了不再使用的对象。</li></ul><h3 id="2-15-Golang协程为什么⽐线程轻量？"><a href="#2-15-Golang协程为什么⽐线程轻量？" class="headerlink" title="2.15 Golang协程为什么⽐线程轻量？"></a>2.15 Golang协程为什么⽐线程轻量？</h3><p>Golang 的协程（Goroutines）比传统的线程轻量，因为 Go 语言设计了独特的用户态调度器和灵活的栈管理机制，这使得 Goroutines 能在更低的资源消耗下高效运行。以下是 Goroutines 比线程轻量的主要原因：</p><ol><li><p>初始栈大小较小</p><ul><li>Goroutines 的初始栈大小通常只有几 KB，这与传统线程的栈大小相差甚远。传统线程的栈通常是固定大小，可能是 1 MB 或更大。较小的初始栈大小使得创建 Goroutines 的开销大大降低。</li></ul></li><li><p>动态栈扩展</p><ul><li>Go 的 Goroutines 支持栈的动态扩展和收缩。这意味着栈可以根据需要增长，而不会固定占用大量内存。动态栈扩展可以减少内存的浪费，并允许更多 Goroutines 在同一时刻运行。</li></ul></li><li><p>用户态调度</p><ul><li>Go 语言的调度器是用户态调度器，与操作系统的线程调度器不同。用户态调度器可以更高效地调度 Goroutines，而不需要进行系统调用或内核态的线程切换，这减少了上下文切换的成本。</li></ul></li><li><p>较少的系统资源消耗</p><ul><li>Goroutines 不需要为每个实例创建操作系统级别的线程，因此它们消耗的系统资源较少。传统线程需要操作系统资源，如文件描述符、内核栈、线程上下文等，这些资源开销较高。</li></ul></li><li><p>高效的 Goroutines 调度</p><ul><li>Go 运行时的调度器可以在多个操作系统线程上调度大量的 Goroutines。它采用 M:N 模型，意味着多个 Goroutines 可以共享少量的操作系统线程。这种调度方式更加灵活，减少了系统资源的消耗。</li></ul></li><li><p>Goroutines 的创建成本较低</p><ul><li>由于 Goroutines 的轻量级特性，它们的创建和销毁成本较低。<strong>传统线程的创建通常涉及操作系统的系统调用，而 Goroutines 可以在用户态完成，大大减少了创建成本</strong>。</li></ul></li><li><p>并发模型的简化</p><ul><li>Go 的并发模型通过 Goroutines 和通道提供了简化的通信机制。这种机制减少了传统线程模型中的复杂同步操作，如锁定、条件变量等，从而降低了 Goroutines 的管理成本。</li></ul></li></ol><h3 id="2-16-线程模型有哪些？为什么-Go-Scheduler-需要实现-M-N-的⽅案？Go-Scheduler-由哪些元-素构成呢？"><a href="#2-16-线程模型有哪些？为什么-Go-Scheduler-需要实现-M-N-的⽅案？Go-Scheduler-由哪些元-素构成呢？" class="headerlink" title="2.16 线程模型有哪些？为什么 Go Scheduler 需要实现 M:N 的⽅案？Go Scheduler 由哪些元 素构成呢？"></a>2.16 线程模型有哪些？为什么 Go Scheduler 需要实现 M:N 的⽅案？Go Scheduler 由哪些元 素构成呢？</h3><p>线程模型描述了如何在操作系统或语言运行时中管理线程或协程。不同的线程模型在调度、资源利用和性能方面具有不同的特点。常见的线程模型包括：</p><ol><li>1:1 线程模型<ul><li>定义：每个用户线程映射到一个操作系统线程。</li><li>优点：操作系统调度器直接管理线程，调度可靠，集成了操作系统的多线程特性。</li><li>缺点：创建、上下文切换和管理成本较高，受限于操作系统线程的限制。</li></ul></li><li>N:1 线程模型<ul><li>定义：多个用户线程映射到一个操作系统线程。</li><li>优点：用户态调度更轻量，创建和管理成本低，节约资源。</li><li>缺点：如果用户态线程阻塞，整个线程就会阻塞；无法充分利用多核。</li></ul></li><li>M:N 线程模型<ul><li>定义：多个用户线程可以映射到多个操作系统线程，通过用户态调度器调度。</li><li>优点：灵活性强，可以在用户态进行高效调度，充分利用多核优势，同时减少线程创建和上下文切换的成本。</li><li>缺点：实现复杂，用户态调度器需要与操作系统进行交互，确保高效和一致性。</li></ul></li></ol><p>为什么 Go Scheduler 选择 M:N 模型？</p><ul><li><p>Go Scheduler 采用 M:N 线程模型，主要是为了结合 1:1 和 N:1 模型的优势，解决两者的缺点：</p><ul><li>高效并发：通过用户态调度器，实现轻量级的 Goroutine 并发，降低创建和管理成本。</li><li>多核支持：通过多个操作系统线程，确保可以充分利用多核 CPU，支持高并发。</li><li>灵活的调度：用户态调度器可以实现灵活的调度策略，减少线程阻塞导致的性能问题。</li></ul></li></ul><p>Go Scheduler 由以下几个关键部分构成：</p><ul><li>M（Machine）：表示操作系统线程。一个 M 可以运行多个 Goroutine。</li><li>P（Processor）：逻辑处理器，负责管理 Goroutine 的调度和运行。每个 P 与一个 M 关联，M 可以在不同 P 之间切换。</li><li>G（Goroutine）：代表一个 Goroutine 实例，可以在 P 上运行。</li></ul><p>Go 的 Scheduler 使用 GMP 模型管理 Goroutine 的调度。P 负责调度 Goroutine，M 负责操作系统线程，G 代表具体的 Goroutine 实例。</p><h3 id="2-17-互斥锁正常模式和饥饿模式的区别-？"><a href="#2-17-互斥锁正常模式和饥饿模式的区别-？" class="headerlink" title="2.17 互斥锁正常模式和饥饿模式的区别 ？"></a>2.17 互斥锁正常模式和饥饿模式的区别 ？</h3><p>在 Go 语言中，互斥锁（sync.Mutex）有两种不同的工作模式：正常模式和饥饿模式。两者的区别主要在于锁的公平性以及锁竞争时的调度策略。</p><ol><li><p>正常模式</p><ul><li>在正常模式下，sync.Mutex 按照 “先到先得” 的原则工作，但并不保证绝对的公平性。锁在释放后，会尽量满足已经在等待的 Goroutine，但不是严格按照队列顺序。以下是正常模式的主要特点：</li></ul></li><li><p>饥饿模式</p><ul><li>饥饿模式用于处理锁竞争中可能出现的饥饿问题。在饥饿模式下，锁按照严格的队列顺序分配，确保所有等待的 Goroutine 按照请求顺序获得锁。以下是饥饿模式的主要特点：</li></ul></li><li><p>什么时候使用饥饿模式？</p><ul><li>在 Go 中，sync.Mutex 默认使用正常模式，但在某些情况下可能会切换到饥饿模式。当锁竞争激烈时，可能会出现某些 Goroutine 长时间无法获得锁的情况，此时锁会自动切换到饥饿模式，确保公平性。</li></ul></li></ol><h3 id="2-18-解释Go-work-stealing-机制？"><a href="#2-18-解释Go-work-stealing-机制？" class="headerlink" title="2.18 解释Go work stealing 机制？"></a>2.18 解释Go work stealing 机制？</h3><p>Work Stealing 机制的基本原理是：</p><p>当一个 P 处理完其队列中的 Goroutines，但其他 P 仍然有未处理的 Goroutines 时，它可以从其他 P 的队列中窃取工作。这种机制的核心目的是平衡负载，确保所有的 P 都有足够的工作，以最大限度地利用多核 CPU 的性能。</p><h3 id="2-19-解释-Go-hand-off-机制？"><a href="#2-19-解释-Go-hand-off-机制？" class="headerlink" title="2.19 解释 Go hand off 机制？"></a>2.19 解释 Go hand off 机制？</h3><p>Hand Off 机制的关键在于减少 Goroutines 的调度延迟。当一个 Goroutine 释放锁、结束 I&#x2F;O 操作或执行其他使其可以再次运行的操作时，如果将其重新放回调度队列可能会导致额外的调度延迟。因此，Hand Off 机制允许在适当的情况下，直接将 Goroutine 交给其他操作系统线程进行运行，减少中间步骤。</p><h3 id="2-20-如何在Golang中实现协程池？"><a href="#2-20-如何在Golang中实现协程池？" class="headerlink" title="2.20 如何在Golang中实现协程池？"></a>2.20 如何在Golang中实现协程池？</h3><pre><code class="go">package mainimport (    &quot;fmt&quot;    &quot;sync&quot;    &quot;time&quot;)// Worker 是一个执行任务的协程func Worker(id int, tasks &lt;-chan func(), wg *sync.WaitGroup) &#123;    defer wg.Done()    for task := range tasks &#123;        fmt.Printf(&quot;Worker %d starting task\n&quot;, id)        task() // 执行任务        fmt.Printf(&quot;Worker %d completed task\n&quot;, id)    &#125;&#125;func main() &#123;    const numWorkers = 3  // 协程池大小    const numTasks = 10   // 总任务数量    tasks := make(chan func(), numTasks) // 用于分发任务的通道    var wg sync.WaitGroup                // 等待所有任务完成的 WaitGroup    // 创建工作者    for i := 1; i &lt;= numWorkers; i++ &#123;        wg.Add(1)        go Worker(i, tasks, &amp;wg)    &#125;    // 分发任务    for i := 1; i &lt;= numTasks; i++ &#123;        task := func(taskID int) func() &#123;            return func() &#123;                fmt.Printf(&quot;Executing task %d\n&quot;, taskID)                time.Sleep(1 * time.Second) // 模拟任务处理时间            &#125;        &#125;(i)        tasks &lt;- task    &#125;    // 关闭任务通道，表示不再有新任务    close(tasks)    // 等待所有工作者完成任务    wg.Wait()    fmt.Println(&quot;All tasks completed&quot;)&#125;</code></pre><p>通过这样的方式，你可以控制同时运行的协程数量，避免创建过多的协程引起的性能和资源问题。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 常识类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H.264编码</title>
      <link href="/2024/05/02/H-264%E7%BC%96%E7%A0%81/"/>
      <url>/2024/05/02/H-264%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="H-264编码"><a href="#H-264编码" class="headerlink" title="H.264编码"></a>H.264编码</h1><p>H.264 是一种用于视频压缩和编码的标准，正式名称为 Advanced Video Coding (AVC)。它由国际电信联盟（ITU-T）和国际标准化组织（ISO&#x2F;IEC）共同制定，并成为视频压缩领域中广泛使用的标准。以下是关于 H.264 的关键知识点的总结，包括其特点、技术细节、应用场景等。</p><p>常见的视频编码标准：</p><ul><li><p>H.264&#x2F;AVC：一种广泛应用的高效视频编码标准，常用于流媒体、视频会议、高清电视等。</p></li><li><p>H.265&#x2F;HEVC：是 H.264 的继承者，提供更高的压缩率，适用于 4K 和 8K 视频。</p></li><li><p>VP9：一种开放源代码的编码标准，常用于 Web 和移动设备。</p></li><li><p>AV1：一种开放且免版税的编码标准，越来越受到关注。</p></li></ul><h2 id="H-264-的特点"><a href="#H-264-的特点" class="headerlink" title="H.264 的特点"></a>H.264 的特点</h2><ul><li><p>高压缩率：H.264 提供了高效的视频压缩方法，在保持较高质量的同时显著减少文件大小。</p></li><li><p>广泛兼容：H.264 是一种通用标准，广泛用于各种设备和平台，包括计算机、移动设备、网络流媒体、电视等。</p></li><li><p>灵活性：H.264 支持多种编码配置和参数设置，适用于不同的应用场景。</p></li><li><p>支持多种分辨率和帧率：H.264 可以用于各种分辨率和帧率，从低分辨率的视频到高清和超高清（如 4K、8K）。</p></li></ul><h2 id="H-264-的技术细节"><a href="#H-264-的技术细节" class="headerlink" title="H.264 的技术细节"></a>H.264 的技术细节</h2><ul><li><p>帧内和帧间压缩：H.264 使用帧内压缩和帧间压缩的方法，以最大限度地减少冗余。帧内压缩指在单个帧内进行压缩，帧间压缩指通过预测其他帧来压缩。</p></li><li><p>宏块和预测：H.264 将视频划分为宏块，并使用多种预测技术进行压缩。宏块可以有不同的大小和形状，支持灵活的预测模式。</p></li><li><p>运动估计和补偿：H.264 通过运动估计和补偿减少帧间冗余，这有助于降低比特率。</p></li><li><p>量化和熵编码：H.264 使用量化来进一步压缩数据，并通过熵编码来减少比特率。</p></li><li><p>SPS 和 PPS：H.264 使用序列参数集（SPS）和画面参数集（PPS）来提供关于视频序列和画面的关键信息。</p></li></ul><h2 id="H-264-的应用场景"><a href="#H-264-的应用场景" class="headerlink" title="H.264 的应用场景"></a>H.264 的应用场景</h2><ul><li><p>视频流媒体：H.264 是互联网流媒体服务（如 YouTube、Netflix）的标准编码方式，提供高质量的压缩和较低的比特率。</p></li><li><p>视频会议：H.264 被广泛用于视频会议和实时通信，提供高效的压缩和低延迟。</p></li><li><p>电视和广播：H.264 被用于高清电视和数字广播，提供高质量的视频压缩。</p></li><li><p>移动设备：由于其高效的压缩能力，H.264 被广泛用于移动设备和便携式媒体播放器。</p></li></ul><h2 id="H-264-的限制和替代品"><a href="#H-264-的限制和替代品" class="headerlink" title="H.264 的限制和替代品"></a>H.264 的限制和替代品</h2><ul><li><p>计算复杂性：H.264 的编码和解码需要一定的计算资源，这可能在某些设备上带来挑战。</p></li><li><p>新标准的出现：随着 H.265（HEVC）和 AV1 等新标准的出现，H.264 在某些应用场景中可能被替代。新标准提供更高的压缩率和更好的性能。</p></li><li><p>专利和许可：H.264 受专利保护，可能需要付费许可，而某些新标准（如 AV1）是开放且免费的。</p></li></ul><h2 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a>常见术语</h2><ul><li><p>H.264（Advanced Video Coding）</p><p>  H.264 是一种高级视频编码标准，提供高效的视频压缩。它由国际电信联盟（ITU-T）和国际标准化组织（ISO&#x2F;IEC）的联合视频专家组（JVT）制定。</p></li><li><p>AVC（Advanced Video Coding）</p><p>  AVC 是 H.264 的另一种名称，强调其在视频编码方面的高级功能。</p></li><li><p>NAL（Network Abstraction Layer）</p><p>  网络抽象层，是 H.264 标准中用于将视频数据封装为网络友好格式的部分。</p></li><li><p>NALU（Network Abstraction Layer Unit）</p><p>  网络抽象层单元，是 NAL 中的基本单位，用于封装视频数据和提供控制信息。</p></li><li><p>SPS（Sequence Parameter Set）</p><p>  序列参数集，包含关于整个视频序列的参数和设置，如分辨率、帧率、颜色格式等。</p></li><li><p>PPS（Picture Parameter Set）</p><p>  画面参数集，包含关于单个画面的参数和设置，如宏块参数、预测模式等。</p></li><li><p>IDR Frame（Instantaneous Decoding Refresh Frame）</p><p>  即时解码刷新帧，也称为关键帧，是一种独立帧，可以用来重置解码状态。</p></li><li><p>I Frame（Intra-coded Frame）</p><p>  帧内编码帧，也称为关键帧，是一种独立的帧，作为其他帧的基准。</p></li><li><p>P Frame（Predicted Frame）</p><p>  预测帧，是一种基于前一帧进行预测的视频帧。</p></li><li><p>B Frame（Bi-predictive Frame）</p><p>  双向预测帧，是一种基于前后帧进行预测的视频帧。</p></li><li><p>Motion Estimation</p><p>  运动估计，是视频编码中用于帧间预测的技术，确定视频帧中的运动矢量。</p></li><li><p>Entropy Coding</p><p>  熵编码，是一种数据压缩方法，使用变长编码来压缩数据。</p></li></ul><h2 id="I-帧与-IDR-帧的区别"><a href="#I-帧与-IDR-帧的区别" class="headerlink" title="I 帧与 IDR 帧的区别"></a>I 帧与 IDR 帧的区别</h2><ul><li><p>前向引用：I 帧不依赖其他帧进行解码，但其后的帧可能引用 I 帧之前的帧。而 IDR 帧确保其后的所有帧不会引用之前的帧，这意味着从 IDR 帧开始，解码器可以安全地解码，而无需担心前向参考。</p></li><li><p>重启解码状态：IDR 帧用于确保解码器可以从此帧开始解码，而 I 帧不一定具有这种保证。</p></li><li><p>用途：IDR 帧更适合用于需要重启解码状态的场景，例如视频流的切换、场景变化等，而 I 帧用于独立解码但可能涉及前向参考的场景。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebRTC-一对一通话</title>
      <link href="/2024/05/02/WebRTC-%E4%B8%80%E5%AF%B9%E4%B8%80%E9%80%9A%E8%AF%9D/"/>
      <url>/2024/05/02/WebRTC-%E4%B8%80%E5%AF%B9%E4%B8%80%E9%80%9A%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<h1 id="WebRTC-一对一通话"><a href="#WebRTC-一对一通话" class="headerlink" title="WebRTC-一对一通话"></a>WebRTC-一对一通话</h1><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/2024/05/02/WebRTC-%E4%B8%80%E5%AF%B9%E4%B8%80%E9%80%9A%E8%AF%9D/logic.png"></p><h2 id="通话过程"><a href="#通话过程" class="headerlink" title="通话过程"></a>通话过程</h2><p><img src="/2024/05/02/WebRTC-%E4%B8%80%E5%AF%B9%E4%B8%80%E9%80%9A%E8%AF%9D/logic2.png"></p><h3 id="图解："><a href="#图解：" class="headerlink" title="图解："></a>图解：</h3><ul><li>WebRTC 终端：负责音视频<code>采集</code>、<code>编解码</code>、<code>NAT穿越</code>、音视频<code>数据传输</code></li><li>Signal 信令服务器：负责<code>信令处理</code>、如加入房间、离开房间、媒体协商消息的传递</li><li>STUN&#x2F;TURN服务器：负责获取WebRTC终端在<code>公网</code>的IP地址，以及NAT穿越失败后的<code>数据中转</code></li></ul><h3 id="WebRTC-进行通话的大体过程"><a href="#WebRTC-进行通话的大体过程" class="headerlink" title="WebRTC 进行通话的大体过程"></a>WebRTC 进行通话的大体过程</h3><ol><li><p>音视频采集</p><ul><li>进入房间前，先进行检测设备可用性，当可用时则进行音视频数据的采集</li></ul></li><li><p>采集后的处理</p><ul><li>一方面：采集的数据会进行用作预览，即自己可以看到画面</li><li>另一方面：可以将其录制下来保存为文件、等视频通话结束后，上传到服务器后可以让用户回看之前的内容</li></ul></li><li><p>获取数据就绪后 - 房间的创建和加入</p><ul><li>WebRTC终端向信令服务器发送「加入」的信令，Signal服务器收到消息后会进行创建房间的操作 - 推流端</li><li>另一端也会做差不多一样的事，不同点在于不是创建房间，而是加入房间 - 观看端</li><li>第二个终端(观看端)成功加入房间后，第一个用户(推流端)会收到「另一个用户已成功加入」的消息</li></ul></li><li><p>获取数据就绪后 - 音视频数据传递</p><ul><li>第一个终端(推流端)会创建“媒体连接”对象，即RTCPeerConnection，然后将采集到的音视频数据通过RTCPeerConnection对象进行编码，最终通过P2P传送给对方；</li><li>P2P穿越失败后：为保障音视频数据正常，需要通过TURN服务器进行音视频数据中转</li><li>第二端(观看端)接收到数据后，会先将收到的数据进行解码，最后将其展示出来，这样就实现了一对一的单通</li><li>实现互通的方式：双方都需要通过RTCPeerConnection对象传输自己端的数据，然后另一端进行接收</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传输协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZLMediaKit使用说明</title>
      <link href="/2024/05/01/ZLMediaKit%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2024/05/01/ZLMediaKit%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="ZLMediaKit使用说明"><a href="#ZLMediaKit使用说明" class="headerlink" title="ZLMediaKit使用说明"></a>ZLMediaKit使用说明</h1><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>你有三种方法使用ZLMediaKit，分别是：</p><ol><li>使用c api，作为sdk使用，请参考<a href="https://github.com/ZLMediaKit/ZLMediaKit/tree/master/api/include">这里</a>.</li><li>作为独立的流媒体服务器使用，不想做c&#x2F;c++开发的，可以参考 <a href="https://github.com/ZLMediaKit/ZLMediaKit/wiki/MediaServer%E6%94%AF%E6%8C%81%E7%9A%84HTTP-API">restful api</a> 和 <a href="https://github.com/ZLMediaKit/ZLMediaKit/wiki/MediaServer%E6%94%AF%E6%8C%81%E7%9A%84HTTP-HOOK-API">web hook</a>.</li><li>如果想做c&#x2F;c++开发，添加业务逻辑增加功能，可以参考<a href="https://github.com/ZLMediaKit/ZLMediaKit/tree/master/tests">这里</a>的测试程序.</li></ol><h2 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h2><p>根据<a href="https://github.com/ZLMediaKit/ZLMediaKit">git项目</a>自行操作，建议使用docker方式启动。</p><pre><code class="bash">#此镜像为github持续集成自动编译推送，跟代码(master分支)保持最新状态docker run -id -p 1935:1935 -p 8080:80 -p 8443:443 -p 8554:554 -p 10000:10000 -p 10000:10000/udp -p 8000:8000/udp -p 9000:9000/udp zlmediakit/zlmediakit:master</code></pre><h2 id="推流"><a href="#推流" class="headerlink" title="推流"></a>推流</h2><p>ZLMediaKit支持rtsp&#x2F;rtmp&#x2F;rtp推流，一般通常使用obs&#x2F;ffmpeg推流测试，其中FFmpeg推流命令支持以下：</p><ol><li>使用rtsp方式推流<pre><code class="bash"># h264推流ffmpeg -re -i &quot;/path/to/test.mp4&quot; -vcodec h264 -acodec aac -f rtsp -rtsp_transport tcp rtsp://127.0.0.1/live/test# h265推流ffmpeg -re -i &quot;/path/to/test.mp4&quot; -vcodec h265 -acodec aac -f rtsp -rtsp_transport tcp rtsp://127.0.0.1/live/test</code></pre></li><li>使用rtmp方式推流<pre><code class="bash">ffmpeg -re -i &quot;/path/to/test.mp4&quot; -vcodec h264 -acodec aac -f flv rtmp://127.0.0.1/live/test# RTMP标准不支持H265,但是国内有自行扩展的，如果你想让FFmpeg支持RTMP-H265,请按照此文章编译：https://github.com/ksvc/FFmpeg/wiki/hevcpush</code></pre></li><li>使用rtp方式推流<pre><code class="bash"># h264推流ffmpeg -re -i &quot;/path/to/test.mp4&quot; -vcodec h264 -acodec aac -f rtp_mpegts rtp://127.0.0.1:10000# h265推流ffmpeg -re -i &quot;/path/to/test.mp4&quot; -vcodec h265 -acodec aac -f rtp_mpegts rtp://127.0.0.1:10000</code></pre></li></ol><h2 id="收流"><a href="#收流" class="headerlink" title="收流"></a>收流</h2><p>可以通过接口 <strong>http:&#x2F;&#x2F;&lt; ip &gt;:8080&#x2F;index&#x2F;api&#x2F;getMediaList?secret&#x3D;&lt; secret &gt;</strong> 获取  </p><ul><li>8080是因为我们使用docker启动时映射的是8080:80</li><li>secret需要进入容器 在文件&#x2F;opt&#x2F;media&#x2F;conf&#x2F;config.ini中查看</li></ul><p>然后我们可以获取到所有的流数据，简化如下：</p><pre><code class="json">&#123;    &quot;code&quot; : 0,    &quot;data&quot; :     [        &#123;            &quot;app&quot; : &quot;live&quot;            &#123;                &quot;identifier&quot; : &quot;24-83&quot;,                &quot;local_ip&quot; : &quot;172.17.0.2&quot;,                &quot;local_port&quot; : 1935,                &quot;peer_ip&quot; : &quot;192.168.100.104&quot;,                &quot;peer_port&quot; : 57008            &#125;,            &quot;schema&quot; : &quot;rtsp&quot;,            &quot;stream&quot; : &quot;test&quot;,        &#125;    ]&#125;</code></pre><p>播放流的url组成以 <strong>rtsp:&#x2F;&#x2F;somedomain.com:554&#x2F;live&#x2F;0?token&#x3D;abcdefg&amp;field&#x3D;value</strong> 为例,该url分为以下几个部分：</p><ul><li>协议(scheam) : rtsp协议,默认端口554</li><li>虚拟主机(vhost) : somedomain.com,该字段既可以是域名也可以是ip，如果是ip则对应的虚拟主机为__defaultVhost__</li><li>服务端口号(port) : 554,如果不指定端口号，则使用协议默认端口号</li><li>应用名(app) : live</li><li>流ID(streamid) : 0</li><li>参数(args) : token&#x3D;abcdefg&amp;field&#x3D;value</li></ul><p>对于上述json回复，我们使用</p><pre><code class="bash"># 8554 docker映射了554端口ffplay.exe -i rtsp://&lt;ip&gt;:8554/live/test</code></pre><p>即可进行播放。</p>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zlmediakit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SRS使用说明</title>
      <link href="/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="SRS使用说明"><a href="#SRS使用说明" class="headerlink" title="SRS使用说明"></a>SRS使用说明</h1><h2 id="方法一：-Docker-使用SRS"><a href="#方法一：-Docker-使用SRS" class="headerlink" title="方法一： Docker 使用SRS"></a>方法一： Docker 使用SRS</h2><ul><li><p>启动命令：</p><pre><code class="bash">docker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 registry.cn-hangzhou.aliyuncs.com/ossrs/srs:5</code></pre></li><li><p>使用ffmpeg推流：</p><pre><code class="bash">ffmpeg -re -i ./doc/source.flv -c copy -f flv rtmp://localhost/live/livestream</code></pre></li><li><p>打开下面的页面播放流（若SRS不在本机，请将localhost更换成服务器IP）:</p><ul><li>RTMP (by VLC): rtmp:&#x2F;&#x2F;localhost&#x2F;live&#x2F;livestream</li><li>H5(HTTP-FLV): <a href="http://localhost:8080/live/livestream.flv">http://localhost:8080/live/livestream.flv</a></li><li>H5(HLS): <a href="http://localhost:8080/live/livestream.m3u8">http://localhost:8080/live/livestream.m3u8</a></li></ul></li></ul><h2 id="方法二：-源码编译-使用SRS"><a href="#方法二：-源码编译-使用SRS" class="headerlink" title="方法二： 源码编译 使用SRS"></a>方法二： 源码编译 使用SRS</h2><ul><li><p>下载源码：</p><pre><code class="bash">git clone -b develop https://gitee.com/ossrs/srs.git</code></pre></li><li><p>编译，注意需要切换到srs&#x2F;trunk目录：</p><pre><code class="bash">cd srs/trunk./configuremake</code></pre></li><li><p>启动服务器：</p><pre><code class="bash"># conf文件夹下有很多配置，这里默认选用srs.conf./objs/srs -c conf/srs.conf</code></pre></li><li><p>检查SRS是否成功启动，可以打开 <a href="http://localhost:8080/">http://localhost:8080/</a> ，或者执行命令：</p><pre><code class="bash"># 查看SRS的状态./etc/init.d/srs status# 或者看SRS的日志tail -n 30 -f ./objs/srs.log# 启动SRS：./etc/init.d/srs start    # 停止SRS：./etc/init.d/srs stop    # 重启SRS：./etc/init.d/srs restart    # Reload SRS：./etc/init.d/srs reload</code></pre></li><li><p>推流同上</p></li></ul><h2 id="Oryx-的使用"><a href="#Oryx-的使用" class="headerlink" title="Oryx 的使用"></a>Oryx 的使用</h2><p>Oryx(SRS Stack)是一个基于Go、Reactjs、SRS、FFmpeg、WebRTC等的轻量级、开源的视频云解决方案。</p><ul><li><p>使用Docker启动：</p><pre><code class="bash">docker run --restart always -d -it --name oryx -v $HOME/data:/data -p 80:2022 -p 443:2443 -p 1935:1935 -p 8000:8000/udp -p 10080:10080/udp registry.cn-hangzhou.aliyuncs.com/ossrs/oryx:5</code></pre></li><li><p>直接访问<code>80</code>端口即可使用Orys</p><p>  SRS5对于推拉流暂时只下图所列出的：</p><p>  <img src="/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/Oryx.png"></p></li></ul><h2 id="SRS-接入-GB28181-docker方式"><a href="#SRS-接入-GB28181-docker方式" class="headerlink" title="SRS 接入 GB28181 (docker方式)"></a>SRS 接入 GB28181 (docker方式)</h2><p>必须是 6.0 才支持 HEVC</p><p>HEVC（High Efficiency Video Coding，高效视频编码）是视频编码标准，也称为 H.265</p><ul><li><p>启动容器<br>  首先本地创建一个gb28181.conf文件，用于配置协议的参数。</p><pre><code class="bash"># 拉取镜像docker pull registry.cn-hangzhou.aliyuncs.com/ossrs/srs:6# 启动容器CANDIDATE=&quot;192.168.110.115&quot; # 本机ipdocker run -itd --restart always -p 1935:1935 -p 1985:1985 -p 8080:8080 -p 5060:5060 -p 5060:5060/udp -p 9000:9000/udp --name srs6.0 --network host registry.cn-hangzhou.aliyuncs.com/ossrs/srs:6 ./objs/srs -c conf/gb28181.conf</code></pre></li><li><p>启动服务器：</p><pre><code class="bash"># conf文件夹下有很多配置，这里默认选用srs.conf./objs/srs -c conf/gb28181.conf</code></pre></li><li><p>摄像头设置：</p><p>  <img src="/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/gb28181_3.png"><br>  <img src="/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/gb28181_4.png"></p></li><li><p>查看实时流：</p><p>  访问<a href="http://192.168.110.115:1985/console/ng_index.html#/streams">webui控制台</a>，可以查看流状态：<br>  <img src="/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/gb28181_1.png"></p><p>  点击预览即可查看：<br>  <img src="/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/gb28181_2.png"></p></li></ul><p>总体来说，SRS6 目前也只支持 TCP 模式，且不支持密码认证和录像回放（需摄像头以NVR接入）等功能，所以整体体验下来是没有基于<a href="https://github.com/ZLMediaKit/ZLMediaKit">ZLMediakit</a>的<a href="https://github.com/648540858/wvp-GB28181-pro">wvp-GB28181-pro</a>好用的。</p><h2 id="SRS-WebRTC"><a href="#SRS-WebRTC" class="headerlink" title="SRS WebRTC"></a>SRS WebRTC</h2><p>SRS是一个媒体服务器，提供了Signaling和SFU Server的能力。和其他SFU比如Janus不同的是，<strong>SRS是基于Stream的</strong>，尽管房间中 可以有多个参与者，本质上都是有人在推流，其他人在订阅这个流。这样可以避免将房间中的所有流，都耦合到一个SFU传输，可以分散到 多个SFU传输，这样可以支持更多人的会议。</p><p>SRS支持的Signaling就是WHIP和WHEP，具体请参考<a href="https://ossrs.net/lts/zh-cn/docs/v6/doc/webrtc#http-api">HTTP API</a>部分。和直播很不一样的是，由于Signaling和Media分离， 因此需要设置<a href="https://ossrs.net/lts/zh-cn/docs/v6/doc/webrtc#config-candidate">Candidate</a>。Media默认使用UDP传输，若UDP不可用也可以用TCP参考<a href="https://ossrs.net/lts/zh-cn/docs/v6/doc/webrtc#webrtc-over-tcp">TCP</a>。若遇到不可用的情况，很有可能是Candidate设置不对，也有可能是防火墙或端口不通，请参考<a href="https://ossrs.net/lts/zh-cn/docs/v6/doc/webrtc#connection-failures">Connectivity</a>使用工具检查。SRS还支持了不同协议的转换，比如推流RTMP后用WebRTC观看参考<a href="https://ossrs.net/lts/zh-cn/docs/v6/doc/webrtc#rtmp-to-rtc">RTMP to WebRTC</a>，或者用WebRTC推流后用HLS观看参考<a href="https://ossrs.net/lts/zh-cn/docs/v6/doc/webrtc#rtc-to-rtmp">RTC to RTMP</a>。</p><p>下面是WHIP和WHEP的交互图：</p><p><img src="/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/rtc.png"></p><ul><li><a href="https://ossrs.net/lts/zh-cn/docs/v6/doc/webrtc#config">SRS中WebRTC相关配置和功能</a></li></ul><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="WHIP-和-WHEP"><a href="#WHIP-和-WHEP" class="headerlink" title="WHIP 和 WHEP"></a>WHIP 和 WHEP</h3><p>WHIP (WebRTC-HTTP Ingestion Protocol) 和 WHEP (WebRTC-HTTP Egress Protocol) 是用于 WebRTC 流媒体传输的两种协议，旨在简化和优化 WebRTC 应用中的流媒体传输过程。WHIP 通常用于上传媒体流，而 WHEP 用于下载媒体流。这两个协议通过提供简单的 HTTP 接口，简化了 WebRTC 的信令过程，使 WebRTC 应用的开发和部署更加容易。它们通常在实时流媒体、直播和其他需要实时通信的场景中使用。</p>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我遇到过的疑难杂症</title>
      <link href="/2024/04/17/%E6%88%91%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
      <url>/2024/04/17/%E6%88%91%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/</url>
      
        <content type="html"><![CDATA[<h1 id="我遇到过的疑难杂症"><a href="#我遇到过的疑难杂症" class="headerlink" title="我遇到过的疑难杂症"></a>我遇到过的疑难杂症</h1><h2 id="单片机上跑的udp程序突然崩溃"><a href="#单片机上跑的udp程序突然崩溃" class="headerlink" title="单片机上跑的udp程序突然崩溃"></a>单片机上跑的udp程序突然崩溃</h2><p>同事使用C语言写了个udp程序，与我的服务通信，逻辑是他起一个socket，向我发送数据，我回复OK。<br>一开始工作正常，但是一段时间后他的程序崩溃。<br>经排查，是因为他没有写<code>recv()</code>函数，且一直<code>复用的同一个socket</code>。数据到达后，没处理，堆积在缓冲区导致错误。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WebRTC</title>
      <link href="/2023/12/25/WebRTC/"/>
      <url>/2023/12/25/WebRTC/</url>
      
        <content type="html"><![CDATA[<h1 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h1><p>WebRTC（Web Real-Time Communication）是一种开放框架，用于在网络应用程序和网站之间实现实时通信。它是一个基于浏览器的技术，使开发人员能够创建语音、视频和数据的实时通信应用，而无需用户下载任何插件或第三方软件。</p><h2 id="协议类型"><a href="#协议类型" class="headerlink" title="协议类型"></a>协议类型</h2><p>WebRTC 包含一系列协议、API 和标准，用于实现实时通信。主要涉及的协议包括：</p><ol><li>ICE（Interactive Connectivity Establishment）：<br> 用于发现和连接两个端点之间的最优路径。</li><li>STUN（Session Traversal Utilities for NAT）：<br> 用于找到对等方的公共 IP 地址。</li><li>TURN（Traversal Using Relays around NAT）：<br> 用于在直接连接不可能时，通过中继服务器传递数据。</li><li>SRTP（Secure Real-time Transport Protocol）：<br> 用于安全的音视频传输。</li><li>DTLS（Datagram Transport Layer Security）：<br> 为 WebRTC 提供安全性和数据加密。</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>视频通话和语音通话：用于在浏览器中创建实时音视频通话应用，如视频会议、在线教育等。</li><li>实时数据传输：可用于文件共享、在线游戏、协作应用等。</li><li>直播流媒体：WebRTC 可以用于低延迟直播或点对点流媒体传输。</li></ol><h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><p>WebRTC实际上是两个Web浏览器之间直接通信的标准，主要包含了信令(Signaling)和媒体(Media)两个部分的协议。 信令解决两个设备之间的能力的协商的问题，比如支持的编解码能力。媒体解决两个设备之间加密和低延迟媒体包传输的能力。 除此之外，WebRTC本身还实现了语言处理技术比如3A，网络拥塞控制比如NACK、FEC和GCC，音视频编解码，平滑和低延迟播放技术。</p><pre><code class="css">+----------------+                        +----------------++    Browser     +----&lt;--Signaling-----&gt;--+    Browser     ++ (like Chrome)  +----&lt;----Media-----&gt;----+ (like Chrome)  ++----------------+                        +----------------+</code></pre><blockquote><p>Note: WebRTC已经是RFC正式标准，因此各种浏览器都已经支持，而开源的实现也很多，因此不限于浏览器，移动端的浏览器和 Native库也有很多，因此为了沟通的简单起见，本文一般以浏览器指代所有支持WebRTC协议的客户端或设备。</p></blockquote><p>在互联网上，两个浏览器几乎无法直接通信，特别是不在一个局域网，而且是在远距离跨城市甚至跨国家时，两个浏览器之间 传输数据会经过非常多的网络路由器和防火墙，因此传输质量无法保障。因此，实际应用是需要经过服务器中转，而WebRTC服务器有 几种类型：</p><ol><li><p>Signaling Server: </p><p> 信令服务，两个浏览器之间交换SDP的服务。如果是多人会议，则需要提供房间服务，本质上都是为各个浏览器交换SDP。而在流媒体领域，为了可以使用WebRTC推流和播放，像推送和播放RTMP&#x2F;SRT&#x2F;HLS流一样，WHIP&#x2F;WHEP协议被设计出来了。</p></li><li><p>TURN Server: </p><p> 转发服务，帮助两个浏览器之间转发媒体数据的服务。这是一种透明转发服务，并<strong>不会实现数据缓存</strong>，因此当多人会议时，浏览器之间需要传输<code>N*N + N*(N-2)</code>份数据。一般只应用在非常少的通信场景中，比如一对一。开源实现可查看<a href="https://github.com/coturn/coturn">coturn</a>这个项目。</p></li><li><p>SFU Server: </p><p> 选择性转发服务，服务器上有缓存数据，因此浏览器只需要上传一份数据，服务器会复制给其他参会者。<strong>SRS就是SFU</strong>，关于SFU的作用可以参考<a href="https://stackoverflow.com/questions/61703692/what-is-the-role-of-sfu-janus-mediasoup-or-medooze-on-a-webrtc-application/75491178#75491178">这里</a>。目前主要的WebRTC服务器都是SFU服务器，会有<code>N*N</code>份流传输，比TURN少<code>N*(N-2)</code>份上行数据传输，能解决大部分的传输问题。</p></li><li><p>MCU Server: </p><p> 多点控制服务，服务器将会议中的流合并成一路，这样浏览器只需要传输N*2份数据，上传一路下载一路数据。但由于<strong>需要编解码</strong>，服务器支持的流的数量比SFU要少一个量级，只有在某些特定场景才会采用。</p></li></ol><p>我们重点介绍SFU的工作流，因为SFU是在WebTC服务器中使用最多的，它本质上就是一个浏览器：</p><pre><code class="css">+----------------+                        +---------++    Browser     +----&lt;--Signaling-----&gt;--+   SFU   ++ (like Chrome)  +----&lt;----Media-----&gt;----+  Server ++----------------+                        +---------+</code></pre><blockquote><p>Note: SFU一般都会有Signaling的能力，其实可以把RTMP地址也可以看成是一种非常简化的信令协议，只是WebRTC的信令需要协商 媒体和传输能力，所以比较复杂。在复杂的WebRTC系统中，可能有独立的Signaling和Room集群，但是SFU同样也会有简化的Signaling能力， 只是可能是用于和其他服务通信。</p></blockquote><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="WebRTC-是-P2P-的-一对一视频的时候好理解-那多对多怎么做到-P2P-呢"><a href="#WebRTC-是-P2P-的-一对一视频的时候好理解-那多对多怎么做到-P2P-呢" class="headerlink" title="WebRTC 是 P2P 的,一对一视频的时候好理解,那多对多怎么做到 P2P 呢"></a>WebRTC 是 P2P 的,一对一视频的时候好理解,那多对多怎么做到 P2P 呢</h3><p>WebRTC 的核心原则是点对点（Peer-to-Peer，P2P）通信，但在多对多的场景中，直接的 P2P 连接可能会变得复杂。WebRTC 的设计初衷是尽可能使用 P2P 连接，以提高效率和降低延迟，但在多对多场景中，可能会使用不同的技术架构和策略。</p><p>在多对多的 WebRTC 应用中，通常有两种主要模式来处理点对点通信：</p><ol><li>Mesh 模式：<br> 在 Mesh 模式中，每个参与者与其他所有参与者建立 P2P 连接。这意味着如果有 N 个参与者，每个参与者将建立 N-1 个连接。因此，整个网络中会有 N*(N-1)&#x2F;2 个连接。<ul><li>优点：直接的 P2P 连接提供了最低的延迟，数据不需要经过中间服务器。</li><li>缺点：连接数量随着参与者数量的增加而指数增长，这会导致带宽和资源消耗的增加。这种模式在小规模会议中效果较好，但在大型会议或资源受限的环境中可能会遇到瓶颈。</li></ul></li><li>SFU 模式（Selective Forwarding Unit）：<br> 在 SFU 模式中，每个参与者只与一个中间服务器（SFU）建立连接。SFU 服务器负责接收每个参与者的音频和视频流，然后根据需求将其转发给其他参与者。<ul><li>优点：减少了参与者之间的连接数量，降低了每个参与者的带宽和处理负担。SFU 服务器可以选择性地转发流，从而支持更大的会议规模。</li><li>缺点：SFU 服务器引入了一定的延迟，因为数据需要经过中间服务器；而且 SFU 服务器可能成为单点故障。</li></ul></li></ol><h3 id="SFU-与-MCU-的区别"><a href="#SFU-与-MCU-的区别" class="headerlink" title="SFU 与 MCU 的区别"></a>SFU 与 MCU 的区别</h3><ul><li><p>SFU（Selective Forwarding Unit）</p><p>  SFU 是选择性转发的，可以选择性地转发音频和视频流，允许每个参与者接收不同数量的流或不同质量的流。</p></li><li><p>MCU（Multipoint Control Unit）</p><p>  MCU 将多个参与者的音频和视频流进行合成，这意味着每个参与者只需接收一条合成流。由于 MCU 需要对媒体流进行解码、合成和转码，资源消耗相对较高。</p></li></ul><p>架构区别如下：</p><p><img src="/2023/12/25/WebRTC/sfu_mcu.png"></p><table><thead><tr><th></th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>SFU</td><td>灵活分发，并发高</td><td>下行转发路数多，带宽占用高，多方通话影响体验</td></tr><tr><td>MCU</td><td>转发流数少，下行带宽占用少</td><td>服务器性能要求高，部署成本高，实时性稍差</td></tr></tbody></table><h3 id="优秀开源项目"><a href="#优秀开源项目" class="headerlink" title="优秀开源项目"></a>优秀开源项目</h3><p>WebRTC 的生态中，有许多优异的开源媒体服务器，下面列出部分关注度高的项目：</p><table><thead><tr><th>Project</th><th>SFU</th><th>MCU</th><th>LIcense</th></tr></thead><tbody><tr><td>SRS</td><td>☑️</td><td>✖️</td><td>MIT</td></tr><tr><td>Janus</td><td>☑️</td><td>☑️</td><td>GPL v3</td></tr><tr><td>Licode</td><td>☑️</td><td>☑️</td><td>MIT</td></tr><tr><td>MediaSoup</td><td>☑️</td><td>✖️</td><td>ISC</td></tr><tr><td>Kurento</td><td>☑️</td><td>☑️</td><td>Apache2</td></tr><tr><td>Jitsi</td><td>☑️</td><td>✖️</td><td>Apache2</td></tr></tbody></table><h3 id="优秀文章"><a href="#优秀文章" class="headerlink" title="优秀文章"></a>优秀文章</h3><p>关于WebRTC的传输机制，我看到一篇很详细的文章，可以参考：<br><a href="https://juejin.cn/post/7171446735661695006">WebRTC → 传输技术解析</a></p>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传输协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GB28181</title>
      <link href="/2023/11/26/GB28181/"/>
      <url>/2023/11/26/GB28181/</url>
      
        <content type="html"><![CDATA[<h1 id="GB28181"><a href="#GB28181" class="headerlink" title="GB28181"></a>GB28181</h1><p>GB28181是中国国家标准编号，标题是“基于IP网络的安全防范视频监控联网系统信息传输、交换、控制技术要求”。这是一个中国国内的标准，主要用于安全防范和监控系统，确保不同制造商的设备在基于IP的网络环境下能够互操作。GB28181标准的主要用途在于公共安全和城市监控应用，例如公安、交通、社区等。</p><h2 id="协议类型"><a href="#协议类型" class="headerlink" title="协议类型"></a>协议类型</h2><p>GB28181规范了基于IP网络的安全防范视频监控联网系统的信息传输、交换、控制等技术要求。主要内容包括：</p><ol><li>通信协议：规定了信令和媒体传输协议，确保设备之间可以互操作。</li><li>媒体传输：定义了音视频流的传输方式，支持RTP、RTCP等。</li><li>控制信令：定义了设备的控制、管理、告警等功能，包括注册、注销、心跳等信令。</li><li>设备互操作性：确保不同厂商的设备能够在同一个网络环境下进行协作。</li></ol><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>主要应用于安全防范和视频监控领域</p><h2 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h2><p>GB28181采用了标准的IP网络协议堆栈，通常基于<code>SIP（Session Initiation Protocol）</code>作为信令协议，使用<code>RTP（Real-time Transport Protocol）</code>传输音视频流。其工作机制大致如下：</p><ol><li>设备注册：<br>设备通过SIP向中央服务器注册，以便在网络中标识和管理。</li><li>媒体传输：<br>音视频流通过RTP传输，通常在局域网或广域网中传输监控内容。</li><li>设备控制：<br>中央服务器可以通过SIP信令向设备发送控制指令，例如摄像头的移动、变焦、聚焦等。</li><li>告警和心跳：<br>设备可以向服务器发送告警信息或心跳信号，确保系统状态正常。</li></ol><p>设备工作流程：<br><img src="/2023/11/26/GB28181/gb28181.png" alt="工作流程"></p><h2 id="SIP-信令协议"><a href="#SIP-信令协议" class="headerlink" title="SIP 信令协议"></a>SIP 信令协议</h2><h3 id="SIP-和-SDP"><a href="#SIP-和-SDP" class="headerlink" title="SIP 和 SDP"></a>SIP 和 SDP</h3><p>SIP（Session Initiation Protocol）与 SDP（Session Description Protocol）是用于通信领域的重要协议。虽然它们常常一起使用，但它们在功能和作用上有很大的区别。</p><ul><li><p>SIP<br>  SIP，全称 “Session Initiation Protocol”，是一种应用层协议，主要用于创建、修改和终止多媒体会话（如语音、视频、消息等）。它在网络电话、即时消息、视频会议、流媒体等应用中广泛使用。SIP 的核心功能包括：</p><ol><li>会话建立：通过邀请消息（INVITE）和应答消息等建立会话。</li><li>会话修改：在会话进行过程中调整会话的参数，例如添加或移除媒体流。</li><li>会话终止：通过发送 BYE 消息来结束会话。</li></ol><p>  SIP 使用请求-响应模型，类似于 HTTP，并支持多种传输协议（例如，UDP、TCP、TLS）。SIP 不定义实际传输的数据，而是处理与会话控制相关的信令。</p></li><li><p>SDP<br>  SDP，全称 “Session Description Protocol”，是一种用于描述多媒体会话参数的协议。它通常与 SIP 一起使用，用于描述会话的相关信息。<br>  SDP 描述的内容包括：</p><ol><li>会话名称和目的：用于标识会话。</li><li>时间信息：表明会话何时开始和结束。</li><li>媒体描述：包括媒体类型、传输协议、端口号、编解码器等。</li><li>连接信息：表明会话在哪个网络地址进行。</li></ol><p>  SDP 的结构通常是文本格式的，易于解析和生成。它在 SIP 消息中常见，特别是用于描述会话的媒体属性。在 SIP 中，SDP 通常包含在 INVITE 请求和应答消息中，用于协商通信双方如何交换媒体流。</p></li><li><p>关系<br>  SIP 和 SDP 的关系可以概括为：</p><ul><li>SIP 负责建立、修改和终止会话，是一种用于信令和控制的协议。</li><li>SDP 用于描述会话的细节，包括媒体类型、传输参数和编解码器等，是一种描述性协议。</li></ul><p>  在 SIP 会话的建立过程中，SDP 通常作为 SIP 消息的一部分，以描述会话的详细信息。在 SIP 会话中，SDP 的使用是为了协商会话双方的媒体参数，确保能够正确交换媒体流。</p></li></ul><h3 id="SIP-请求消息分类"><a href="#SIP-请求消息分类" class="headerlink" title="SIP 请求消息分类"></a>SIP 请求消息分类</h3><table><thead><tr><th>请求类型</th><th>描述</th></tr></thead><tbody><tr><td>INVITE</td><td>发起会话或邀请参与者加入现有会话，可能包含 SDP 信息。</td></tr><tr><td>ACK</td><td>确认 INVITE 请求的最终响应。</td></tr><tr><td>BYE</td><td>终止会话。</td></tr><tr><td>CANCEL</td><td>取消正在进行的请求。</td></tr><tr><td>REGISTER</td><td>向注册服务器注册用户代理位置。</td></tr><tr><td>OPTIONS</td><td>查询服务器或用户代理的功能和可用性。</td></tr><tr><td>INFO</td><td>在会话中发送辅助信息。</td></tr><tr><td>PRACK</td><td>对临时响应的确认。</td></tr><tr><td>UPDATE</td><td>更新现有会话的参数。</td></tr><tr><td>REFER</td><td>将当前会话转移给其他用户代理。</td></tr><tr><td>SUBSCRIBE</td><td>订阅特定事件。</td></tr><tr><td>NOTIFY</td><td>向订阅者发送事件通知。</td></tr><tr><td>MESSAGE</td><td>发送即时消息。</td></tr><tr><td>PUBLISH</td><td>发布状态信息。</td></tr></tbody></table><h3 id="SIP-响应消息分类"><a href="#SIP-响应消息分类" class="headerlink" title="SIP 响应消息分类"></a>SIP 响应消息分类</h3><table><thead><tr><th>响应类型</th><th>描述</th></tr></thead><tbody><tr><td>1xx 临时响应</td><td></td></tr><tr><td>100 Trying</td><td>服务器正在尝试处理请求。</td></tr><tr><td>180 Ringing</td><td>被叫方正在响铃。</td></tr><tr><td>183 Session Progress</td><td>会话正在进展。</td></tr><tr><td>——–</td><td>—-</td></tr><tr><td>2xx 成功响应</td><td></td></tr><tr><td>200 OK</td><td>请求成功。</td></tr><tr><td>202 Accepted</td><td>请求被接受。</td></tr><tr><td>——–</td><td>—-</td></tr><tr><td>3xx 重定向响应</td><td></td></tr><tr><td>300 Multiple Choices</td><td>多种重定向选项。</td></tr><tr><td>301 Moved Permanently</td><td>资源永久移动。</td></tr><tr><td>302 Moved Temporarily</td><td>资源临时移动。</td></tr><tr><td>305 Use Proxy</td><td>需要使用代理。</td></tr><tr><td>——–</td><td>—-</td></tr><tr><td>4xx 客户端错误响应</td><td></td></tr><tr><td>400 Bad Request</td><td>请求无效。</td></tr><tr><td>401 Unauthorized</td><td>需要认证。</td></tr><tr><td>403 Forbidden</td><td>禁止访问。</td></tr><tr><td>404 Not Found</td><td>未找到资源。</td></tr><tr><td>407 Proxy Authentication Required</td><td>需要代理认证。</td></tr><tr><td>408 Request Timeout</td><td>请求超时。</td></tr><tr><td>486 Busy Here</td><td>被叫方忙碌。</td></tr><tr><td>487 Request Terminated</td><td>请求被终止。</td></tr><tr><td>——–</td><td>—-</td></tr><tr><td>5xx 服务器错误响应</td><td></td></tr><tr><td>500 Server Internal Error</td><td>服务器内部错误。</td></tr><tr><td>501 Not Implemented</td><td>功能未实现。</td></tr><tr><td>503 Service Unavailable</td><td>服务不可用。</td></tr><tr><td>504 Server Timeout</td><td>服务器超时。</td></tr><tr><td>——–</td><td>—-</td></tr><tr><td>6xx 全局错误响应</td><td></td></tr><tr><td>600 Busy Everywhere</td><td>所有被叫方都忙碌。</td></tr><tr><td>603 Decline</td><td>被叫方拒绝。</td></tr><tr><td>604 Does Not Exist Anywhere</td><td>在任何地方都不存在。</td></tr><tr><td>606 Not Acceptable</td><td>请求不可接受。</td></tr></tbody></table><h3 id="SIP-请求消息结构"><a href="#SIP-请求消息结构" class="headerlink" title="SIP 请求消息结构"></a>SIP 请求消息结构</h3><p>SIP 请求消息包含三个主要部分：请求行、头字段、消息体。</p><ol><li><p>请求行（Request Line）</p><ul><li>包含请求方法、请求 URI，以及 SIP 版本号。</li><li>格式：<code>METHOD sip:uri SIP/2.0</code></li><li>示例：<code>INVITE sip:bob@example.com SIP/2.0</code></li></ul></li><li><p>头字段（Headers）</p><ul><li>包含一系列头字段，包含键和值，用于传递各种信息。</li><li>常见的头字段：</li><li><code>Via</code>: 路径追踪，用于记录消息经过的节点。</li><li><code>From</code>: 来源信息，包含显示名称、SIP URI 和标签。</li><li><code>To</code>: 目的地信息，包含显示名称、SIP URI 和标签。</li><li><code>Call-ID</code>: 会话的唯一标识符。</li><li><code>CSeq</code>: 请求序列号，包含请求方法和序列号。</li><li><code>Contact</code>: 用户代理的联系地址。</li><li><code>Max-Forwards</code>: 防止环路，指示消息可以被转发的最大次数。</li><li><code>Content-Type</code>: 消息体的 MIME 类型。</li><li><code>Content-Length</code>: 消息体的长度。</li></ul></li><li><p>消息体（Message Body）</p><ul><li>通常包含会话描述协议（SDP）的内容，用于描述会话的细节。</li><li>根据请求方法和上下文的不同，消息体内容可能不同。</li></ul></li><li><p>示例 SIP 请求消息</p><pre><code class="sip">INVITE sip:bob@example.com SIP/2.0Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bK776asdhdsMax-Forwards: 70From: Alice &lt;sip:alice@atlanta.com&gt;;tag=1928301774To: Bob &lt;sip:bob@example.com&gt;Call-ID: a84b4c76e66710@pc33.atlanta.comCSeq: 314159 INVITEContact: &lt;sip:alice@pc33.atlanta.com&gt;Content-Type: application/sdpContent-Length: 142v=0o=alice 2890844526 2890844526 IN IP4 pc33.atlanta.coms=-c=IN IP4 pc33.atlanta.comt=0 0m=audio 49170 RTP/AVP 0</code></pre></li></ol><h3 id="SIP-设备注册过程"><a href="#SIP-设备注册过程" class="headerlink" title="SIP 设备注册过程"></a>SIP 设备注册过程</h3><p><img src="/2023/11/26/GB28181/register.png"></p><ol><li><p>用户首次试呼时，sip代理向代理服务器发送 REGISTER 注册请求；</p></li><li><p>代理服务器通过后端认证&#x2F;计费中心获知用户信息不在数据库中，便向终端代理回送401 Unauthorized 质询信息，其中包含安全认证所需的令牌；</p></li><li><p>终端代理提示用户输入其标识和密码后，根据安全认证令牌将其加密后，再次用REGISTER 消息报告给代理服务器；</p></li><li><p>代理服务器将REGISTER 消息中的用户信息解密，通过认证&#x2F;计费中心验证其合法后，将该用户信息登记到数据库中，并向终端代理A 返回成功响应消息200 OK。</p></li></ol><h3 id="SIP-设备注销过程"><a href="#SIP-设备注销过程" class="headerlink" title="SIP 设备注销过程"></a>SIP 设备注销过程</h3><p><img src="/2023/11/26/GB28181/logout.png"></p><ol><li><p>SIP代理向SIP服务器发送 Register请求,Expires字段的值为0,表示SIP代理要注销;</p></li><li><p>SIP服务器向 SIP代理发送响应401,并在响应的消息头 WWW_Authenticate字段中给出<br>适合SIP代理的认证体制和参数;</p></li><li><p>SIP代理重新向SIP服务器发送 Register请求,在请求的 Authorization字段给出信任书,<br>包含认证信息,Expires字段的值为0;</p></li><li><p>SIP 服务器对请求进行验证,如果检查出 SIP 代理身份合法,向 SIP 代理发送成功响应<br>200OK,如果身份不合法则发送拒绝服务应答。</p></li></ol><h3 id="客户端发起的点播流程"><a href="#客户端发起的点播流程" class="headerlink" title="客户端发起的点播流程"></a>客户端发起的点播流程</h3><p><img src="/2023/11/26/GB28181/play1.png"></p><h3 id="文档和说明"><a href="#文档和说明" class="headerlink" title="文档和说明"></a>文档和说明</h3><p><a href="https://ossrs.net/lts/zh-cn/assets/files/GBT28181-2016-3f992e659a46001a1c89c05db539a5d3.pdf">GB28181-2016</a></p><p><a href="https://blog.csdn.net/xiehuanbin/article/details/134337873">GB28181 要求的RTP流格式</a></p><h3 id="支持GB28181的优秀开源项目"><a href="#支持GB28181的优秀开源项目" class="headerlink" title="支持GB28181的优秀开源项目"></a>支持GB28181的优秀开源项目</h3><ul><li><p><a href="https://github.com/ZLMediaKit/ZLMediaKit">ZLMediakit</a> + <a href="https://github.com/648540858/wvp-GB28181-pro">wvp-GB28181-pro</a> + <a href="https://github.com/648540858/wvp-pro-assist">wvp-pro-assist</a></p><table><thead><tr><th>服务</th><th>作用</th><th>是否必须</th></tr></thead><tbody><tr><td>WVP-PRO</td><td>实现国标28181的信令以及视频平台相关的功能是</td><td></td></tr><tr><td>ZLMediaKit</td><td>为WVP-PRO提供国标28181的媒体部分的实现，以及各种视频流格式的分发支持是</td><td></td></tr><tr><td>wvp-pro-assist</td><td>wvp的辅助录像程序，也可单独跟zlm一起使用，提供录像控制,录像合并下载接口否（不安装只是影响云端录像功能和国标录像下载）</td><td></td></tr></tbody></table></li><li><p><a href="https://github.com/ossrs/srs">SRS</a></p></li><li><p><a href="https://github.com/panjjo/gosip">gosip</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传输协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抓包</title>
      <link href="/2023/11/26/%E6%8A%93%E5%8C%85/"/>
      <url>/2023/11/26/%E6%8A%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><p>如果说对于网络编程，有什么工具是必会的，我觉得抓包肯定是其中之一了。</p><h2 id="抓包工具的选择"><a href="#抓包工具的选择" class="headerlink" title="抓包工具的选择"></a>抓包工具的选择</h2><h3 id="1-Wireshark"><a href="#1-Wireshark" class="headerlink" title="1. Wireshark"></a>1. Wireshark</h3><p>在具备图形界面的系统上，比如windows，linux发行版ubuntu，opensuse等，我一般直接使用Wireshark直接进行抓包，也方便进行内容的查看。</p><h3 id="2-Tcpdump"><a href="#2-Tcpdump" class="headerlink" title="2. Tcpdump"></a>2. Tcpdump</h3><p>在使用命令行的系统，比如linux服务器，我一般使用Tcpdump进行抓包，无需额外安装，系统一般自带，抓包的到的文件，可以使用Wireshark打开，在图形界面下方便查看内容。</p><h2 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h2><h3 id="Wireshark的安装"><a href="#Wireshark的安装" class="headerlink" title="Wireshark的安装"></a>Wireshark的安装</h3><pre><code class="shell"># 1. 添加wireshark用户组sudo groupadd wireshark# 2. 将dumpcap更改为wireshark用户组sudo chgrp wireshark /usr/bin/dumpcap# 3. 让wireshark用户组有root权限使用dumpcapsudo chmod 4755 /usr/bin/dumpcap# 4. 将需要使用的用户名加入wireshark用户组sudo gpasswd -a $USER wireshark</code></pre><h3 id="tcpdump-的安装"><a href="#tcpdump-的安装" class="headerlink" title="tcpdump 的安装"></a>tcpdump 的安装</h3><p>tcpdump 一般linux都是自带，无需安装，可以这样验证;显示版本信息即是已安装</p><pre><code class="shell">tcpdump --version</code></pre><h2 id="开始抓包"><a href="#开始抓包" class="headerlink" title="开始抓包"></a>开始抓包</h2><h3 id="使用Wireshark"><a href="#使用Wireshark" class="headerlink" title="使用Wireshark"></a>使用Wireshark</h3><p>在28181中我一般只关注sip包和rtp包，所以我一般是直接过滤sip和rtp，可以输入框输入 <code>sip or rtp</code>这样即可，如果设备来源比较多还可以加上ip和端口号的过滤<code>(sip or rtp )and ip.addr==192.168.1.3 and udp.port==5060</code><br>详细的过滤规则可以自行百度，我可以提供一些常用的给大家参考<br><img src="/2023/11/26/%E6%8A%93%E5%8C%85/dump1.png"><br><strong>只过滤SIP：</strong></p><pre><code class="shell">sip</code></pre><p><strong>只获取rtp数据：</strong></p><pre><code class="shell">rtp</code></pre><p><strong>默认方式：</strong></p><pre><code class="shell">sip or rtp</code></pre><p><strong>过滤IP：</strong></p><pre><code class="shell"> sip and ip.addr==192.168.1.3</code></pre><p><strong>过滤端口：</strong></p><pre><code class="shell"> sip and udp.port==5060</code></pre><p>输入命令开启抓包后，此时可以进行音视频播放操作，比如点播，录像回访等，操作完成回到Wireshark点击红色的停止即可，需要保存文件可以点击<code>文件-&gt;导出特定分组</code>导出过滤后的数据，也可以直接<code>文件-&gt;另存为</code>保存未过滤的数据。</p><h3 id="使用tcpdump"><a href="#使用tcpdump" class="headerlink" title="使用tcpdump"></a>使用tcpdump</h3><p>对于服务器抓包，为了得到足够完整的数据，我一般会要求直接抓取网卡数据而不过滤，如下：<br>抓取网卡首先需要获取网卡名，在linux我一般使用<code>ip addr</code>获取网卡信息，如下所示：<br><img src="/2023/11/26/%E6%8A%93%E5%8C%85/dump2.png"></p><pre><code class="shell">sudo tcpdump -i wlp3s0 -w demo.pcap</code></pre><p><img src="/2023/11/26/%E6%8A%93%E5%8C%85/dump3.png"><br>命令行会停留在这个位置，此时可以进行操作，比如点播，录像回放等，操作完成回到命令行使用<code>Ctrl+C</code>结束命令行，在当前目录下得到demo.pcap，将这个文件下载到图形界面操作系统里，即可使用Wireshark查看了<br>更多的操作可以参考： <a href="https://www.cnblogs.com/jiujuan/p/9017495.html">https://www.cnblogs.com/jiujuan/p/9017495.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音视频传输协议</title>
      <link href="/2023/11/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/11/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="传统音视频传输协议"><a href="#传统音视频传输协议" class="headerlink" title="传统音视频传输协议"></a>传统音视频传输协议</h1><h2 id="RTP-Real-time-Transport-Protocol"><a href="#RTP-Real-time-Transport-Protocol" class="headerlink" title="RTP(Real-time Transport Protocol)"></a>RTP(Real-time Transport Protocol)</h2><p>RTP（Real-time Transport Protocol，实时传输协议）是一种在实时应用程序中传输多媒体数据的网络协议。</p><h3 id="协议类型"><a href="#协议类型" class="headerlink" title="协议类型"></a>协议类型</h3><p>传输层协议</p><p>RTP、TCP、UDP都属于<code>传输层</code>协议; RTP也可以认为是<code>介于应用层与传输层之间</code>（5层模型）。<br><img src="/2023/11/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/rtp_1.png"></p><p>从图中可以看出，RTP被划分在<code>传输层</code>，它建立在UDP上。同UDP协议一样，为了实现其实时传输功能，RTP也有固定的封装形式。RTP用来为端到端的实时传输提供时间信息和流同步，但并不保证服务质量。服务质量由RTCP来提供。</p><p>不少人也把RTP归为<code>应用层</code>的一部分，这是从应用开发者的角度来说的。操作系统中的TCP&#x2F;IP等协议栈所提供的是我们最常用的服务，而RTP的实现还是要靠开发者自己。因此从开发的角度来说，RTP的实现和应用层协议的实现没不同，所以可将RTP看成应用层协议。</p><h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p><img src="/2023/11/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/rtp_2.png"></p><table><thead><tr><th>字段</th><th>位数</th><th>说明</th></tr></thead><tbody><tr><td>Version (V)</td><td>2</td><td>表示RTP的版本。当前版本是2。</td></tr><tr><td>Padding (P)</td><td>1</td><td>如果需要填充，则设置此位。</td></tr><tr><td>Extension (X)</td><td>1</td><td>如果使用了扩展头，则设置此位。</td></tr><tr><td>CSRC Count (CC)</td><td>4</td><td>表示后续CSRC标识符的数量。</td></tr><tr><td>Marker (M)</td><td>1</td><td>通常用于标记帧的边界。</td></tr><tr><td>Payload Type (PT)</td><td>7</td><td>指示负载的类型（例如，音频或视频编码）。</td></tr><tr><td>Sequence Number</td><td>16</td><td>用于检测丢包和排序。</td></tr><tr><td>Timestamp</td><td>32</td><td>表示数据生成的时间戳。</td></tr><tr><td>SSRC</td><td>32</td><td>标识同步源的唯一标识符。</td></tr><tr><td>CSRC</td><td>0-15</td><td>0到15个32位字段，用于标识贡献源。</td></tr><tr><td>Header Extension (可选)</td><td>可变</td><td>如果X位被设置，可能包含额外的头部扩展。</td></tr><tr><td>Payload</td><td>可变</td><td>实际的数据部分，可能包含音频、视频或其他媒体数据。</td></tr><tr><td>Padding</td><td>可变</td><td>可选填充，以确保帧的字节对齐。</td></tr></tbody></table><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>视频会议：在视频会议应用中，RTP 用于传输实时音视频数据，并确保顺序和时间同步。</li><li>网络电话 (VoIP)：RTP 负责传输语音数据，并与 SIP（Session Initiation Protocol）等协议配合使用。</li><li>实时流媒体：RTP 在实时流媒体应用中，用于传输音视频内容，并支持对传输质量的监控。</li></ul><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="为何光有-UDP-不够，还需要-RTP"><a href="#为何光有-UDP-不够，还需要-RTP" class="headerlink" title="为何光有 UDP 不够，还需要 RTP"></a>为何光有 UDP 不够，还需要 RTP</h4><p>传输媒体流对网络的要求：IP 网络的不可预知性，数据包可能存在丢失、错序等问题</p><p>因此，接收端需要能正确还原音频或视频信号，需要：</p><ol><li>检测出错序，并保持采样和播放之间的同步关系（解决方案：时间戳）</li><li>需要在接收端能够检测出分组丢失（解决方案：序列号）</li></ol><p>那就只有用 RTP 了，UDP 没这功能</p><h2 id="RTCP-Real-time-Transport-Control-Protocol"><a href="#RTCP-Real-time-Transport-Control-Protocol" class="headerlink" title="RTCP(Real-time Transport Control Protocol)"></a>RTCP(Real-time Transport Control Protocol)</h2><p>传输协议</p><p> <code>RTCP</code>为<code>RTP</code>提供<code>流量控制</code>和<code>拥塞控制</code>。在RTP会话期间,各参与者周期性地传送RTCP包。</p><p> RTCP包中含有已发送的<strong>数据包的数量</strong>、<strong>丢失的数据包的数量</strong>等统计资料.因此,服务器可以利用这些信息动态地改变传输速率，甚至改变有效载荷类型。</p><p> RTP和RTCP配合使用，它们能以有效的反馈和最小的开销使传输效率最佳化。因而特别适合传送网上的实时数据。 </p><h2 id="RTSP（Real-time-Streaming-Protocol）"><a href="#RTSP（Real-time-Streaming-Protocol）" class="headerlink" title="RTSP（Real-time Streaming Protocol）"></a>RTSP（Real-time Streaming Protocol）</h2><h3 id="协议类型-1"><a href="#协议类型-1" class="headerlink" title="协议类型"></a>协议类型</h3><p>应用层协议</p><p>RTSP在体系结构上位于应用层，在RTP和RTCP之上, 它使用<code>TCP</code>或<code>RTP</code>完成数据传输。</p><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>当应用程序提供<code>RTSP协议</code>建立一个<code>RTP会话</code>时，应用程序将确定一对目的传输地址（一个网络地址和<code>两个端口号</code>），其中两个端口号中的<strong>偶数端口是分配给RTP进行裸码流数据传输</strong>的，<strong>奇数端口则是分配给RTCP进行传输控制</strong>的。</p><p>RTP的发送过程如下：</p><ol><li>从上层接收流媒体信息码流（如H.264），封装成RTP数据包；RTCP从上层接收控制信息，封装成RTCP控制包。</li><li>将RTP 数据包发往UDP端口对中偶数端口；RTCP将RTCP控制包发往UDP端口对中的接收端口。</li></ol><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>实时流媒体应用：<br>RTSP被广泛用于实时流媒体应用，包括在线广播、网络摄像头、监控摄像头、IPTV、视频会议、VoIP等。这些应用需要灵活控制流媒体会话，例如播放、暂停、停止、快进、快退等。</li><li><strong>网络摄像头和监控系统（安防领域）</strong>：<br>RTSP在网络摄像头和监控系统中应用广泛。它允许客户端在需要时连接到摄像头，开始流媒体传输，实时查看视频监控，并可以在不同时间点暂停或停止传输。</li><li>IPTV（互联网电视）：<br>RTSP在IPTV中用于控制和传输电视流。用户可以通过RTSP控制收看特定的频道、录制节目、调节播放参数等。RTSP的灵活性使其能够处理按需点播和直播内容。</li><li>多媒体内容点播：<br>在多媒体内容点播服务中，RTSP用于提供类似VCR的功能，包括快进、快退、跳转到特定位置等。它支持按需内容流传输和控制。</li><li>视频会议：<br>RTSP可以用于视频会议系统，提供会议中音频和视频流的控制。它允许用户加入会议、离开会议、调整传输参数等。</li><li>远程教育和在线学习：<br>RTSP在远程教育和在线学习环境中用于实时流媒体传输，帮助教师和学生进行互动。它可以用于播放课程视频、实时课堂、教学演示等。</li><li>企业内网广播：<br>企业可以使用RTSP进行内部广播，例如公司公告、培训课程、员工会议等。RTSP的灵活控制能力使其适用于内部流媒体传输。</li></ol><h3 id="其他问题-1"><a href="#其他问题-1" class="headerlink" title="其他问题"></a>其他问题</h3><h4 id="RTSP有握手过程吗？"><a href="#RTSP有握手过程吗？" class="headerlink" title="RTSP有握手过程吗？"></a>RTSP有握手过程吗？</h4><p>RTSP（Real-Time Streaming Protocol，实时流媒体传输协议）没有传统意义上的握手过程，如TCP的三次握手或类似于RTMP的握手机制。RTSP主要用于控制多媒体流的传输，提供了类似于HTTP的客户端-服务器交互机制，允许客户端发出控制命令来启动、停止或操纵媒体流。</p><p>尽管没有典型的握手过程，但RTSP的会话控制过程中涉及建立和维护会话，这包括发送初始请求（如SETUP）来创建一个会话，并使用会话标识符（Session ID）来跟踪会话状态。这一过程类似于HTTP的请求-响应模式，以下是一些常见的RTSP请求：</p><ol><li>OPTIONS：用于查询服务器支持的RTSP方法。</li><li>DESCRIBE：请求流媒体描述信息（如SDP，Session Description Protocol）。</li><li>SETUP：请求在特定的传输通道（如RTP&#x2F;UDP）上建立会话。</li><li>PLAY：启动媒体流的播放。</li><li>PAUSE：暂停媒体流的播放。</li><li>TEARDOWN：结束会话，释放资源。</li></ol><p>在这个过程中，RTSP会通过Session ID来维持会话的状态和唯一性，而不是通过类似握手的同步机制。RTSP的会话是无状态的，这意味着每个请求需要携带足够的上下文信息，以便服务器能够理解客户端的意图。</p><h2 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h2><h3 id="协议类型-2"><a href="#协议类型-2" class="headerlink" title="协议类型"></a>协议类型</h3><p>应用层协议</p><h3 id="工作机制-1"><a href="#工作机制-1" class="headerlink" title="工作机制"></a>工作机制</h3><p><img src="/2023/11/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/rtmp_1.png"></p><p>RTMP协议规定，播放一个流媒体有两个前提步骤：  </p><ol><li>建立一个网络连接（NetConnection）；  </li><li>建立一个网络流（NetStream）。</li></ol><p>其中，网络连接代表服务器端应用程序和客户端之间基础的连通关系。网络流代表了发送多媒体数据的通道。服务器和客户端之间只能建立一个网络连接，但是基于该连接可以创建很多网络流。</p><p>播放一个RTMP协议的流媒体需要经过以下几个步骤：握手，建立连接，建立流，播放。RTMP连接都是以握手作为开始的。建立连接阶段用于建立客户端与服务器之间的“网络连接”；建立流阶段用于建立客户端与服务器之间的“网络流”；播放阶段用于传输视音频数据。</p><p>握手过程：</p><ol><li>客户端握手 C0：<br>客户端发送 C0 消息，它包含协议版本（通常是 3）。</li><li>服务器响应 S0：<br>服务器接收 C0 后，发送 S0 消息，包含协议版本，通常与客户端的协议版本相同。</li><li>客户端握手 C1：<br>客户端发送 C1 消息，包含一个 1536 字节的随机数据和一个 4 字节的时间戳。这段随机数据用于后续的握手验证。</li><li>服务器响应 S1：<br>服务器接收 C1 后，发送 S1 消息。该消息也包含 1536 字节的随机数据和一个 4 字节的时间戳。服务器的随机数据是不同于客户端的，用于确保握手的随机性。</li><li>客户端握手 C2：<br>客户端发送 C2 消息，它包含 1536 字节的数据，这是之前服务器 S1 消息中的随机数据。通过这种方式，客户端表明它收到了服务器的响应，并且验证了握手的一致性。</li><li>服务器确认 S2：<br>服务器接收 C2 后，发送 S2 消息，该消息包含 1536 字节的数据，与客户端 C1 消息中的随机数据相同。通过这种方式，服务器验证了客户端的响应。</li></ol><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>直播流媒体：<br>RTMP 是一种流行的流媒体协议，广泛用于直播视频、音频流和实时聊天应用程序。其低延迟特性使其成为直播场景的热门选择，尤其是网络视频平台和直播节目。</li><li>实时互动：<br>由于 RTMP 的低延迟和可靠性，它在实时互动应用中被广泛使用，如在线游戏直播、视频通话、在线教学和网络研讨会。</li><li>内容分发网络 (CDN)：<br>RTMP 是许多内容分发网络用来在服务器之间传输实时流媒体的协议。CDN 使用 RTMP 将直播流分发到边缘节点，并通过其他协议（如 HLS 或 DASH）向客户端分发内容。</li><li>广播行业：<br>在广播行业，RTMP 仍然是流行的协议，用于将现场视频源传输到中央服务器，然后广播或流式传输给观众。</li><li>媒体制作与管理：<br>RTMP 通常用于将实时流媒体从摄像机或媒体制作工作站发送到视频制作软件和平台。这使得现场拍摄和实时编辑成为可能。</li><li>在线教育和网络研讨会：<br>RTMP 被用于实时传输视频和音频流，用于在线教育和网络研讨会。它的低延迟特性使其适合这种需要即时互动的场景。</li><li>社交媒体直播：<br>一些社交媒体平台支持 RTMP 协议，允许用户使用直播软件或硬件进行实时直播。</li></ol><h3 id="其他问题-2"><a href="#其他问题-2" class="headerlink" title="其他问题"></a>其他问题</h3><h2 id="HTTP-FLV-HTTP-Flash-Video"><a href="#HTTP-FLV-HTTP-Flash-Video" class="headerlink" title="HTTP-FLV (HTTP-Flash Video)"></a>HTTP-FLV (HTTP-Flash Video)</h2><h3 id="协议类型-3"><a href="#协议类型-3" class="headerlink" title="协议类型"></a>协议类型</h3><p>应用层协议<br>基于<code>HTTP</code>协议</p><h3 id="工作机制-2"><a href="#工作机制-2" class="headerlink" title="工作机制"></a>工作机制</h3><p>HTTP 协议中有个约定：<code>content-length</code>字段，http 的 body 部分的长度。</p><ul><li>服务器回复 http 请求的时候如果有这个字段，客户端就接收这个长度的数据然后就认为数据传输完成了。</li><li>如果服务器回复 http 请求中没有这个字段，客户端就一直接收数据，直到服务器跟客户端的 socket 连接断开。 (流式传输)</li></ul><p>http-flv 直播就是利用第二个原理，服务器回复客户端请求的时候不加 content-length 字段，在回复了 http 内容之后，紧接着发送 flv 数据，客户端就一直接收数据了。</p><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><p>网络直播：<br>HTTP-FLV 适合实时网络直播，因为它可以在客户端与服务器之间保持持续的连接，并即时传输数据。这种机制有助于减少延迟，实现实时直播。</p></li><li><p>视频点播：<br>HTTP-FLV 也可以用于点播内容的播放。通过 HTTP 的灵活性，服务器可以根据客户端的需求提供流媒体数据。</p></li><li><p>Web 视频播放：<br>HTTP-FLV 的兼容性使其适用于 Web 上的嵌入式视频播放，特别是在 Flash 时代流行的各种嵌入式视频播放器。</p></li></ol><h3 id="其他问题-3"><a href="#其他问题-3" class="headerlink" title="其他问题"></a>其他问题</h3><h2 id="HLS-HTTP-Live-Streaming"><a href="#HLS-HTTP-Live-Streaming" class="headerlink" title="HLS (HTTP Live Streaming)"></a>HLS (HTTP Live Streaming)</h2><p>HLS 是一种基于 HTTP 的流媒体传输协议，最初由苹果公司开发，现在是流媒体领域的一个广泛采用的协议。下面是对 HLS 协议的详解，包括其类型、工作机制、应用场景和其他常见问题。</p><h3 id="协议类型-4"><a href="#协议类型-4" class="headerlink" title="协议类型"></a>协议类型</h3><p>应用层协议<br>基于<code>HTTP</code>协议</p><h3 id="工作机制-3"><a href="#工作机制-3" class="headerlink" title="工作机制"></a>工作机制</h3><p>HLS 的核心机制是将音视频内容分段，然后通过 HTTP 请求进行传输和播放。其工作流程大致如下：</p><ol><li>内容分段：<br>源视频文件或直播流被切割成较小的段（segments），每个段通常几秒钟长，通常为 10 秒。</li><li>创建索引文件：<br>同时，生成一个索引文件（或称为清单文件、播放列表），通常是 .m3u8 文件。这个索引文件列出所有视频段的 URL，以及其他元数据，如时间戳、码率、分辨率等。</li><li>客户端播放：<br>客户端（通常是视频播放器或媒体播放软件）首先请求索引文件，然后根据索引文件中的信息，按顺序请求视频段，并进行播放。</li><li>可自适应的质量：<br>HLS 支持多种比特率和分辨率的视频段，客户端可以根据网络状况选择最佳的段以实现自适应流媒体（Adaptive Bitrate Streaming）。这种特性使 HLS 在不同带宽下都能保持较好的播放体验。</li><li>缓存和 CDN 支持：<br>由于 HLS 基于 HTTP 协议，网络基础设施中的缓存和 CDN（内容分发网络）可以有效地支持 HLS，从而提高流媒体传输的效率和可靠性。</li></ol><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>直播和广播：<br>HLS 被广泛用于直播活动、赛事转播等。</li><li>点播和回放：<br>HLS 也可用于点播内容或流媒体服务中的内容回放。</li><li>多平台兼容性：<br>由于 HLS 的 HTTP 基础，它在各种平台和设备上都可以使用，特别是在苹果生态系统中广泛支持。</li></ol><h3 id="其他问题-4"><a href="#其他问题-4" class="headerlink" title="其他问题"></a>其他问题</h3><h1 id="几种传统协议的不同点"><a href="#几种传统协议的不同点" class="headerlink" title="几种传统协议的不同点"></a>几种传统协议的不同点</h1><ol><li><p>HTTP将所有的数据作为文件做处理。http协议不是流媒体协议。</p></li><li><p>RTMP和RTSP协议是流媒体协议。</p></li><li><p>RTMP协议是Adobe的私有协议,未完全公开，RTSP协议和HTTP协议是共有协议，并有专门机构做维护。</p></li><li><p>RTMP协议一般传输的是flv，f4v格式流，RTSP协议一般传输的是ts, h264, h265, mp4格式的流,HTTP没有特定的流。</p></li><li><p>RTSP传输一般需要2-3个通道，命令和数据通道分离，HTTP和RTMP一般在TCP一个通道上传输命令和数据。RTSP实时流协议 作为一个应用层协议，RTSP提供了一个可供扩展的框架，它的意义在于使得实时流媒体数据的受控和点播变得可能。总的说来，RTSP是一个流媒体表示协议，主要用来控制具有实时特性的数据发送，但它本身并不传输数据，而是必须依赖于下层传输协议所提供的某些服务。RTSP可以对流媒体提供诸如播放、暂停、快进等操作，它负责定义具体的控制消息、操作方法、状态码等，此外还描述了与RTP间的交互操作（RFC2326）。</p></li></ol><h1 id="新兴流媒体协议"><a href="#新兴流媒体协议" class="headerlink" title="新兴流媒体协议"></a>新兴流媒体协议</h1><p>基于浏览器插件的老牌直播协议RTMP终于寿钟正寝，虽然各大CDN厂商还在坚持使用RTMP协议，但是也难逃被各大浏览器厂商淘汰的趋势和事实；<strong>RTSP主要应用于安防领域</strong>，而随之兴起流行的HTTP-FLV、HLS直播技术也因为延迟大，平台依赖性强，网络自适应差等问题饱受诟病。</p><p>而新兴的WEBRTC协议是专门基于网页js设计的即时音视频通信协议，其无插件的直播性能完全能满足流媒体直播的要求，而新兴的互联网90%的浏览流量都在浏览器上，所以WEBRTC是目前互联网直播协议中一种比较优质是选择。</p><h2 id="GB28181"><a href="#GB28181" class="headerlink" title="GB28181"></a>GB28181</h2><p>见 GB28181 专栏</p><h2 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h2><p>见 WebRTC 专栏</p>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 传输协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg使用说明</title>
      <link href="/2023/10/14/FFmpeg%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2023/10/14/FFmpeg%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="FFmpeg使用说明"><a href="#FFmpeg使用说明" class="headerlink" title="FFmpeg使用说明"></a>FFmpeg使用说明</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="封装格式-编码格式-协议"><a href="#封装格式-编码格式-协议" class="headerlink" title="封装格式 编码格式 协议"></a>封装格式 编码格式 协议</h3><p><img src="/2023/10/14/FFmpeg%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/avpack.png"></p><ul><li>封装格式：MP4</li><li>编码格式：H.264</li><li>协议：RTMP</li></ul><h3 id="音／视频流"><a href="#音／视频流" class="headerlink" title="音／视频流"></a>音／视频流</h3><p>在音视频领域，我们把一路音／视频称为一路流。如我们小时候经常使用VCD看港片，在里边可以选择粤语或国语声音，其实就是CD视频文件中存放了两路音频流，用户可以选择其中一路进行播放。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>我们一般把 MP4､ FLV、MOV等文件格式称之为容器。也就是在这些常用格式文件中，可以存放多路音视频文件。以 MP4 为例，就可以存放一路视频流，多路音频流，多路字幕流。</p><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>channel是音频中的概念，称之为声道。在一路音频流中，可以有单声道，双声道或立体声。</p><h3 id="视频解码"><a href="#视频解码" class="headerlink" title="视频解码"></a>视频解码</h3><p>视频解码是将视频压缩编码后的数据流（例如 H.264、H.265 等）解码成原始的像素数据（通常是 YUV 格式），以便于显示或进一步处理的过程。在视频编码中，为了减小文件大小和提高传输效率，视频数据经过压缩编码处理，即将原始的视频数据压缩成较小的码流。而视频解码则是将这些压缩后的数据流还原成原始的视频像素数据，以便于播放或后续处理。</p><ul><li><p>硬解码：</p><p>  硬解码是利用专用的硬件解码器（通常是 GPU）来解码音视频流。硬解码器通常集成在显卡或其他专用的硬件设备中，能够高效地处理音视频解码任务。硬解码器通常支持多种音视频编解码器，并能够通过硬件加速来实现高效的解码性能。由于硬解码利用专用的硬件资源，因此能够在低功耗的情况下实现高效的解码，适用于移动设备、嵌入式系统和高性能计算环境等场景。</p></li><li><p>软解码：</p><p>  软解码是利用通用的处理器（如 CPU）来解码音视频流。软解码器是通过软件实现的音视频解码算法，不依赖于专用的硬件设备。软解码器通常运行在通用的计算机系统上，利用 CPU 的计算能力来进行音视频解码。软解码虽然不具备硬解码那样的硬件加速能力，但能够在普通的计算机系统上运行，并且通常具有更好的兼容性和灵活性。软解码适用于各种计算环境，但在解码大尺寸、高码率的高清视频时可能会受到性能限制。</p></li><li><p>H.265 相比于 H.264 具有更高的压缩效率和更高的视频质量，但也需要更多的计算资源来进行编码。因此，在选择编码标准时，需要根据具体的应用场景和需求权衡各种因素。</p></li></ul><h3 id="DTS与PTS"><a href="#DTS与PTS" class="headerlink" title="DTS与PTS"></a>DTS与PTS</h3><p>DTS（Decoding Time Stamp）和 PTS（Presentation Time Stamp）是用于管理音视频流中时间信息的两种时间戳。</p><ol><li><p>DTS（解码时间戳）：</p><ul><li>DTS 表示数据在解码器中解码的时间点。它指示了数据在解码器中被解码的时间，即解码器何时开始处理数据。</li><li>对于视频流，DTS 表示视频帧被解码的时间点。</li><li>对于音频流，DTS 表示音频样本被解码的时间点。</li></ul></li><li><p>PTS（显示时间戳）：</p><ul><li>PTS 表示数据在播放器中显示的时间点。它指示了数据在播放器中何时被呈现给用户。</li><li>对于视频流，PTS 表示视频帧被显示的时间点。</li><li>对于音频流，PTS 表示音频样本被播放的时间点。</li></ul></li></ol><p>通常情况下，音视频数据在传输过程中可能会发生延迟或者重排列，DTS 和 PTS 用于确保数据能够在正确的时间点被解码和显示，以保证音视频同步以及顺畅播放。PTS 必须始终晚于或等于 DTS，以确保数据按正确的顺序呈现。</p><h3 id="常见分辨率"><a href="#常见分辨率" class="headerlink" title="常见分辨率"></a>常见分辨率</h3><p>3840<em>2160 (4K)<br>2560</em>1440 (2K)<br>1920<em>1080 (1080P 高清 200万像素)<br>1280</em>720 (720P)<br>640*360 (360P)</p><p>除了1080P还有1080I<br>这里的P和I分别表示逐行扫描与隔行扫描<br>电视一般用I 网络视频，视频文件用P</p><h3 id="dpi"><a href="#dpi" class="headerlink" title="dpi"></a>dpi</h3><p>每英寸像素</p><h3 id="色彩空间模型"><a href="#色彩空间模型" class="headerlink" title="色彩空间模型"></a>色彩空间模型</h3><p>记录像素点色彩数据的方式<br>有RGB，YUV420，YUV422，YUV444，HSV，CMYK</p><p>网络视频一般使用<code>YUV420</code><br>虽然颜色有所失真，但是数据量少</p><h3 id="帧率"><a href="#帧率" class="headerlink" title="帧率"></a>帧率</h3><p>一秒的视频帧数（FPS）</p><p>网络视频一般为25FPS、30FPS</p><p>过高的帧率在感官上不会有所提升，反而影响性能</p><h3 id="码率"><a href="#码率" class="headerlink" title="码率"></a>码率</h3><ul><li>一秒的数据量大小，单位Mbps</li><li>码率的设置是为了限制数据量过大，防止客户端带宽不足而产生卡顿</li><li>编码器会根据最大码率对视频进行有损压缩</li></ul><h3 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h3><blockquote><p>GOP一般是H.264，H.265这些编码格式才有的概念<br>GOP（Group of Pictures）是视频编码中的一个重要概念，它定义了一组连续的视频帧，这些帧之间存在特定的时间关系，用于视频压缩编码和解码。</p></blockquote><p>一个 GOP 包含以下类型的帧：</p><ol><li><p>I帧（Intra-coded Frame）：</p><p> I帧是一个关键帧，它是完整的帧，不依赖于其他帧进行解码。在编码器中，I帧通过对整个帧进行压缩编码，以保留最大的图像信息，从而提供了视频的基础图像。解码器可以利用I帧进行随机访问和解码。</p></li><li><p>P帧（Predictive-coded Frame）：</p><p> P帧是通过对前向预测（从前面的I帧或P帧中预测）进行压缩编码得到的。它只包含当前帧和之前帧之间的差异数据，而不包含整个图像数据。P帧可以通过参考之前的I帧或P帧来解码。</p></li><li><p>B帧（Bidirectional-coded Frame）：</p><p> B帧是通过对前向和后向预测（从前面的I帧或P帧以及后面的P帧中预测）进行压缩编码得到的。它包含当前帧和前后帧之间的差异数据，能够进一步提高视频的压缩比和质量。B帧需要参考前后的I帧或P帧来解码。</p><p> 由于需要根据后向的帧进行推理，所以在<code>直播流等场景下，是不产生B帧的</code>，使直播流畅。</p></li></ol><p>GOP 的结构通常如下所示：</p><pre><code class="css">I P P P B B P P P B B P P ...</code></pre><p>其中，每个GOP以一个I帧开始，后面跟随一系列的P帧和B帧。GOP的长度（即包含的帧数）可以根据具体的编码设置进行调整，常见的GOP长度为 15、30、60 等。较长的GOP长度可以提高压缩效率，但会增加视频的延迟和解码复杂度；而较短的GOP长度可以提高视频的抗干扰能力和随机访问性能，但会降低压缩效率。因此，在实际应用中，需要根据视频的特性和需求来选择合适的GOP长度。</p><ul><li><p>在线播放场景  </p><ul><li>一般不必关心GOP  </li><li>为了防止未加载完跳转卡顿时间长等问题–&gt;<code>因为两个I帧间隔过长</code>  </li><li>可以将GOP设置为帧率的4-5倍</li></ul></li><li><p>直播场景</p><ul><li>流媒体服务器设置缓存I帧</li><li>GOP设置为帧率的1-2倍</li><li>禁止生成B帧</li></ul></li></ul><h3 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h3><ul><li><p>具体的编码过程由编码格式决定</p></li><li><p>每个编码格式对应不同的压缩&#x2F;解压缩算法</p></li><li><p>每个编码格式对应不同的编码器&#x2F;解码器</p></li><li><p>客户端没有对应编码格式的解码器，是播不出视频的</p></li><li><p>只有对视频文件大小产生影响的参数才会作用与<code>编码阶段</code>，如码率，最大码率等，限制文件的大小，可能会发生有损压缩</p></li><li><p>分辨率，帧率等参数是由<code>转码程序</code>完成的，编码器不支持这些修改</p></li></ul><h3 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h3><ul><li>当前一刻的声音样本</li><li>真实声音虽然是连续的，但是在计算机中，声音是离散且均匀的声音样本</li></ul><h3 id="位深度"><a href="#位深度" class="headerlink" title="位深度"></a>位深度</h3><p>音频的位深度是指用于表示<code>每个采样值的比特数</code>。它决定了每个采样值可以表示的幅度范围，也影响了音频的动态范围和信噪比。</p><p>常见的位深度包括 8 位、16 位、24 位和 32 位等。较低的位深度会限制音频信号的动态范围，可能导致信号的失真和噪声的增加，特别是在低音量或者动态范围较大的场景下。相反，较高的位深度可以提供更广阔的动态范围和更低的噪声水平，因此产生更高质量的音频。</p><p>一般来说，16 位的位深度已经能够满足大多数音频应用的要求，包括 CD 音质和广播。24 位的位深度被认为是高保真音频的标准，它提供了更高的动态范围和更低的噪声水平，因此在专业录音和音乐制作中被广泛使用。32 位的位深度通常用于一些特殊需求，如音频处理中的临时计算过程，但在存储和传输过程中会转换为较低的位深度。</p><h3 id="采样率"><a href="#采样率" class="headerlink" title="采样率"></a>采样率</h3><p>采样率（也称为采样频率）是指在一段时间内对模拟信号进行采样的频率，通常用赫兹（Hz）来表示。在数字音频处理中，采样率决定了每秒钟采集的采样数，它是一个非常重要的参数，直接影响到数字音频的质量和精度。</p><p>常见的音频采样率包括：</p><ol><li>8 kHz：音频通话或监控录音。</li><li>22.05 kHz、24 kHz：FM调频广播。</li><li>44.1 kHz：这是最常用的音频采样率之一，用于 CD 音质。在音频 CD 中，每秒钟采集 44100 个样本。</li><li>48 kHz：这是另一个常见的音频采样率，用于广播、电影和多媒体制作等领域。</li><li>96 kHz、192 kHz：这些是高保真音频的采样率，用于专业音频录制和制作，它们提供了更高的音频质量和更广阔的频率范围。</li></ol><p>较高的采样率可以提供更高的音频质量和更广泛的频率响应范围，因为它们能够更准确地捕捉音频信号的细节。然而，高采样率也会导致更大的数据量和更高的处理需求。</p><p>选择合适的采样率取决于具体的应用需求。对于一般的音频播放和日常录制，通常使用标准的采样率（如 44.1 kHz 或 48 kHz）即可满足需求。而在专业音频制作和高保真音频领域，可能会选择更高的采样率以获得更高的音频质量。</p><h3 id="音频帧"><a href="#音频帧" class="headerlink" title="音频帧"></a>音频帧</h3><p>将一小段音频采样数据打包在一起</p><p>具体时间跨度由编码格式决定</p><h3 id="音频码率"><a href="#音频码率" class="headerlink" title="音频码率"></a>音频码率</h3><p>一般网络音频直播，音频文件，码率在128Kbps即可</p><h3 id="常用音视频编码标准"><a href="#常用音视频编码标准" class="headerlink" title="常用音视频编码标准"></a>常用音视频编码标准</h3><table><thead><tr><th>名称</th><th>推出机构</th><th>推出时间</th><th>目前使用领域</th></tr></thead><tbody><tr><td>HEVC（H.265）</td><td>MPEG&#x2F;ITU-T</td><td>2013</td><td>新王</td></tr><tr><td>H.264</td><td>MPEG&#x2F;ITU-T</td><td>2003</td><td>各个领域</td></tr><tr><td>MPEG4</td><td>MPEG</td><td>2001</td><td>不温不火</td></tr><tr><td>MPEG2</td><td>MPEG</td><td>1994</td><td>数字电视</td></tr><tr><td>VP9</td><td>Google</td><td>2013</td><td>不温不火</td></tr><tr><td>VP8</td><td>Google</td><td>2008</td><td>不普及</td></tr><tr><td>VC-1</td><td>Microsoft Inc.</td><td>2006</td><td>微软平台</td></tr></tbody></table><table><thead><tr><th>名称</th><th>推出机构</th><th>推出时间</th><th>目前使用领域</th><th>损失</th></tr></thead><tbody><tr><td>AAC</td><td>MPEG</td><td>1997</td><td>各个领域（新）</td><td>有损</td></tr><tr><td>MP3</td><td>MPEG</td><td>1993</td><td>各个领域（旧）</td><td>有损</td></tr><tr><td>FLAC</td><td>Josh Coalson</td><td>2001</td><td>数字音乐市场</td><td>无损</td></tr><tr><td>WAV</td><td>Microsoft 和 IBM</td><td>1991</td><td>音频处理和专业音乐制作领域</td><td>无损</td></tr></tbody></table><h3 id="常用协议与编码汇总"><a href="#常用协议与编码汇总" class="headerlink" title="常用协议与编码汇总"></a>常用协议与编码汇总</h3><p>见pdf</p><h3 id="OpenGL"><a href="#OpenGL" class="headerlink" title="OpenGL"></a>OpenGL</h3><p>OpenGL（Open Graphics Library）是一种用于渲染 2D 和 3D 矢量图形的跨平台图形 API（应用程序编程接口）。它允许开发人员通过编程方式创建高性能的图形应用程序，如视频游戏、模拟器、CAD 软件等。</p><p>OpenGL 由一个庞大的函数库组成，开发人员可以使用这些函数来执行各种图形操作，包括顶点操作、纹理映射、光照、投影等。它提供了一系列功能，使开发人员能够利用计算机的图形硬件来加速图形处理。OpenGL 是一种底层的图形 API，它提供了对图形硬件的直接访问，因此可以在不同的操作系统和硬件平台上实现高性能的图形渲染。</p><p>由于其跨平台特性和高性能，OpenGL 在计算机图形领域得到了广泛的应用。它被用于开发各种类型的图形应用程序，包括游戏、CAD 软件、虚拟现实应用程序、科学可视化工具等。OpenGL 是一个开放标准，由 Khronos Group 维护和推动发展，因此在不同的操作系统和硬件平台上都有相应的实现版本。</p><h3 id="OpenCV"><a href="#OpenCV" class="headerlink" title="OpenCV"></a>OpenCV</h3><p>OpenCV（Open Source Computer Vision Library）是一个开源的计算机视觉和图像处理库，提供了丰富的函数和工具，用于处理图像和视频数据。它由一系列 C++、Python、Java 等语言的函数库和模块组成，可以在各种平台上运行，包括 Windows、Linux、macOS 等。</p><p>OpenCV 提供了丰富的图像处理和计算机视觉功能，包括但不限于：</p><ol><li>图像读取和保存：支持读取和保存多种格式的图像文件，如 JPEG、PNG、BMP 等。</li><li>图像处理：包括图像变换、颜色空间转换、滤波、边缘检测、形态学操作等。</li><li>特征检测和描述：提供了多种特征检测和描述算法，如 Harris 角点检测、SIFT、SURF、ORB 等。</li><li>目标检测和跟踪：包括 Haar 特征、HOG 特征、卷积神经网络（CNN）等目标检测算法。</li><li>视频分析：提供了视频读取、视频流处理、光流估计、运动检测等功能。</li><li>机器学习：提供了一些基本的机器学习算法和工具，如支持向量机（SVM）、K近邻（KNN）等。</li></ol><p>OpenCV 是一个非常强大和广泛应用的图像处理库，被广泛应用于计算机视觉、图像处理、机器人、自动驾驶等领域。它被许多研究人员、工程师和开发者使用，并在学术界和工业界都有着广泛的影响。</p><h3 id="直播流常用协议"><a href="#直播流常用协议" class="headerlink" title="直播流常用协议"></a>直播流常用协议</h3><ol><li><p>RTMP、HTTP-FLV</p><ul><li>RTMP：<ul><li>一般用于直播源推流，直播系统内直播流数据传递。</li><li>浏览器摒弃了Flash播放器，且据说高并发下rtmp会有问题，所以不用于拉流。</li><li>建立在TCP之上。</li><li>延迟低：1-3s。</li><li>变种RTMPT、RTMPS等。</li></ul></li><li>HTTP-FLV：一般用于客户端直播流观看。<ul><li>网页需要引入flv.js才可播放该类型流。</li><li>延迟比RTMP略高。</li></ul></li><li>二者都是在FLV封装格式基础上的。</li><li>现在比较流行的方案是，直播源推流是RTMP协议，直播拉流观看是HTTP-FLV协议。</li></ul></li><li><p>HLS（HTTP Live Streaming）</p><ul><li><p>HLS协议一般只用作拉流观看，但是从严格意义上讲，HLS协议并不是流式协议。</p></li><li><p>它工作原理很简单，就是通过HTTP协议下载静态文件。</p></li><li><p>不同的是，HLS协议的文件由两部分组成，一是多个只有几秒长度的.ts碎片视频文件，另一个是记录这些视频文件地址的.m3u8索引文件，且这些静态文件都是直接写入磁盘的。</p></li><li><p>更具体的说，HLS观看地址是以http:&#x2F;&#x2F;开头、.m3u8结尾的，实际上这个地址就是索引文件的地址，客户端获取到索引文件后，就可以下载对应的碎片视频文件并开始播放了。</p></li><li><p>由于HLS协议实际上是通过HTTP协议请求文件的，且HLS相关文件是直接写入磁盘的，所以并不需要特殊的流媒体服务软件，使用Nginx等HTTP服务就可以了。</p></li><li><p>点播的场景下，也就是普通网络视频观看的场景下。.m3u8索引文件会记录所有的碎片视频文件地址，HLS在点播的场景下，优势是更加明显的。HLS协议的点播视频，会比.mp4、.flv的视频更快地播放出来，且在加载中跳转视频也会更加顺滑。</p></li><li><p>HLS协议在直播的场景下是没什么优势的。虽然HLS协议的直播流也可以适配很多播放场景，但是由于需要生成静态文件，直播延迟很大，大概在5-30秒左右，使用直播CDN的话，由于边缘节点同步等问题，直播延迟甚至可能会达到1分钟左右。</p></li><li><p>当然HLS协议也有一定的优势，在直播时移，也就是直播转点播，或者录播，也就是点播转直播的场景， 理论上只需要修改索引文件就可以了。</p></li></ul></li><li><p>WebRTC</p><ul><li><p>WebRTC协议其实并不是为了直播场景而设计的，WebRTC是一种点对点的视频&#x2F;语音通话协议。</p></li><li><p>由于WebRTC是基于UDP的，建立通信后，会不断以流式发送数据，所以延迟会比RTMP还要低。</p></li><li><p>在一些交互性较高的直播场景，如直播带货等场景，会使用WebRTC作为推流和观看协议 WebRTC的延迟理论上可以达到1秒内。</p></li></ul></li><li><p>RTSP</p><ul><li><p>RTSP一般不用作直播场景，RTSP一般用作摄像头、监控等硬件设备的实时视频流观看与推送上。</p></li><li><p>尽管RTSP协议也支持推流&#x2F;拉流，且支持TCP、UDP切换以及其他诸多优点。但是泛用性不足，特别是现在的浏览器都不支持RTSP的播放。</p></li></ul></li></ol><h3 id="点播封装格式"><a href="#点播封装格式" class="headerlink" title="点播封装格式"></a>点播封装格式</h3><p>MP4：适合在线播放视频不是主营业务的网站系统<br>FLV：适合短视频，小文件偏多的网站系统<br>HLS：适合长视频，大文件偏多的网站系统</p><h3 id="音频重采样"><a href="#音频重采样" class="headerlink" title="音频重采样"></a>音频重采样</h3><p>音频重采样是指将音频信号从一个采样率转换为另一个采样率的过程。采样率是指每秒对音频信号进行采样的次数，通常以赫兹（Hz）为单位。音频重采样可能涉及改变采样率、通道数、位深度等参数。</p><p>音频重采样可能需要的几种情况包括：</p><ul><li><p><strong>播放器与音频设备之间的不匹配</strong>：音频设备通常有其支持的固定采样率，如果要播放的音频数据的采样率与设备不匹配，就需要对音频数据进行重采样以适应设备的要求。</p></li><li><p><strong>音频数据源与目标之间的不匹配</strong>：从不同来源获取的音频数据可能具有不同的采样率，例如，网络音频流的采样率可能与本地音频设备的采样率不同，因此需要对音频数据进行重采样以使其匹配。</p></li><li><p><strong>音频处理过程中的采样率变化</strong>：在音频处理中，可能需要对音频数据进行采样率变换，以进行滤波、混音等处理，或者将音频与视频进行同步。</p></li><li><p><strong>音频合成</strong>：将多个来源的音频数据合成为一个音频流时，可能需要对其中一个或多个音频流进行重采样，以使其具有相同的采样率和其他参数。</p></li></ul><p>重采样的过程通常涉及<code>插值</code>、<code>抽取</code>或<code>过滤</code>等技术，以确保在转换过程中尽量减少失真和伪像。总的来说，音频重采样是一个常见的音频处理过程，可以帮助解决音频数据之间的不匹配问题，保证音频数据的质量和一致性。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="ffplay播放器流程"><a href="#ffplay播放器流程" class="headerlink" title="ffplay播放器流程"></a>ffplay播放器流程</h3><p><img src="/2023/10/14/FFmpeg%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/ffplay_flow.png"></p><h3 id="主要模块"><a href="#主要模块" class="headerlink" title="主要模块"></a>主要模块</h3><ul><li>libavcodec : 编&#x2F;解码</li><li>libavdevice : 设备视频文件的封装&#x2F;解封装</li><li>libavfilter : 帧级操作（如添加滤镜）</li><li>libavformat : 文件 I&#x2F;O 和 封装&#x2F;解封装</li><li>libavutil : 通用工具集合</li><li>libpostproc : 预处理</li><li>libswresample : 音频重采样、格式处理、混音等</li><li>libswscale : 色彩处理和缩放</li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>我们按使用目的可以将 FFMPEG 命令分成以下几类：</p><ul><li><p>基本信息查询命令</p></li><li><p>录制</p></li><li><p>分解&#x2F;复用</p></li><li><p>处理原始数据</p></li><li><p>滤镜</p></li><li><p>切割与合并</p></li><li><p>图／视互转</p></li><li><p>直播相关</p></li></ul><p>除了 FFMPEG 的基本信息查询命令外，其它命令都按下图所示的流程处理音视频。<br><img src="/2023/10/14/FFmpeg%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/ffmpeg_flow.png"></p><ol><li><p>（demuxer）打开输入文件，解封装，从容器格式中分离出音频、视频：</p><p> 使用 FFmpeg 提供的 API 或命令行工具，打开要处理的输入文件。输入文件可以是音频文件、视频文件或者其他多媒体格式。</p></li><li><p>（decode）解码音视频数据：</p><p> 从输入文件中读取音视频数据，并进行解码。对于音频数据，通常使用音频解码器进行解码，得到原始的音频样本数据。对于视频数据，使用视频解码器进行解码，得到原始的视频帧数据。</p></li><li><p>（encode）进行处理并编码处理后的音视频数据：</p><p> 对音频数据和视频数据进行需要的处理，例如音频处理、视频处理、滤镜处理等。可以根据需要应用各种效果、转码、裁剪、缩放等操作。</p><p> 将处理后的音频数据和视频数据进行编码。对音频数据使用音频编码器进行编码，得到编码后的音频数据。对视频数据使用视频编码器进行编码，得到编码后的视频数据。</p></li><li><p>（muxer）混流，封装编码后的音视频数据：</p><p> 将编码后的音频数据和视频数据封装到容器格式中，生成最终的输出文件。可以选择不同的容器格式，如 MP4、AVI、FLV、MKV 等。</p></li></ol><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><ul><li>输入&#x2F;输出文件<ul><li>-i：指定输入文件。</li><li>输出文件：输出文件的格式由其扩展名确定。</li></ul></li><li>视频相关参数<ul><li>-c:v &#x2F; -codec:v：指定视频编解码器。</li><li>-b:v：设置视频比特率。</li><li>-s：设置视频分辨率（例如，-s 1920x1080）。</li><li>-r：设置帧率（例如，-r 30 表示每秒 30 帧）。</li><li>-vf：应用视频过滤器（例如，-vf “scale&#x3D;1280:720” 用于缩放视频）。</li><li>-an：删除音频流。</li><li>-t：设置持续时间，适用于裁剪视频。</li></ul></li><li>音频相关参数<ul><li>-c:a &#x2F; -codec:a：指定音频编解码器。</li><li>-b:a：设置音频比特率。</li><li>-ac：设置音频通道数（例如，-ac 2 表示立体声）。</li><li>-ar：设置音频采样率（例如，-ar 44100 表示 44.1 kHz）。</li><li>-af：应用音频过滤器（例如，-af “volume&#x3D;2” 用于增大音量）。</li></ul></li><li>转码和格式转换<ul><li>-f：指定输出文件格式（例如，-f mp4）。</li><li>-map：用于选择和重排流（stream），适合复杂的多流文件。</li><li>-copy：用于直接复制编码流，不进行转码。</li></ul></li><li>视频处理<ul><li>-ss：指定开始时间，用于剪切视频（例如，-ss 00:01:00 表示从 1 分钟开始）。</li><li>-to：指定结束时间，用于剪切视频。</li><li>-filter_complex：应用复杂的过滤器链，用于高级视频处理。</li></ul></li><li>其他常用参数<ul><li>-y：在输出文件存在时强制覆盖。</li><li>-n：在输出文件存在时不覆盖。</li><li>-v：设置输出的详细程度（例如，-v quiet 表示静默模式）。</li><li>-hide_banner：隐藏 FFmpeg 启动时的横幅信息。</li><li>-threads：设置使用的线程数，以加速处理。</li><li>-benchmark：输出处理时间，用于性能分析。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 音视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker使用说明</title>
      <link href="/2023/04/29/Docker%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2023/04/29/Docker%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker使用说明"><a href="#Docker使用说明" class="headerlink" title="Docker使用说明"></a>Docker使用说明</h1><p>基于Ubuntu20之后的系统使用Docker的操作说明。</p><p>如果是其他操作系统，如debian，请自行修改密钥地址和软件源。</p><h2 id="Docker-的安装"><a href="#Docker-的安装" class="headerlink" title="Docker 的安装"></a>Docker 的安装</h2><ol><li><p>更新 Ubuntu ,确保你的 Ubuntu 系统软件包是最新的。</p><pre><code class="bash">sudo apt-get updatesudo apt-get upgrade</code></pre></li><li><p>安装必要的依赖, Docker 需要一些额外的工具和库。</p><pre><code class="bash">sudo apt-get install -y \    ca-certificates \    curl \    gnupg \    lsb-release</code></pre></li><li><p>添加 Docker 的 GPG 密钥,确保你安装的软件包来源是可信的。</p><pre><code class="bash">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</code></pre></li><li><p>添加 Docker 的官方 APT 源。</p><pre><code class="bash">echo \&quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \$(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</code></pre></li><li><p>安装 Docker 引擎和 Docker CLI。</p><pre><code class="bash">sudo apt-get updatesudo apt-get install -y docker-ce docker-ce-cli containerd.io</code></pre></li><li><p>验证 Docker 安装。</p><pre><code class="bash">sudo docker run hello-world</code></pre><p> 这会拉取并运行一个简单的 Docker 容器。如果一切正常，你会看到一条成功消息。</p></li><li><p>配置 Docker 权限<br> 为了避免每次使用 Docker 都需要 sudo，你可以将自己添加到 docker 用户组。</p><pre><code class="bash">sudo usermod -aG docker $USER</code></pre></li></ol><p>注意：这会让你无需 sudo 即可运行 Docker 命令，但请注意这种设置可能具有安全风险。建议在生产环境中谨慎处理。</p><h2 id="docker-compose的安装"><a href="#docker-compose的安装" class="headerlink" title="docker-compose的安装"></a>docker-compose的安装</h2><p>要在 Ubuntu 上安装 Docker Compose，您需要确保已安装 Docker，然后可以下载 Docker Compose 的可执行文件并将其添加到系统的可执行路径中。以下是安装 Docker Compose 的步骤：</p><ol><li><p>安装 Docker</p><p> 确保已在 Ubuntu 上安装 Docker。如果尚未安装，请先安装 Docker。请参照我之前提供的指南。</p></li><li><p>下载 Docker Compose 的二进制文件</p><p> 使用<code>curl</code>或<code>wget</code>从官方 GitHub 存储库下载 Docker Compose 的最新版本。你可以查看 <a href="https://github.com/docker/compose/releases">Docker Compose 发布页面</a> 获取最新版本的版本号。</p><pre><code class="bash"># 确保 Docker Compose 的版本号最新DOCKER_COMPOSE_VERSION=&quot;2.24.0&quot;  # 这是一个示例，请根据官方版本更新# 下载 Docker Compose 二进制文件# 注意这里的CPU架构 我选的x86_64 请根据自己的架构进行选择sudo curl -L &quot;https://github.com/docker/compose/releases/download/v$DOCKER_COMPOSE_VERSION/docker-compose-linux-x86_64&quot; -o /usr/local/bin/docker-compose</code></pre></li><li><p>添加执行权限<br> 将下载的 Docker Compose 文件设为可执行状态。</p><pre><code class="bash">sudo chmod +x /usr/local/bin/docker-compose</code></pre></li><li><p>检查 Docker Compose 是否成功安装<br> 验证 Docker Compose 是否已正确安装。</p><pre><code class="bash">docker-compose --version</code></pre><p> 如果安装成功，你应该会看到 Docker Compose 的版本信息。</p></li><li><p>使用 Docker Compose</p><p> 安装完成后，你可以开始使用 Docker Compose。创建 docker-compose.yml 文件并在其中定义服务，然后使用 docker-compose up 启动服务。</p></li></ol><blockquote><p>注意事项<br>    1. 在下载 Docker Compose 二进制文件时，确保从官方可信渠道下载。<br>    2. 如果你需要 Docker Compose 的旧版本，可以在官方 GitHub 页面上找到以前的版本。<br>    3. 请根据自己的机器系统和CPU架构选择正确的版本。</p></blockquote><h2 id="Docker-基本使用"><a href="#Docker-基本使用" class="headerlink" title="Docker 基本使用"></a>Docker 基本使用</h2><ul><li><p>简单命令</p><pre><code class="bash"># 搜索镜像docker search &lt;image&gt;# 拉取镜像docker pull &lt;image&gt;:&lt;tag&gt;# 列出本地的 Docker 镜像docker images# 列出容器docker ps# 启动容器docker start &lt;container&gt;# 停止容器docker stop &lt;container&gt;# 删除指定镜像 使用 -f 参数可以强制删除docker rmi &lt;image_name&gt;# 删除指定容器 需要先停止容器docker rm &lt;container&gt;</code></pre></li><li><p>启动容器</p><pre><code class="bash">docker run -itd --restart always -p &lt;host_port&gt;:&lt;container_port&gt; &lt;image&gt; &lt;cmd&gt;</code></pre><ul><li>-d：以后台模式运行容器（即“守护进程”模式）。</li><li>-it：启动交互式容器并分配一个伪终端，通常用于调试和开发。</li><li>–name <container_name>：指定容器的名称。</container_name></li><li>-p <host_port>:<container_port>：映射主机和容器的端口。</container_port></host_port></li><li>-v <host_path>:<container_path>：挂载主机上的文件夹到容器中。</container_path></host_path></li><li>–rm：容器停止后自动删除。</li><li>–env <key>&#x3D;<value>：设置环境变量。</value></key></li><li>–network <network_name>：指定容器运行的网络。</network_name></li><li>–restart 重启策略：<ul><li>no：默认值。容器不会自动重启。</li><li>always：无论容器因何原因停止，它都会自动重启。这对于需要确保容器长期运行的服务非常有用。</li><li>unless-stopped：类似于 always，但如果容器是由用户手动停止的，它不会重新启动。适用于需要持久化服务但允许用户手动停止的场景。</li><li>on-failure：当容器因为非零退出码停止时，它会重新启动。适用于容器可能因错误而停止的场景。可以通过添加一个整数参数来指定尝试重启的最大次数，比如 on-failure:3 表示容器最多尝试重启 3 次。</li></ul></li></ul></li><li><p>查看日志</p><pre><code class="bash">docker logs &lt;container&gt;</code></pre><ul><li>-f：跟踪实时日志输出。</li><li>–tail <n>：显示最后的 n 行日志。</n></li></ul></li><li><p>Docker exec</p><p>  docker exec 命令用于在正在运行的容器内执行命令。</p><pre><code class="bash">docker exec -it &lt;container&gt; &lt;cmd&gt;</code></pre><ul><li>-it：以交互方式运行命令，通常用于连接容器的终端。</li><li>–user <user>：以指定用户的身份运行命令。</user></li></ul></li><li><p>创建自定义网络</p><pre><code class="bash">docker network create -d macvlan --subnet=192.168.2.0/24  --gateway=192.168.2.1 -o macvlan_mode=bridge -o parent=enp0s31f6 mynet</code></pre><ul><li>docker network create:<br>  这是创建 Docker 网络的命令。</li><li>-d macvlan:<br>  指定网络驱动为 macvlan。macvlan 驱动允许容器拥有独立的 MAC 地址，使其看起来像是主机上的一个独立网络接口。在这种模式下，容器可以直接与外部网络进行通信。</li><li>–subnet&#x3D;192.168.2.0&#x2F;24:<br>  定义网络的子网范围。这表示所有 IP 地址在 192.168.2.0&#x2F;24 的范围内，子网掩码为 255.255.255.0。这意味着此网络中可用的 IP 地址从 192.168.2.1 到 192.168.2.254。</li><li>–gateway&#x3D;192.168.2.1:<br>  指定该网络的网关地址。在这个例子中，网关地址是 192.168.2.1。通常，网关用于将网络内的流量路由到外部网络。</li><li>-o macvlan_mode&#x3D;bridge:<br>  macvlan 驱动支持几种不同的模式。bridge 模式是最常用的一种，允许容器与外部网络通信，并通过网关与其他网络通信。这与传统的桥接模式不同，macvlan bridge 模式直接连接到物理网络。</li><li>-o parent&#x3D;enp0s31f6:<br>  指定 macvlan 网络的父接口。这里的 enp0s31f6 是主机上的物理网络接口。macvlan 网络将在该接口上创建虚拟网络，使容器能够通过这个接口与外部网络通信。</li><li>mynet:<br>  这是创建的网络名称。在使用 Docker 时，你可以使用这个名称来引用新创建的网络。</li></ul><p>  除了macvlan外，还有bridge、overlay等类型。  </p><ul><li>bridge <ul><li>概述：这是 Docker 的默认网络类型。每个容器都有一个独立的虚拟网络接口，并通过一个虚拟交换机连接到 bridge 网络。容器间可以通过内部 IP 地址进行通信。</li><li>使用场景：适用于希望在单个主机上的容器之间进行通信，同时保持与外部网络的隔离。可以通过端口映射将外部请求路由到容器。</li></ul></li><li>overlay <ul><li>概述：用于 Docker Swarm 或 Kubernetes 等分布式环境。在多个 Docker 主机之间创建虚拟网络，允许容器跨主机通信。使用 VXLAN 等技术实现。</li><li>使用场景：适用于分布式应用程序，需要容器在多个 Docker 主机间通信。常用于多容器应用程序和微服务架构。</li></ul></li></ul></li><li><p>构建镜像</p><pre><code class="bash"># 在当前目录中构建 Docker 镜像，标签为 &quot;my_image:latest&quot;docker build -t my_image:latest .# 使用特定 Dockerfile 构建，标签为 &quot;my_image:v1&quot;docker build -f /path/to/Dockerfile -t my_image:v1 .# 构建时不使用缓存docker build --no-cache -t my_image:no_cache .# 构建时传递环境变量docker build --build-arg MY_VAR=value -t my_image:with_arg .</code></pre><ul><li>-t：指定构建镜像的标签和名称。</li><li>-f：指定 Dockerfile 的路径。默认为当前目录下的 Dockerfile。</li><li>–no-cache：构建时不使用缓存。这对于确保每次都从头开始构建很有用。</li><li>–build-arg：传递构建时的参数（如环境变量）。</li><li>–target：指定构建的阶段（用于多阶段构建）。</li><li>–network：指定构建期间使用的网络模式。</li></ul></li><li><p>推送镜像到dockerhub</p><pre><code class="bash">docker push my_dockerhub_username/my_image:latest</code></pre></li><li><p>docker-compose</p><pre><code class="bash"># 启动docker-compose up# 停止docker-compose down# 查看所有容器的日志docker-compose logs# 列出所有相关容器docker-compose ps</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用说明</title>
      <link href="/2023/04/14/Git%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
      <url>/2023/04/14/Git%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="Git使用说明"><a href="#Git使用说明" class="headerlink" title="Git使用说明"></a>Git使用说明</h1><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>Git 提供了一个叫做<code>git config</code>的工具，专门用来配置或读取相应的工作环境变量。</p><p>这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p><ul><li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。</li><li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。</li><li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git&#x2F;config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git&#x2F;config 里的配置会覆盖 &#x2F;etc&#x2F;gitconfig 中的同名变量。</li></ul><p>在 Windows 系统上，Git 会找寻用户主目录下的 <code>.gitconfig</code>文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings$USER。</p><p>此外，Git 还会尝试找寻 &#x2F;etc&#x2F;gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>配置个人的用户名称和电子邮件地址：</p><pre><code class="bash">git config --global user.name &quot;huahua&quot;git config --global user.email test@huahua.com</code></pre><p>如果用了<code>--global</code>选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。</p><p>如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git&#x2F;config 文件里。</p><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：:</p><pre><code class="bash">git config --global core.editor emacs</code></pre><h3 id="差异分析工具"><a href="#差异分析工具" class="headerlink" title="差异分析工具"></a>差异分析工具</h3><p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p><pre><code class="bash">git config --global merge.tool vimdiff</code></pre><p>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。</p><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><p>要检查已有的配置信息，可以使用<code>git config --list</code>命令：</p><pre><code class="bash">git config --listhttp.postbuffer=2Muser.name=huahuauser.email=test@huahua.com</code></pre><p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 &#x2F;etc&#x2F;gitconfig 和 ~&#x2F;.gitconfig），不过最终 Git 实际采用的是最后一个。</p><p>这些配置我们也可以在 ~&#x2F;.gitconfig 或 &#x2F;etc&#x2F;gitconfig 看到，如下所示：</p><pre><code>vim ~/.gitconfig </code></pre><p>显示内容如下所示：</p><pre><code>[http]    postBuffer = 2M[user]    name = runoob    email = test@runoob.com</code></pre><p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：</p><pre><code>$ git config user.namehuahua</code></pre><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="创建仓库命令"><a href="#创建仓库命令" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h3><p>下表列出了 git 创建仓库的命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>git init</td><td>初始化仓库</td></tr><tr><td>git clone</td><td>拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table><h3 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h3><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><p>下表列出了有关创建与提交你的项目的快照的命令：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>git add</td><td>添加文件到暂存区</td></tr><tr><td>git status</td><td>查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td>git diff</td><td>比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td>git commit</td><td>提交暂存区到本地仓库。</td></tr><tr><td>git reset</td><td>回退版本。</td></tr><tr><td>git rm</td><td>将文件从暂存区和工作区中删除。</td></tr><tr><td>git mv</td><td>移动或重命名工作区文件。</td></tr><tr><td>git checkout</td><td>分支切换。</td></tr><tr><td>git switch （Git 2.23 版本引入）</td><td>更清晰地切换分支。</td></tr><tr><td>git restore （Git 2.23 版本引入）</td><td>恢复或撤销文件的更改。</td></tr></tbody></table><h3 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>git log</td><td>查看历史提交记录</td></tr><tr><td>git blame <file></file></td><td>以列表形式查看指定文件的历史修改记录</td></tr></tbody></table><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>git remote</td><td>远程仓库操作</td></tr><tr><td>git fetch</td><td>从远程获取代码库</td></tr><tr><td>git pull</td><td>下载远程代码并合并</td></tr><tr><td>git push</td><td>上传远程代码并合并</td></tr></tbody></table><h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h2><h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><ol><li>查看标签</li></ol><pre><code class="bash">git tag</code></pre><ol start="2"><li>打标签</li></ol><pre><code class="bash">git tag -a &lt;tagname&gt; -m &quot;tag desc&quot;</code></pre><h3 id="创建新分支并推送到远程仓库"><a href="#创建新分支并推送到远程仓库" class="headerlink" title="创建新分支并推送到远程仓库"></a>创建新分支并推送到远程仓库</h3><ol><li><p>创建新分支：</p><p> 首先，使用 Git 命令创建新的分支。假设要创建一个名为 new-feature 的新分支，可以使用以下命令：</p><pre><code class="bash">git checkout -b new-feature</code></pre><p> 这将创建一个名为 new-feature 的新分支，并将当前分支切换到该分支。</p></li><li><p>在新分支上进行工作：</p><p> 在新分支上进行修改、添加新文件等工作，完成新功能的开发或修改。</p></li><li><p>将新分支推送到远程仓库：</p><p> 使用 git push 命令将新创建的分支推送到远程仓库。如果远程仓库中还不存在该分支，可以使用 -u 选项将本地分支与远程分支关联起来。假设远程仓库名为 origin，可以使用以下命令：</p><pre><code class="bash">git push -u origin new-feature</code></pre><p> 这将把名为 new-feature 的新分支推送到远程仓库，并与远程仓库的同名分支关联起来。</p></li></ol><h3 id="设置上游分支"><a href="#设置上游分支" class="headerlink" title="设置上游分支"></a>设置上游分支</h3><ol><li><p>首先，打开命令行或终端窗口，进入你想要设置上游分支的本地仓库目录。</p></li><li><p>使用以下命令将远程仓库添加为上游分支：</p></li></ol><pre><code class="bash">git remote add upstream &lt;远程仓库URL&gt;</code></pre><ol start="3"><li>使用以下命令来验证上游分支是否设置成功：</li></ol><pre><code class="bash">git remote -v</code></pre><p>这个命令会列出所有与本地仓库相关联的远程仓库，包括上游分支。</p><ol start="4"><li>如果你希望从上游分支获取更新，可以使用以下命令：</li></ol><pre><code class="bash">git fetch upstream</code></pre><p>这个命令会从上游分支获取最新的提交。</p><ol start="5"><li>如果你想要将上游分支合并到你的本地分支中，可以使用以下命令：</li></ol><pre><code class="bash">git merge upstream/&lt;分支名&gt;</code></pre><p>这里的&lt;分支名&gt;是指上游分支的具体名称，例如main、master等。</p><h3 id="查找提交日志"><a href="#查找提交日志" class="headerlink" title="查找提交日志"></a>查找提交日志</h3><pre><code class="bash">git log --grep=&#39;xxx&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/04/13/MySQL/"/>
      <url>/2023/04/13/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="1-基础篇"><a href="#1-基础篇" class="headerlink" title="1.基础篇"></a>1.基础篇</h2><h3 id="1-1-关系型和非关系型数据库的区别你了解多少？"><a href="#1-1-关系型和非关系型数据库的区别你了解多少？" class="headerlink" title="1.1 关系型和非关系型数据库的区别你了解多少？"></a>1.1 关系型和非关系型数据库的区别你了解多少？</h3><ul><li>关系型数据库的优点<ul><li>容易理解。因为它采用了关系模型来组织数据。</li><li>可以保持数据的一致性。</li><li>数据更新的开销比较小。</li><li>支持复杂查询（带where子句的查询）</li></ul></li><li>非关系型数据库的优点<ul><li>不需要经过SQL层的解析，读写效率高。</li><li>基于键值对，数据的扩展性很好。</li><li>可以支持多种类型数据的存储，如图片，文档等等。</li></ul></li></ul><h3 id="1-2-说一说三个范式"><a href="#1-2-说一说三个范式" class="headerlink" title="1.2 说一说三个范式"></a>1.2 说一说三个范式</h3><ul><li><p>第一范式（1NF）：<br>  数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</p></li><li><p>第二范式（2NF）：<br>  在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分</p></li><li><p>第三范式（3NF）：<br>  在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键</p></li></ul><p>数据库设计的三大范式旨在确保数据库的规范性、减少冗余、提高数据完整性和可维护性。第一范式确保每一列都是原子值；第二范式消除部分依赖；第三范式消除传递依赖。遵循这些范式有助于创建结构合理、易于维护的数据库。</p><h3 id="1-3-事务的四大特性-ACID-介绍一下"><a href="#1-3-事务的四大特性-ACID-介绍一下" class="headerlink" title="1.3 事务的四大特性(ACID)介绍一下?"></a>1.3 事务的四大特性(ACID)介绍一下?</h3><ul><li><p>原子性(atomicity，或称不可分割性)：事务的所有操作要么全部成功，要么全部回滚。</p></li><li><p>一致性(consistency)：总是从一个一致性的状态转换到另一个一致性的状态</p></li><li><p>隔离性(isolation)：多个事务并发执行时，一个事务的执行不应影响其他事务的执行</p></li><li><p>持久性(durability)：已被提交的事务对数据库的修改应该永久保存在数据库中。</p></li></ul><h3 id="1-4-存储引擎如何选择？"><a href="#1-4-存储引擎如何选择？" class="headerlink" title="1.4 存储引擎如何选择？"></a>1.4 存储引擎如何选择？</h3><p>如果没有特别的需求，使用默认的Innodb即可。<br>InnoDB 引擎由于其对事务参照完整性，以及更高的并发性等优点开始逐步的取代 MyISAM</p><ul><li>事务和数据完整性：如果需要事务、数据完整性、外键支持，应选择 InnoDB。</li><li>高并发：如果数据库应用需要高并发处理，行级锁的优势使 InnoDB 更合适。</li><li>只读应用：如果应用主要是读取数据，且不需要事务，MyISAM 可能具有性能优势。</li><li>全文搜索：如果需要全文搜索功能，MyISAM 是一种选择，但 InnoDB 在某些版本中也支持全文搜索。</li></ul><h3 id="1-5-事务的隔离性"><a href="#1-5-事务的隔离性" class="headerlink" title="1.5 事务的隔离性"></a>1.5 事务的隔离性</h3><p>脏读、不可重复读和幻读是数据库事务隔离级别中可能出现的问题。它们与数据库事务的隔离性有关，指在不同事务中读写数据时可能遇到的异常行为。以下是这些问题的详细解释和示例。</p><ul><li><p>脏读（Dirty Read）  </p><ul><li><p>脏读发生在一个事务读取了另一个未提交的事务所写的数据。这可能导致读取到不一致或无效的数据。</p></li><li><p>示例：<br>  事务 A 修改了某个表中的数据，但还没有提交。此时，事务 B 读取了该数据。如果事务 A 决定<code>回滚</code>，则事务 B 读取的数据可能是错误的。这种情况就是脏读。</p></li></ul></li><li><p>不可重复读（Non-Repeatable Read）</p><ul><li><p>不可重复读是指一个事务在不同时间多次读取同一行数据时，结果可能不同，因为另一事务在这期间修改了该行。</p></li><li><p>示例：<br>  事务 A 读取了某个表中的数据，然后事务 B <code>修改并提交</code>了该数据。接下来，事务 A 再次读取该数据，发现数据已经改变。这种情况就是不可重复读。</p></li></ul></li><li><p>幻读（Phantom Read）</p><ul><li><p>幻读是指一个事务在不同时间多次读取数据时，结果可能不同，因为另一事务在这期间插入或删除了数据行。</p></li><li><p>示例：<br>  事务 A 读取了满足某个条件的所有记录，然后事务 B <code>插入</code>了一行满足相同条件的数据。接下来，事务 A 再次读取相同的条件，发现多了一个记录。这种情况就是幻读。</p></li></ul></li></ul><p><strong>事务隔离级别</strong></p><p>这些问题的发生与事务的隔离级别有关。SQL 数据库通常提供四个隔离级别，每个隔离级别对这些问题的处理不同。</p><ul><li><p>读未提交（Read Uncommitted）：<br>  最低的隔离级别，允许脏读、不可以重复读和幻读。</p></li><li><p>读已提交（Read Committed）：<br>  中级隔离级别，防止脏读，但可能出现不可重复读和幻读。</p></li><li><p>可重复读（Repeatable Read）：<br>  较高的隔离级别，防止脏读和不可重复读，但可能出现幻读。</p></li><li><p>序列化（Serializable）：<br>  最高的隔离级别，防止脏读、不可重复读和幻读，但可能降低并发性能。</p></li></ul><p>这里需要注意的是：<br>Mysql 默认采用的 REPEATABLE_READ隔离级别<br>Oracle 默认采用的 READ_COMMITTED隔离级别</p><h3 id="1-6-服务器日志"><a href="#1-6-服务器日志" class="headerlink" title="1.6 服务器日志"></a>1.6 服务器日志</h3><p><strong>常见的 MySQL 服务器日志</strong></p><ul><li><p>错误日志（Error Log）：<br>记录了 MySQL 服务器启动、运行和关闭过程中遇到的错误、警告和通知。错误日志对于诊断 MySQL 服务器的运行问题非常重要。</p><ul><li>用途：排查数据库启动失败、崩溃或运行时遇到的错误。</li><li>配置：使用 –log-error 参数或 log_error 配置选项来设置错误日志的位置。</li></ul></li><li><p>查询日志（General Query Log）：<br>记录了 MySQL 服务器接收到的所有 SQL 查询和命令。查询日志可以帮助你了解数据库中发生的所有操作。</p><ul><li>用途：监控数据库的活动，调试查询操作，排查问题。</li><li>配置：使用 –general-log 参数或 general_log 配置选项启用查询日志。</li><li>注意：查询日志可能导致大量日志文件，影响性能，通常仅在调试或诊断时启用。</li></ul></li><li><p><strong>慢查询日志（Slow Query Log）</strong>：<br>记录了执行时间超过指定阈值的查询。慢查询日志可以帮助你检测和优化慢查询。</p><ul><li>用途：识别慢查询，优化数据库性能。</li><li>配置：使用 –slow-query-log 参数或 slow_query_log 配置选项启用慢查询日志，并使用 long_query_time 设置阈值。</li><li>优化：通过分析慢查询日志，可以优化索引、简化查询逻辑等。</li></ul></li><li><p><strong>二进制日志（Binary Log）</strong>：<br>记录了所有更改数据的操作，包括 INSERT、UPDATE、DELETE 等。这些日志用于数据库的复制和恢复。</p><ul><li>用途：数据恢复、数据库复制。</li><li>配置：使用 –log-bin 参数或 log_bin 配置选项启用二进制日志。</li><li>注意：二进制日志文件可能占用较多存储空间，需要定期清理。</li></ul></li><li><p><strong>中继日志（Relay Log）</strong>：<br>记录了从服务器从主服务器复制过来的二进制日志。中继日志主要用于 MySQL 复制中的从服务器。</p><ul><li>用途：在 MySQL 复制中，从服务器用于重放从主服务器复制过来的二进制日志。</li><li>配置：由 MySQL 自动管理，中继日志位置可以在复制配置中指定。</li><li>注意：中继日志可能需要定期清理，以防止占用过多存储空间。</li></ul></li><li><p>日志的用途</p><ul><li>诊断和排查问题：通过错误日志、查询日志等，可以查找和排除 MySQL 服务器中的问题。</li><li>性能优化：通过慢查询日志，可以识别性能问题，并采取优化措施。</li><li>安全监控：查询日志可以帮助监控数据库活动，检测异常或未经授权的操作。</li><li>数据恢复和复制：二进制日志用于数据库复制和数据恢复，确保数据的可靠性。</li></ul></li><li><p>日志的配置和管理<br>在 MySQL 中，日志的配置和管理需要考虑性能和存储空间。以下是一些常见的日志管理技巧：</p></li><li><p>启用必要的日志：仅在需要时启用查询日志和慢查询日志，以减少性能影响。</p></li><li><p>定期清理日志：定期清理二进制日志和中继日志，防止占用过多存储空间。</p></li><li><p>日志轮换：使用日志轮换策略，确保日志文件不会过大。</p></li><li><p>监控日志：定期查看日志，及时发现和解决问题。</p></li></ul><h3 id="1-7-B-树和-B-树的区别"><a href="#1-7-B-树和-B-树的区别" class="headerlink" title="1.7 B 树和 B+ 树的区别"></a>1.7 B 树和 B+ 树的区别</h3><ul><li>数据存储位置：B 树的内部节点和叶子节点都可以存储数据，而 B+ 树只有叶子节点存储数据，内部节点只用于索引。</li><li>顺序遍历：B+ 树的叶子节点按顺序链接，可以快速进行顺序遍历和范围查询，而 B 树没有这样的顺序链接。</li><li>树的高度：由于 B+ 树的内部节点不存储数据，内部节点数量相对较少，通常比 B 树更扁平。</li><li>性能：B+ 树通常在数据库和文件系统中表现更好，特别是顺序遍历和范围查询。</li></ul><p>所以 B+ 树在数据库索引和文件系统中广泛应用，因为它提供了快速查找、顺序遍历和范围查询的能力。</p><h3 id="1-8-视图-和-游标"><a href="#1-8-视图-和-游标" class="headerlink" title="1.8 视图 和 游标"></a>1.8 视图 和 游标</h3><p>视图（View）和游标（Cursor）是数据库中用于数据处理和查询的两种不同概念，它们在用途和功能上有显著差异。视图是一种虚拟表，它提供了对数据的自定义视角，而游标是一种用于遍历结果集的数据库对象。以下是视图和游标的详细解释以及它们的区别。</p><ul><li><p>视图是一种虚拟表，它是基于 SQL 查询的结果生成的。视图可以为用户提供自定义的数据视角，而无需直接操作底层表。</p><ul><li>示例：<br>  创建一个视图来显示特定部门的员工信息：</li></ul><pre><code class="sql">CREATE VIEW sales_employees ASSELECT id, name, department_idFROM employeesWHERE department_id = 1;</code></pre></li><li><p>游标是一种用于逐行遍历数据库结果集的数据库对象。游标允许你在结果集中逐行移动，并对每一行执行操作。</p><ul><li>示例：<br>  使用游标遍历员工表，计算每个员工的奖金：</li></ul><pre><code class="sql">DELIMITER //CREATE PROCEDURE calculate_bonuses()BEGINDECLARE done INT DEFAULT 0;DECLARE emp_id INT;DECLARE emp_bonus DECIMAL(10, 2);DECLARE emp_cursor CURSOR FOR SELECT id FROM employees;DECLARE CONTINUE HANDLER FOR SQLSTATE &#39;02000&#39; SET done = 1;OPEN emp_cursor;read_loop: LOOP    FETCH emp_cursor INTO emp_id;    IF done THEN    LEAVE read_loop;    END IF;    -- 计算奖金的逻辑    SET emp_bonus = ...;    -- 更新奖金    UPDATE employees SET bonus = emp_bonus WHERE id = emp_id;END LOOP;CLOSE emp_cursor;END //DELIMITER ;</code></pre></li></ul><h3 id="1-9-乐观锁-和-悲观锁"><a href="#1-9-乐观锁-和-悲观锁" class="headerlink" title="1.9 乐观锁 和 悲观锁"></a>1.9 乐观锁 和 悲观锁</h3><p>乐观锁（Optimistic Locking）和悲观锁（Pessimistic Locking）是数据库中用于处理并发操作的一种机制。它们旨在确保多用户环境中的数据一致性和完整性。在选择使用哪种锁机制时，考虑并发性、性能需求和可能发生的冲突是关键。以下是乐观锁和悲观锁的详细解释以及它们的区别和应用场景。</p><ul><li><p>乐观锁（Optimistic Locking）<br>  乐观锁假设数据更新时冲突的概率较低，因此在更新数据前不对数据进行加锁。相反，它通过检测数据在读和写之间是否发生变化，来确保数据的正确性。如果数据在此期间发生变化，乐观锁会阻止更新，确保数据不被无意中覆盖。</p><ul><li>特点：<ul><li>不进行显式加锁，避免了锁竞争。</li><li>通过检查机制（如版本号或时间戳）来确保数据一致性。</li><li>当发生并发冲突时，操作可能被拒绝，并需要重新尝试。</li></ul></li><li>实现方式：<ul><li>版本号：在表中增加一个版本号列，每次更新时增加版本号。更新操作时检查版本号，如果版本号不一致，则拒绝更新。</li><li>时间戳：类似于版本号，但使用时间戳来检测数据变化。</li></ul></li><li>应用场景：<br>  乐观锁适用于并发冲突概率较低的场景，尤其是在读多写少的环境中。它避免了锁的竞争，通常性能更高。<br>  示例：<br>  使用版本号实现乐观锁的更新操作：<pre><code class="sql">-- 读取数据和版本号SELECT name, version FROM employees WHERE id = 1;-- 更新数据时检查版本号UPDATE employeesSET name = &#39;John&#39;, version = version + 1WHERE id = 1 AND version = current_version;</code></pre></li></ul></li><li><p>悲观锁（Pessimistic Locking）<br>  悲观锁假设数据更新时可能会发生冲突，因此在进行操作前对数据进行显式加锁。这样，其他用户无法同时访问被锁定的数据，避免了并发冲突。</p><ul><li>特点：<ul><li>通过加锁来确保数据一致性，防止数据被同时修改。</li><li>锁定期间，其他操作可能被阻塞，等待锁释放。</li><li>当锁竞争严重时，可能导致性能问题和死锁。</li></ul></li><li>实现方式：<ul><li>行级锁：锁定特定的行，其他操作无法修改该行，直到锁释放。</li><li>表级锁：锁定整个表，其他操作无法对表进行修改。</li></ul></li><li>应用场景：<br>  悲观锁适用于并发冲突概率较高的场景，尤其是在写多读少的环境中。悲观锁可以确保数据的一致性，但可能导致性能问题和锁竞争。<br>  示例：<br>  使用行级锁进行悲观锁的更新操作：<pre><code class="sql">-- 开启事务START TRANSACTION;-- 显式加锁SELECT * FROM employees WHERE id = 1 FOR UPDATE;-- 执行更新操作UPDATE employees SET name = &#39;John&#39; WHERE id = 1;-- 提交事务COMMIT;</code></pre></li></ul></li><li><p>乐观锁和悲观锁的区别</p><ul><li>加锁方式：<ul><li>乐观锁不进行显式加锁，而是通过版本号或时间戳来确保数据一致性。</li><li>悲观锁通过显式加锁，防止数据被同时修改。</li></ul></li><li>性能和并发：<ul><li>乐观锁通常性能较高，因为不进行显式加锁，适用于读多写少的场景。</li><li>悲观锁可能导致性能问题，适用于写多读少的场景。</li></ul></li></ul></li></ul><h3 id="2-0-MySQL-索引类型"><a href="#2-0-MySQL-索引类型" class="headerlink" title="2.0 MySQL 索引类型"></a>2.0 MySQL 索引类型</h3><p>MySQL 索引的最主要数据结构包括 B+ 树、哈希表、R 树和全文索引等。这些数据结构各有特点和适用场景，在 MySQL 中用于提高查询速度和优化数据库性能。以下是 MySQL 索引最主要的数据结构及其用途的详细介绍。</p><ol><li><strong>B+ 树（B+ Tree）</strong><br>B+ 树是一种平衡树结构，用于支持快速查找和顺序遍历。在 MySQL 中，B+ 树通常用于存储索引，并保持树的平衡，以确保快速的插入、删除和查找操作。</li></ol><ul><li>特点：<ul><li>B+ 树的内部节点只存储键和指向子节点的指针，所有数据存储在叶子节点中。</li><li>B+ 树的叶子节点按顺序链接，支持快速顺序遍历和范围查询。</li><li>B+ 树能够保持平衡，确保操作的时间复杂度较低。</li></ul></li><li>应用场景：<ul><li>B+ 树索引常用于 MySQL 的 InnoDB 存储引擎，用于主键索引、唯一索引和一般索引。它适用于大部分查询操作，如等值查询、范围查询和排序操作。</li></ul></li><li>实现方式：<ul><li>MySQL 使用 B+ 树来实现 InnoDB 的聚簇索引和辅助索引。</li><li>聚簇索引：B+ 树的叶子节点存储表中的完整行数据，叶子节点按顺序链接。</li><li>辅助索引：B+ 树的叶子节点存储键值和指向聚簇索引的指针。</li></ul></li></ul><ol start="2"><li><p>哈希表（Hash Table）<br>哈希表是一种基于哈希函数的索引结构，用于快速查找和等值查询。在 MySQL 中，哈希索引用于特定场景，适用于快速的等值查询。</p></li><li><p>R 树（R-Tree）<br>R 树是一种用于空间数据索引的树结构，适用于地理信息系统和空间数据库。在 MySQL 中，R 树用于 MyISAM 存储引擎的空间索引。</p></li><li><p>全文索引（Full-Text Index）<br>全文索引用于快速搜索和检索文本数据，适用于全文搜索操作。在 MySQL 中，全文索引用于支持文本内容的搜索和检索。</p></li></ol><h3 id="2-1-聚集索引-和-非聚集索引"><a href="#2-1-聚集索引-和-非聚集索引" class="headerlink" title="2.1 聚集索引 和 非聚集索引"></a>2.1 聚集索引 和 非聚集索引</h3><p><code>聚集索引</code>和<code>非聚集索引</code>是关系型数据库中的两种索引结构。</p><ul><li>聚集索引将数据行按索引顺序存储，适用于范围查询和排序等场景；</li><li>非聚集索引只存储索引键和指向数据行的指针，不改变数据行的存储顺序。</li></ul><p>形象的例子：  </p><ul><li><p>聚集索引就像你按照字母顺序整理好的书，每一页都按照某个特定的顺序排列，比如按照书的内容排列。这样，你要找到某一页，只需翻开书的第一页，然后顺着页码找到对应的内容。这种方式很适合按照顺序查找或者按照范围查找。</p></li><li><p>非聚集索引就像是另外一本独立的目录，它并不按照书的内容排列，而是按照关键词（比如主题）来排序，然后指向书的实际位置。这样，如果你要查找某个关键词，就先查找这个独立目录，然后再根据指向的位置去找到实际的内容。虽然查找速度快，但它不改变书的内容排列顺序。</p></li></ul><p>选择合适的索引类型取决于应用场景、查询需求和数据组织方式。聚集索引在 InnoDB 等存储引擎中通常是主键索引，而非聚集索引用于加速特定查询。</p><h2 id="2-SQL篇"><a href="#2-SQL篇" class="headerlink" title="2.SQL篇"></a>2.SQL篇</h2><h3 id="2-1-简述下SQL及分类？"><a href="#2-1-简述下SQL及分类？" class="headerlink" title="2.1 简述下SQL及分类？"></a>2.1 简述下SQL及分类？</h3><p>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。<br>作用：用于存取数据、查询、更新和管理关系数据库系统。<br>基本的分类如下：</p><ol><li><p>数据查询语言（Data Query Language, DQL）<br>负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。</p></li><li><p>数据定义语言 (Data Definition Language, DDL)<br>负责数据结构定义与数据库对象定义的语言，由<code>CREATE</code>、<code>ALTER</code>与<code>DROP</code>三个语法所组成</p></li><li><p>数据操纵语言（Data Manipulation Language, DML）<br>负责对数据库对象运行数据访问工作的指令集，以<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>三种指令为核心，<br>分别代表插入、更新与删除。</p></li><li><p>数据控制语言 (Data Control Language)<br>它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。<br>由<code>GRANT</code>和<code>REVOKE</code>两个指令组成。</p></li></ol><h3 id="2-2-drop、delete与truncate的区别是什么？"><a href="#2-2-drop、delete与truncate的区别是什么？" class="headerlink" title="2.2 drop、delete与truncate的区别是什么？"></a>2.2 drop、delete与truncate的区别是什么？</h3><p>三者都表示删除，但是三者有一些差别：</p><ul><li>在不再需要一张表的时候，用drop；</li><li>在想删除部分数据行时候，用delete；</li><li>在保留表而删除所有数据的时候用truncate。</li></ul><h3 id="2-3-关联查询"><a href="#2-3-关联查询" class="headerlink" title="2.3 关联查询"></a>2.3 关联查询</h3><p>关联查询（Join Query）是一种将两个或多个表中的数据根据特定条件组合在一起的方法。通过关联查询，你可以从不同表中提取相关数据，并将它们结合到一个结果集中。以下是 MySQL 中常见的关联查询类型，以及每种关联查询的详细解释、应用场景和示例。</p><ol><li><p>INNER JOIN（内连接）<br>内连接是最常见的关联查询类型，返回两个表中都存在匹配记录的行。</p><ul><li>用途：<br> 用于提取两个或多个表中符合连接条件的记录。如果某个表中没有匹配的记录，则该行不会出现在结果集中。</li><li>应用场景：<br> 内连接适用于需要提取两个表中匹配数据的场景，例如，员工与部门的对应关系。</li></ul><pre><code class="sql">SELECT employees.name, departments.nameFROM employeesINNER JOIN departmentsON employees.department_id = departments.id;</code></pre></li><li><p>LEFT JOIN（左连接）<br>左连接返回左表中的所有记录，即使右表中没有匹配的记录。在右表中没有匹配的数据时，结果集中的对应列将为 NULL。</p><ul><li>用途：<br> 用于确保左表中的所有记录都被包含在结果集中，即使右表没有匹配的记录。</li><li>应用场景：<br> 当需要保留左表中的所有数据时，左连接是理想的选择。例如，找出没有分配部门的员工。</li></ul><pre><code class="sql">SELECT employees.name, departments.nameFROM employeesLEFT JOIN departmentsON employees.department_id = departments.id;</code></pre></li><li><p>RIGHT JOIN（右连接）<br>右连接与左连接相似，但它返回右表中的所有记录，即使左表中没有匹配的数据。在左表中没有匹配的数据时，结果集中的对应列将为 NULL。</p><ul><li>用途：<br> 用于确保右表中的所有记录都被包含在结果集中。</li><li>应用场景：<br> 当右表中的数据需要保留时，例如，找出没有员工的部门。</li></ul><pre><code class="sql">SELECT employees.name, departments.nameFROM employeesRIGHT JOIN departmentsON employees.department_id = departments.id;</code></pre></li><li><p>CROSS JOIN（交叉连接）<br>交叉连接生成两个表的笛卡尔积，每个表中的每一行与另一个表中的每一行组合。</p><ul><li>用途：<br> 用于生成所有可能的组合，通常在没有明确的连接条件时使用。</li><li>应用场景：<br> 交叉连接用于生成所有可能的组合，例如，生成所有产品与所有客户的组合。</li></ul><pre><code class="sql">SELECT products.name, customers.nameFROM productsCROSS JOIN customers;</code></pre></li><li><p>SELF JOIN（自连接）<br>自连接是将一个表与自身进行连接，用于查找自引用关系。</p><ul><li>用途：<br> 用于处理表中自引用关系的查询，例如员工与他们的经理。</li><li>应用场景：<br> 当需要找到自引用关系时，自连接是有效的解决方案。</li></ul><pre><code class="sql">SELECT a.name AS employee_name, b.name AS manager_nameFROM employees aJOIN employees bON a.manager_id = b.id;</code></pre></li></ol><ul><li>关联查询的注意事项<ul><li>连接条件：<br>  关联查询通常需要指定连接条件，以确保结果的准确性。</li><li>性能考虑：<br>  在处理大量数据或复杂连接时，关联查询可能导致性能问题。适当的索引和优化可以改善性能。</li><li>空值处理：<br>  在 LEFT JOIN 和 RIGHT JOIN 中，右表或左表中没有匹配数据时，结果集中的对应列将为 NULL。因此，查询中应考虑空值处理。</li></ul></li></ul><h3 id="2-4-IN-和-EXISTS"><a href="#2-4-IN-和-EXISTS" class="headerlink" title="2.4 IN 和 EXISTS"></a>2.4 IN 和 EXISTS</h3><p><code>IN</code>和<code>EXISTS</code>是 MySQL 中的两种子查询操作符，通常用于检查某个值是否在特定集合中。它们在用法上有一定的重叠，但在性能和应用场景上存在一些关键区别。以下是 IN 和 EXISTS 的详细解释，以及它们的区别和适用场景。</p><ul><li><p>IN 操作符<br>IN 用于检查某个值是否在给定的集合中，通常用于简单的子查询和静态集合。</p><ul><li>用法：<br>  IN 可以用于将一个值与一组值进行比较，常用于子查询或固定列表。</li></ul><pre><code class="sql">SELECT * FROM employeesWHERE department_id IN (SELECT id FROM departments WHERE name = &#39;Sales&#39;);</code></pre><ul><li>特点：  <ul><li>IN 会一次性计算子查询中的所有结果，然后与外部查询进行比较。</li><li>在子查询结果较小时，IN 的性能通常较好。</li><li>如果 IN 中有重复值，MySQL 会自动去重。</li></ul></li></ul></li><li><p>EXISTS 操作符<br>EXISTS 用于检查子查询是否返回至少一行结果，通常用于复杂的条件检查。</p><ul><li>用法：<br>  EXISTS 通常用于确定子查询是否有结果，适用于检查是否存在相关记录的场景。</li></ul><pre><code class="sql">SELECT * FROM employeesWHERE EXISTS (SELECT 1 FROM departments WHERE department_id = employees.department_id AND name = &#39;Sales&#39;);</code></pre><ul><li>特点：<ul><li>EXISTS 会逐行检查子查询，如果子查询有结果，则 EXISTS 返回 true。</li><li>EXISTS 在子查询较大且仅需检查存在性时性能较好。</li><li>EXISTS 在处理复杂条件和多表连接时更有效。</li></ul></li></ul></li><li><p>IN 与 EXISTS 的区别</p><ul><li>性能：  <ul><li>IN 通常在子查询结果较小时性能较好，因为它一次性计算所有结果。</li><li>EXISTS 在子查询结果较大且只需检查存在性时性能较好，因为它一旦找到匹配结果可以停止计算。</li></ul></li><li>使用场景：<ul><li>IN 适用于与静态集合或小型子查询进行比较。</li><li>EXISTS 适用于检查子查询是否存在结果，尤其是涉及复杂条件或多表连接的情况下。</li></ul></li><li>可读性：<ul><li>IN 通常在需要比较一个值与集合时更直观。</li><li>EXISTS 在需要检查条件是否满足时更合适。</li></ul></li></ul></li></ul><h3 id="2-5-基于MySQL简述下SQL的生命周期"><a href="#2-5-基于MySQL简述下SQL的生命周期" class="headerlink" title="2.5 基于MySQL简述下SQL的生命周期"></a>2.5 基于MySQL简述下SQL的生命周期</h3><ol><li>应用服务器与数据库服务器建立一个连接</li><li>数据库进程拿到请求sql</li><li>解析并生成执行计划，执行</li><li>读取数据到内存并进行逻辑处理</li><li>通过步骤一的连接，发送结果到客户端</li><li>关掉连接，释放资源</li></ol><h2 id="3-高可用篇"><a href="#3-高可用篇" class="headerlink" title="3.高可用篇"></a>3.高可用篇</h2><h3 id="3-1-主从复制的作用及解决的问题是？"><a href="#3-1-主从复制的作用及解决的问题是？" class="headerlink" title="3.1 主从复制的作用及解决的问题是？"></a>3.1 主从复制的作用及解决的问题是？</h3><ol><li>主从复制的作用  <ul><li>主数据库出现问题，可以切换到从数据库。</li><li>可以进行数据库层面的读写分离。</li><li>可以在从数据库上进行日常备份。</li></ul></li><li>解决的问题<ul><li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li><li>负载均衡：降低单个服务器的压力</li><li>高可用和故障切换：帮助应用程序避免单点失败</li><li>升级测试：可以用更高版本的MySQL作为从库</li></ul></li></ol><h3 id="3-2-分库分表的常见类型"><a href="#3-2-分库分表的常见类型" class="headerlink" title="3.2 分库分表的常见类型"></a>3.2 分库分表的常见类型</h3><p>分库分表的常见类型包括水平分割和垂直分割，具体如下：</p><ul><li>水平分表（Sharding）<br>水平分表是将数据行按某个规则拆分到不同的表或库中。这种方式通常用于数据量大、行数多的场景。</li><li>垂直分表（Vertical Partitioning）<br>垂直分表是将不同的列拆分到不同的表或库中。这种方式通常用于表中的列数过多，或数据结构过于复杂的场景。</li></ul><h2 id="4-性能优化篇"><a href="#4-性能优化篇" class="headerlink" title="4.性能优化篇"></a>4.性能优化篇</h2><h3 id="4-1-主键使用自增ID还是UUID？"><a href="#4-1-主键使用自增ID还是UUID？" class="headerlink" title="4.1 主键使用自增ID还是UUID？"></a>4.1 主键使用自增ID还是UUID？</h3><p><strong>推荐使用自增ID，不要使用UUID。</strong></p><p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，</p><p>也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，</p><p>如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，<br>由于到来的ID与原来的大小不确定，会<code>造成非常多的数据插入，数据移动</code>。</p><p>然后导致产生很多的内存碎片，进而造成插入性能的下降。 </p><p>总之，在数据量大一些的情况下，用自增主键性能会好一些。 关于主键是聚簇索引，</p><p>如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，<br>如果没有唯一键，会生成一个隐式的主键。</p><h3 id="4-2-如何优化子查询（嵌套查询）"><a href="#4-2-如何优化子查询（嵌套查询）" class="headerlink" title="4.2 如何优化子查询（嵌套查询）"></a>4.2 如何优化子查询（嵌套查询）</h3><ol><li>用<code>关联查询</code>替代 </li><li>优化GROUP BY和DISTINCT 这两种查询据可以使用<code>索引</code>来优化，是最有效的优化方法 </li><li>关联查询中，使用标识列分组的效率更高 如果不需要ORDER BY，<br>进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。 </li><li>WITH ROLLUP超级聚合，可以挪到应用程序处理</li></ol><h3 id="4-3-对慢查询都怎么优化"><a href="#4-3-对慢查询都怎么优化" class="headerlink" title="4.3 对慢查询都怎么优化?"></a>4.3 对慢查询都怎么优化?</h3><ol><li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，<br>可能是加载了许多结果中并不需要的列，对语句进行<code>分析以及重写</code>。 </li><li>分析语句的执行计划，然后获得其使用<code>索引</code>的情况，之后修改语句或者修改索引，<br>使得语句可以尽可能的命中索引。<br>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li></ol><h3 id="4-4-一道场景题-假如你所在的公司选择MySQL数据库作数据存储-一天五万条以上的增量，预计运维三年，你有哪些优化手段？"><a href="#4-4-一道场景题-假如你所在的公司选择MySQL数据库作数据存储-一天五万条以上的增量，预计运维三年，你有哪些优化手段？" class="headerlink" title="4.4 一道场景题:假如你所在的公司选择MySQL数据库作数据存储,一天五万条以上的增量，预计运维三年，你有哪些优化手段？"></a>4.4 一道场景题:假如你所在的公司选择MySQL数据库作数据存储,一天五万条以上的增量，预计运维三年，你有哪些优化手段？</h3><ol><li><p>设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。</p></li><li><p>选择合适的表字段数据类型和存储引擎,适当的添加索引。</p></li><li><p>MySQL库主从读写分离。</p></li><li><p>找规律分表,减少单表中的数据量提高查询速度。</p></li><li><p>添加缓存机制，比如Memcached，Apc等。</p></li><li><p>不经常改动的页面，生成静态页面。</p></li><li><p>书写高效率的SQL。比如SELECT * FROM TABEL 改为SELECT field_1, field_2 FROM TABEL。</p></li></ol><h3 id="4-5-覆盖索引"><a href="#4-5-覆盖索引" class="headerlink" title="4.5 覆盖索引"></a>4.5 覆盖索引</h3><p>覆盖索引（Covering Index）是指一种索引，其中包含了查询所需的所有数据，因此查询可以直接从索引中获取结果，而无需访问表中的实际数据。由于覆盖索引能够减少 I&#x2F;O 操作并提高查询效率，因此在数据库优化中具有重要作用。</p><ul><li><p>覆盖索引的工作原理<br>覆盖索引的关键在于索引包含了查询所需的所有列。传统的索引通常只包含索引列以及指向表中相应数据行的指针，但覆盖索引不仅包含索引列，还包括查询所需的其他列。当查询可以完全通过索引获取数据时，就不需要访问表的数据行，这可以显著减少 I&#x2F;O 操作，提高查询性能。</p></li><li><p>覆盖索引的应用场景<br>覆盖索引在以下场景中非常有用：</p><ul><li>快速查询：<br>  覆盖索引可以显著加快查询速度，因为它减少了读取表数据的必要。</li><li>**避免<code>回表</code>**：<br>  **传统索引需要通过指针访问表的数据，这称为<code>回表</code>**。覆盖索引不需要回表，因为所有数据都在索引中。</li><li>查询优化：<br>  覆盖索引可以用于优化查询性能，特别是在读取数据量大的情况下。</li><li>减少 I&#x2F;O：<br>  覆盖索引减少了对表数据的访问，从而减少了 I&#x2F;O 操作，提高了效率。</li></ul></li><li><p>覆盖索引的示例<br>假设有一个员工表，其中包含员工的 ID、姓名、部门 ID 和工资。如果你想查询某个特定部门的所有员工姓名和工资，则可以创建一个覆盖索引，包含 department_id、name 和 salary 列。这种情况下，查询可以直接从索引中获取数据，而无需访问表中的行。</p><pre><code class="sql">-- 创建覆盖索引CREATE INDEX idx_department_name_salaryON employees (department_id, name, salary);-- 使用覆盖索引进行查询SELECT name, salaryFROM employeesWHERE department_id = 1;</code></pre></li></ul><p>在这个示例中，查询所需的所有列都包含在索引中，因此不需要回表，可以显著提高查询性能。</p><ul><li>覆盖索引的注意事项<ul><li>索引大小：<br>  覆盖索引可能会增加索引的大小，因为它包含了查询所需的所有列。在设计覆盖索引时，需要平衡索引大小与查询性能。</li><li>索引维护：<br>  覆盖索引需要维护，这可能会增加数据库的负担，特别是在高频率的插入、更新、删除操作中。 </li><li>选择合适的列：<br>  在创建覆盖索引时，选择包含查询所需的列，同时避免过多不必要的列，以减少索引大小。</li></ul></li></ul><h3 id="4-6-既然索引有那么多优点，为什么不对表总的每一列创建一个索引呢？"><a href="#4-6-既然索引有那么多优点，为什么不对表总的每一列创建一个索引呢？" class="headerlink" title="4.6 既然索引有那么多优点，为什么不对表总的每一列创建一个索引呢？"></a>4.6 既然索引有那么多优点，为什么不对表总的每一列创建一个索引呢？</h3><ul><li>当对表中的数据进行增加、删除和修改的时候，<strong>索引也要动态的维护</strong>，这样就降低了数据的维护速度。</li><li><strong>索引需要占物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立簇索引，那么需要的空间就会更大。</li><li><strong>创建索引和维护索引要耗费时间</strong>，这种时间随着数据量的增加而增加</li></ul><h3 id="4-7-设置多个索引有效吗"><a href="#4-7-设置多个索引有效吗" class="headerlink" title="4.7 设置多个索引有效吗"></a>4.7 设置多个索引有效吗</h3><p>在一个特定的查询中，通常只有<strong>一个索引能够生效</strong>。这是因为数据库优化器会<strong>根据查询条件、索引选择性和表的大小等因素选择最适合的索引</strong>。为了确保查询效率，数据库管理员需要选择和设置合适的索引，并定期检查和优化索引。通过使用<code>EXPLAIN</code>语句，你可以查看查询计划，了解哪个索引生效以及优化器选择索引的方式。</p><h3 id="4-8-你知道哪些数据库结构优化的手段？"><a href="#4-8-你知道哪些数据库结构优化的手段？" class="headerlink" title="4.8 你知道哪些数据库结构优化的手段？"></a>4.8 你知道哪些数据库结构优化的手段？</h3><ul><li><p><strong>范式优化</strong>：比如消除冗余（节省空间。。</p></li><li><p><strong>反范式优化</strong>：比如适当加冗余等(减少join)限定数据的范围:务必禁止不带任何限制数据范围条件的查询语句。<br>比如:我们当用户在查询订单历史的时候,我们可以控制在一个月的范围内。</p></li><li><p><strong>读&#x2F;写分离</strong>：经典的数据库拆分方案，主库负责写，从库负责读；</p></li><li><p><strong>拆分表</strong>：分区将数据在物理上分隔开,不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。<br>这样,当对这个表进行查询时,只需要在表分区中进行扫描,而不必进行全表扫描,明显缩短了查询时间,另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘1&#x2F;O，一个精心设置的分区可以将数据传输对磁盘1&#x2F;0竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。</p></li></ul><h3 id="4-9-数据库高并发解决方案"><a href="#4-9-数据库高并发解决方案" class="headerlink" title="4.9 数据库高并发解决方案"></a>4.9 数据库高并发解决方案</h3><p>应对数据库高并发，关键在于优化数据库设计、查询、锁机制、缓存策略和系统配置。</p><ol><li>数据库设计：</li></ol><ul><li>分库分表：将数据分布到多个表或库，减少单一表的负载。</li><li>读写分离：将读操作分配给从库，写操作集中在主库。</li></ul><ol start="2"><li>查询优化：</li></ol><ul><li>索引优化：使用合适的索引，加快查询速度。</li><li>简化查询：减少复杂查询和嵌套子查询。</li></ul><ol start="3"><li>缓存策略：</li></ol><ul><li>应用层缓存：使用 Redis、Memcached 等缓存，减少数据库压力。</li><li>数据库缓存：利用数据库查询缓存，缓存常用查询结果。</li></ul><ol start="4"><li>锁机制优化：</li></ol><ul><li>行级锁：避免表级锁，减少锁竞争。</li><li>乐观锁：减少锁的持有时间。</li></ul><ol start="5"><li>数据库配置和硬件：</li></ol><ul><li>配置优化：调整数据库参数，确保高并发性能。</li><li>硬件资源：确保足够的 CPU、内存和存储，避免瓶颈。</li></ul><ol start="6"><li>监控和调整：</li></ol><ul><li>监控工具：实时监控数据库性能。</li><li>分析慢查询：找出并解决性能瓶颈。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 常识类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake语法</title>
      <link href="/2023/02/28/CMake%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/02/28/CMake%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="CMake-语法"><a href="#CMake-语法" class="headerlink" title="CMake 语法"></a>CMake 语法</h1><h2 id="CMake-简介"><a href="#CMake-简介" class="headerlink" title="CMake 简介"></a>CMake 简介</h2><h3 id="什么是-CMake"><a href="#什么是-CMake" class="headerlink" title="什么是 CMake"></a>什么是 CMake</h3><pre><code>CMake 是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装（编译过程）。他能够输出各种各样的makefile 或者 project 文件，CMake 的配置文件取名为 CMakeLists.txt。也就是在 CMakeLists.txt 这个文件中写 cmake 代码。 一句话：cmake 就是将多个 cpp、hpp 文件组合构建为一个大工程的语言。</code></pre><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><strong>优点：</strong><ul><li>开源，使用类BSD许可发布。</li><li>跨平台，并可以生成 native 编译配置文件，在 Linux&#x2F;Unix 平台，生成 makefile；在苹果平台可以生成 Xcode；在Windows 平台，可以生成 MSVC 的工程文件。</li><li>能够管理大型项目。</li><li>简化编译构建过程和编译过程。cmake 的工具链非常简单：cmake + make。</li><li>高效率，因为 cmake 在工具链中没有 libtool。</li><li>可扩展，可以为 cmake 编写特定功能的模块，扩展 cmake 功能。</li></ul></li><li><strong>缺点：</strong><ul><li>cmake 只是看起来比较简单，而使用并不简单。</li><li>cmake 编写的过程实际上是编程的过程，每个项目使用一个       </li><li>cmake 跟已有体系配合不是特别的理想，比如 pkgconfig。</li></ul></li></ul><h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><p>在 linux 下使用 CMake 生成 Makefile 并编译的流程如下：</p><ol><li>编写 CMake 配置文件 CMakeLists.txt 。</li><li>在 CMakeLists.txt 文件所在目录创建一个 build 文件夹，然后进入目录。（这一步可以省略，但是生成的中间文件不易清理）</li><li>执行命令<code>cmake PATH</code>或者<code>ccmake PATH</code>生成 Makefile（<code>ccmake</code>和<code>cmake</code>的区别在于前者提供了一个交互式的界面）。其中，<code>PATH</code>是 CMakeLists.txt 所在的目录。</li><li>使用<code>make</code>命令进行编译，使用<code>make install</code>进行安装。</li></ol><h2 id="CMake-实战"><a href="#CMake-实战" class="headerlink" title="CMake 实战"></a>CMake 实战</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>以Ubuntu为例：<br>首先，更新本地的软件包索引，以确保获取最新的可用软件包列表。打开终端，并执行以下命令：</p><pre><code class="bash">sudo apt update</code></pre><p>安装 CMake。执行以下命令：</p><pre><code class="bash">sudo apt install cmake</code></pre><p>安装完成后，你可以通过以下命令验证是否成功安装了 CMake：</p><pre><code class="bash">cmake --version</code></pre><p>该命令会显示安装的 CMake 版本信息。</p><p>通过以上步骤，你应该已经成功在 Ubuntu 上安装了 CMake。</p><h3 id="编译单个源文件"><a href="#编译单个源文件" class="headerlink" title="编译单个源文件"></a>编译单个源文件</h3><p>首先查看一下某个示例的目录结构：</p><pre><code>.├── CMakeLists.txt├── main.cpp└── README.adoc</code></pre><p>在本目录下有三个文件，分别是源文件 main.cpp，cmake 构建规则 CMakeLists.txt 以及说明文件 README.adoc，下面来看看他们的具体内容。</p><pre><code class="C++">#include &lt;iostream&gt;int main(int argc, char *argv[])&#123;   std::cout &lt;&lt; &quot;Hello CMake!&quot; &lt;&lt; std::endl;   return 0;&#125;</code></pre><p>源文件是一个简单的 Hello World。</p><pre><code class="cmake">cmake_minimum_required(VERSION 3.10)    # 设CMake最小版本号project(hello_cmake)    # 设置工程名add_executable($&#123;PROJECT_NAME&#125; main.cpp)# 生成可执行文件</code></pre><p>CMakeLists 中主要包含了三个命令：</p><ul><li><code>cmake_minimum_required(VERSION 3.10)</code>：指定运行此配置文件所需的 CMake 的最低版本。</li><li><code>project (hello_cmake)</code>：设置项目的名称，同时会自动生成 PROJECT_NAME 变量，使用 ${PROJECT_NAME} 即可访问到 hello_cmake。</li><li><code>add_executable(hello_cmake main.cpp)</code>：第一个参数是可执行文件名，第二个参数是要编译的源文件列表。z这里将名为 main.cpp 的源文件编译成一个名称为 hello_cmake 的可执行文件。</li></ul><p>接着我们可以开始构建项目，构建的方法有以下两种：</p><ul><li><strong>内部构建</strong>：直接在源文件目录构建项目，会导致临时文件和源代码放在一起，不好清理。</li><li><strong>外部构建</strong>：创建一个可以位于文件系统上任何位置的构建文件夹。 所有临时构建和目标文件都位于此目录中，以保持源代码树的整洁。</li></ul><p>这里以外部构建为例，此时我们需要新建一个构建文件夹 build，并在该目录下运行 cmake 命令进行构建：</p><pre><code class="bash">#创建并进入build目录mkdir build &amp;&amp; cd build#构建当前目录cmake ..#使用cmake生成的makefile编译得到可执行文件make</code></pre><p>此时在当前目录下，就会生成可执行文件 hello_cmake。将其运行查看是否成功编译：</p><pre><code class="bash">./hello_cmakeHello CMake!</code></pre><h3 id="编译多个源文件"><a href="#编译多个源文件" class="headerlink" title="编译多个源文件"></a>编译多个源文件</h3><h4 id="单个目录下的多个源文件"><a href="#单个目录下的多个源文件" class="headerlink" title="单个目录下的多个源文件"></a>单个目录下的多个源文件</h4><p>首先查看一下本示例的目录结构：</p><pre><code>.├── CMakeLists.txt├── main.cc├── MathFunctions.cc└── MathFunctions.h</code></pre><p>与上个示例不同，本示例在单个目录下有着多个源文件，此时 CMakeLists 如下：</p><pre><code class="cmake"># CMake 最低版本号要求cmake_minimum_required (VERSION 3.10)# 项目信息project (Demo2)# 查找目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable($&#123;PROJECT_NAME&#125; $&#123;DIR_SRCS&#125;)</code></pre><p>在本示例中，为了避免一个个将所有源文件输入，使用了 aux_source_directory 命令。</p><ul><li><code>aux_source_directory</code>：第一个参数是目录的路径，第二个参数是变量名。当我们使用这个命令时，就会将指定目录下的所有源文件保存到指定的变量名中。<br>如果不想使用这种方法，而是向一条条枚举每个变量，可以使用 set 来手动将源文件保存到变量名中：</li></ul><pre><code class="cmake"># CMake 最低版本号要求cmake_minimum_required (VERSION 3.10)# 项目信息project (Demo2)set(DIR_SRCS    MathFunctions.cc    main.cc)# 指定生成目标add_executable($&#123;PROJECT_NAME&#125; $&#123;DIR_SRCS&#125;)</code></pre><h4 id="多个目录下的多个源文件"><a href="#多个目录下的多个源文件" class="headerlink" title="多个目录下的多个源文件"></a>多个目录下的多个源文件</h4><p>首先查看一下本示例的目录结构：</p><pre><code>.├── CMakeLists.txt├── main.cc└── math    ├── CMakeLists.txt    ├── MathFunctions.cc    └── MathFunctions.h</code></pre><p>与上个示例不同，本示例在多个目录下有着多个源文件。在这种情况下，我们需要在每个目录中都编写一个 CMakeLists.txt。这里为了方便，我们可以将 math 里的文件编译为一个静态库再有 main 函数调用。</p><p>首先看看 math 目录下的 CMakeLists.txt，这里主要做的事是将当前目录下的文件编译为一个静态库：</p><pre><code class="cmake"># 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量aux_source_directory(. DIR_LIB_SRCS)# 指定生成 MathFunctions 链接库add_library (MathFunctions $&#123;DIR_LIB_SRCS&#125;)</code></pre><ul><li><code>add_library</code>：用于从某些源文件创建一个库，默认生成在构建文件夹。第一个参数为库名（不需要 lib 前缀，会自动添加），第二个参数用于指定 SHARED（动态库），STATIC（静态库）（如果不写，则通过全局的BUILD_SHARED_LIBS 的 FALSE 或 TRUE 来指定）。第三个参数即为源文件列表。</li></ul><p>接着看看根目录的 CMakeLists.txt：</p><pre><code class="cmake"># CMake 最低版本号要求cmake_minimum_required (VERSION 3.10)# 项目信息project (Demo3)# 查找目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 添加 math 子目录add_subdirectory(math)# 指定生成目标add_executable(Demo $&#123;DIR_SRCS&#125;)# 添加链接库target_link_libraries(Demo MathFunctions)</code></pre><ul><li><code>add_subdirectory</code>：用于表示该项目包含一个子目录，此时会去处理子目录下的 CMakeLists.txt 与源文件。</li><li><code>target_link_libraries</code>：该命令用于指明可执行文件 Demo 需要链接 MathFunctions 库。第一个参数为可执行文件名，第二个参数为访问权限（PUBLIC、PRIVATE、INTERFACE，默认为 PUBLIC），第三个参数为库名（这两个参数可以为多个）。</li></ul><h3 id="导入外部库"><a href="#导入外部库" class="headerlink" title="导入外部库"></a>导入外部库</h3><h4 id="本地导入（find-package）"><a href="#本地导入（find-package）" class="headerlink" title="本地导入（find_package）"></a>本地导入（find_package）</h4><p>首先查看一下本示例的目录结构：</p><pre><code>.├── CMakeLists.txt├── main.cpp└── README.adoc</code></pre><p>这里主要演示如何导入一个本地的第三方库（这里以 boost 为例），接着看看 MakeLists.txt：</p><pre><code class="cmake">cmake_minimum_required(VERSION 3.10)# Set the project nameproject (third_party_include)# find a boost install with the libraries filesystem and system#使用库文件系统和系统查找boost installfind_package(Boost 1.46.1 REQUIRED COMPONENTS filesystem system)#这是第三方库，而不是自己生成的静态动态库# check if boost was foundif(Boost_FOUND)    message (&quot;boost found&quot;)else()    message (FATAL_ERROR &quot;Cannot find Boost&quot;)endif()# Add an executableadd_executable(third_party_include main.cpp)# link against the boost librariestarget_link_libraries(third_party_include PRIVATE Boost::filesystem)</code></pre><p>这里使用<code>find_package</code>命令来在本地搜索对应的第三方库，Boost 代表需要查询的库名称；1.46.1 代表需要库的最低版本；REQUIRED 表示该库是必须的，如果找不到会报错；COMPONENTS 用于检测该库的对应组件是否存在，如果不存在则认为找到的库不满足条件。</p><h4 id="外部导入（FetchContent）"><a href="#外部导入（FetchContent）" class="headerlink" title="外部导入（FetchContent）"></a>外部导入（FetchContent）</h4><p><code>FetchContent</code>是<code>3.11.0</code>版本开始提供的功能，只需要一个<code>URL</code>或者<code>Git仓库</code>即可引入一个库，这里以 GoogleTest 库为例：</p><pre><code class="cmake">cmake_minimum_required(VERSION 3.14)project(my_project)# GoogleTest requires at least C++11set(CMAKE_CXX_STANDARD 11)include(FetchContent)FetchContent_Declare(  googletest  URL https://github.com/google/googletest/archive/609281088cfefc76f9d0ce82e1ff6c30cc3591e5.zip)# For Windows: Prevent overriding the parent project&#39;s compiler/linker settingsset(gtest_force_shared_crt ON CACHE BOOL &quot;&quot; FORCE)FetchContent_MakeAvailable(googletest)</code></pre><p>使用方法：</p><ol><li><code>include(FetchContent) </code>：表示引入 FetchContent。</li><li><code>FetchContent_Declare(第三方库)</code> ：获取第三方库，可以是一个 URL 或者一个 Git 仓库。</li><li><code>FetchContent_MakeAvailable(第三方库)</code> ：将这个第三方库引入项目。</li><li><code>target_link_libraries(主项目 PRIVATE 子模块::子模块) </code>：链接这个第三方库。</li></ol><h3 id="测试与安装"><a href="#测试与安装" class="headerlink" title="测试与安装"></a>测试与安装</h3><p>CMake 也可以指定安装规则，以及添加测试。这两个功能分别可以通过在产生 Makefile 后使用<code>make install</code>和<code>make test</code>来执行。<br>首先查看一下本示例的目录结构：</p><pre><code>.├── CMakeLists.txt├── config.h.in├── License.txt├── main.cc└── math    ├── CMakeLists.txt    ├── MathFunctions.cc    └── MathFunctions.h</code></pre><h4 id="自定义安装规则"><a href="#自定义安装规则" class="headerlink" title="自定义安装规则"></a>自定义安装规则</h4><p>首先查看 math 目录下的 CMakeLists.txt：</p><pre><code class="cmake"># 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量aux_source_directory(. DIR_LIB_SRCS)# 指定生成 MathFunctions 链接库add_library (MathFunctions $&#123;DIR_LIB_SRCS&#125;)# 指定 MathFunctions 库的安装路径install (TARGETS MathFunctions DESTINATION lib)install (FILES MathFunctions.h DESTINATION include)</code></pre><p>这里使用<code>install</code>命令表明了将静态库 MathFunctions 安装到 &#x2F;usr&#x2F;local&#x2F;lib 目录下，将头文件 MathFunctions.h 安装到 &#x2F;usr&#x2F;local&#x2F;include 目录下。</p><p>接着查看根目录的 install 内容：</p><pre><code class="cmake"># 指定安装路径install (TARGETS Demo DESTINATION bin)install (FILES &quot;$&#123;PROJECT_BINARY_DIR&#125;/config.h&quot; DESTINATION include)</code></pre><p>这里将可执行程序 Demo 安装到了 &#x2F;usr&#x2F;local&#x2F;lib 目录下，再将 config.h 安装到 &#x2F;usr&#x2F;local&#x2F;lib 目录下。</p><blockquote><p>&#x2F;usr&#x2F;local&#x2F; 是默认安装的根目录，可以通过修改 CMAKE_INSTALL_PREFIX 变量的值来指定这些文件应该拷贝到哪个根目录</p></blockquote><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>CMake 提供了一个称为<code>CTest</code>的测试工具。我们要做的只是在项目根目录的 CMakeLists 文件中调用一系列的<code>add_test</code>命令。</p><pre><code class="cmake"># 启用测试enable_testing()# 测试程序是否成功运行add_test (test_run Demo 5 2)# 测试帮助信息是否可以正常提示add_test (test_usage Demo)set_tests_properties (test_usage  PROPERTIES PASS_REGULAR_EXPRESSION &quot;Usage: .* base exponent&quot;)# 测试 5 的平方# add_test (test_5_2 Demo 5 2)# set_tests_properties (test_5_2#  PROPERTIES PASS_REGULAR_EXPRESSION &quot;is 25&quot;)# 测试 10 的 5 次方# add_test (test_10_5 Demo 10 5)# set_tests_properties (test_10_5#  PROPERTIES PASS_REGULAR_EXPRESSION &quot;is 100000&quot;)# 测试 2 的 10 次方# add_test (test_2_10 Demo 2 10)# set_tests_properties (test_2_10#  PROPERTIES PASS_REGULAR_EXPRESSION &quot;is 1024&quot;)# 定义一个宏，用来简化测试工作macro (do_test arg1 arg2 result)  add_test (test_$&#123;  arg1&#125;_$&#123;  arg2&#125; Demo $&#123;  arg1&#125; $&#123;  arg2&#125;)  set_tests_properties (test_$&#123;  arg1&#125;_$&#123;  arg2&#125;    PROPERTIES PASS_REGULAR_EXPRESSION $&#123;  result&#125;)endmacro (do_test)# 利用 do_test 宏，测试一系列数据do_test (5 2 &quot;is 25&quot;)do_test (10 5 &quot;is 100000&quot;)do_test (2 10 &quot;is 1024&quot;)</code></pre><ul><li><code>enable_testing</code>：用于启动测试。</li><li><code>add_test</code>：用于添加测试，第一个参数为测试名，第二个参数为可执行程序，剩下的为可执行程序的参数。</li><li><code>set_tests_properties</code>：测试的提示信息。</li><li><code>macro</code>：宏，用于编写一个重复性操作来简化测试用例的编写。</li><li><code>do_test</code>：编写的测试宏。</li></ul><h4 id="生成安装包"><a href="#生成安装包" class="headerlink" title="生成安装包"></a>生成安装包</h4><p>如果想要生成安装包，则需要使用<code>CPack</code>，它是由 CMake 提供的一个工具，专门用于打包。此时需要在 CMakeLists.txt 中添加以下内容：</p><pre><code class="cmake"># 构建一个 CPack 安装包include (InstallRequiredSystemLibraries)set (CPACK_RESOURCE_FILE_LICENSE  &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/License.txt&quot;)set (CPACK_PACKAGE_VERSION_MAJOR &quot;$&#123;Demo_VERSION_MAJOR&#125;&quot;)set (CPACK_PACKAGE_VERSION_MINOR &quot;$&#123;Demo_VERSION_MINOR&#125;&quot;)include (CPack)</code></pre><ul><li><code>include (InstallRequiredSystemLibraries)</code>：导入 InstallRequiredSystemLibraries 模块。</li><li>设置一些 CPack 相关变量。</li><li><code>include (CPack)</code>：导入 CPack 模块。</li></ul><p>接着执行 cmake 和 make 构建工程，此时再执行 cpack 命令即可生成安装包：</p><pre><code class="cmake">#生成二进制安装包cpack -C CPackConfig.cmake#生成源码安装包cpack -C CPackSourceConfig.cmake</code></pre><p>当命令执行成功后，就会在当前目录下生成 <em>.sh、</em>.tar.gz、*.tar.Z 这三个格式的安装包。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmake </tag>
            
            <tag> make </tag>
            
            <tag> 程序构建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="1-HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）"><a href="#1-HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）" class="headerlink" title="1.HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）"></a>1.HTTPS是如何保证数据传输的安全，整体的流程是什么？（SSL是怎么工作保证安全的）</h2><ol><li><p>客户端Hello: 客户端向服务器发送一个消息，其中包含SSL版本、加密算法等信息。</p></li><li><p>服务器Hello: 服务器接收到客户端的消息后，选择加密算法，并向客户端发送确认信息，也包含了服务器的SSL证书。</p></li><li><p>证书验证: 客户端收到服务器发送的SSL证书后，验证其有效性。这包括检查证书是否由受信任的证书颁发机构（CA）签发，以及检查证书是否已过期或被撤销。</p></li><li><p>生成共享密钥: 客户端生成一个随机的对称密钥，用于加密通信。该密钥将使用服务器的公钥加密，并发送给服务器。</p></li><li><p>密钥交换: 服务器使用其私钥解密客户端发送的共享密钥。</p></li><li><p>握手完成: 至此，SSL握手完成。双方现在都具有了用于加密和解密通信的共享密钥，可以开始安全地进行数据传输。</p></li></ol><p>因为数字签名、摘要是证书防伪非常关键的武器。 “摘要”就是对传输的内容，通过hash算法计算出一段固定长度的串。然后，通过发送方的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名”</p><p>SSL&#x2F;TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><blockquote><p>补充：SSL&#x2F;TLS的四次握手，目前网上的主流答案都在重复阮一峰老师的博客，属于TLS 1.0版本的答案，使用RSA密钥交换算法。但是现在TLS 1.2已经成为主流，使用<code>ECDHE算法</code>，如果面试可以说出这个版本的答案，应该会更好。</p></blockquote><h2 id="2-如何保证公钥不被篡改？"><a href="#2-如何保证公钥不被篡改？" class="headerlink" title="2.如何保证公钥不被篡改？"></a>2.如何保证公钥不被篡改？</h2><p>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p><h2 id="3-Cookie是什么？"><a href="#3-Cookie是什么？" class="headerlink" title="3.Cookie是什么？"></a>3.Cookie是什么？</h2><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务，HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。</p><p>新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><p>cookie 的出现是因为 HTTP 是无状态的一种协议，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，cookie 的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够 cookie 认出你。</p><h2 id="4-Session知识大总结"><a href="#4-Session知识大总结" class="headerlink" title="4.Session知识大总结"></a>4.Session知识大总结</h2><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>使用 Session 维护用户登录状态的过程如下：</p><ol><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。<blockquote><p>注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p></blockquote></li></ol><h2 id="5-Cookie与Session的对比"><a href="#5-Cookie与Session的对比" class="headerlink" title="5.Cookie与Session的对比"></a>5.Cookie与Session的对比</h2><p>HTTP作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下Cookie和Session。</p><ul><li><p><strong>Cookie</strong><br>  Cookie是客户端保持状态的方法。  </p><p>  Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。</p><p>  除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。</p></li><li><p><strong>Session</strong>  </p><p>  Session是服务器保持状态的方法。</p><p>  首先需要明确的是，Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。</p></li></ul><p>当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了Cookie，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如sid&#x3D;xxxxx这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了。</p><h2 id="6-SQL注入攻击了解吗？"><a href="#6-SQL注入攻击了解吗？" class="headerlink" title="6.SQL注入攻击了解吗？"></a>6.SQL注入攻击了解吗？</h2><p>攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。 用户登录，输入用户名 lianggzone，密码 ‘ or ‘1’&#x3D;’1 ，如果此时使用参数构造的方式，就会出现 select * from user where name &#x3D; ‘lianggzone’ and password &#x3D; ‘’ or ‘1’&#x3D;‘1’ 不管用户名和密码是什么内容，使查询出来的用户列表不为空。如何防范SQL注入攻击使用预编译的PrepareStatement是必须的，但是一般我们会从两个方面同时入手。 </p><ol><li>Web端 <ul><li>有效性检验。</li><li>限制字符串输入的长度。</li></ul></li><li>服务端 <ul><li>不用拼接SQL字符串。</li><li>使用预编译的PrepareStatement。 </li><li>有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求) </li><li>过滤SQL需要的参数中的特殊字符。比如单引号、双引号。</li></ul></li></ol><h2 id="7-网络的七层模型与各自的功能"><a href="#7-网络的七层模型与各自的功能" class="headerlink" title="7.网络的七层模型与各自的功能"></a>7.网络的七层模型与各自的功能</h2><p><img src="/2023/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI1.png"><br><img src="/2023/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI2.png"></p><h2 id="8-什么是DHCP？工作原理？"><a href="#8-什么是DHCP？工作原理？" class="headerlink" title="8.什么是DHCP？工作原理？"></a>8.什么是DHCP？工作原理？</h2><p>DHCP（Dynamic Host Configuration Protocol）是一种网络协议，用于动态分配IP地址以及其他网络配置信息给计算机、网络设备和其他客户端设备。DHCP的主要作用是简化网络管理，提供灵活的IP地址分配方案，并降低了网络配置的复杂性。</p><p>以下是DHCP的基本工作原理：</p><ol><li><p>客户端请求：当一个设备加入网络或者需要更新网络配置时，它会向网络中的DHCP服务器发送一个 DHCP 请求。</p></li><li><p>DHCP Discover（发现）：客户端发送一个广播消息到网络上的所有DHCP服务器，请求IP地址分配和其他配置信息。这个消息称为 DHCP Discover 报文。</p></li><li><p>DHCP Offer（提供）：DHCP服务器收到客户端的 DHCP Discover 请求后，会回复一个 DHCP Offer 报文，其中包含了可用的IP地址以及其他配置信息，如子网掩码、默认网关、DNS服务器等。通常情况下，网络中可能有多个DHCP服务器，但是客户端只会选择其中一个DHCP Offer。</p></li><li><p>DHCP Request（请求）：客户端选择一个DHCP Offer，并向提供这个 Offer 的DHCP服务器发送一个 DHCP Request 报文，确认并请求分配相应的IP地址和配置信息。</p></li><li><p>DHCP Acknowledgment（确认）：DHCP服务器收到客户端的 DHCP Request 后，会向客户端发送一个 DHCP Acknowledgment 报文，确认分配给客户端的IP地址和配置信息。同时，DHCP服务器会在自己的地址租用表中记录下客户端的分配情况，以便将来的续约和管理。</p></li><li><p>IP地址租用：客户端在收到 DHCP Acknowledgment 后，会配置自己的网络接口，使用分配到的IP地址和其他配置信息进行通信。分配给客户端的IP地址是有限期的，称为租用期，一般在一段时间后过期。在IP地址租用期内，客户端可以使用这个IP地址。当租用期快要到期时，客户端可以向DHCP服务器发送续约请求，以延长租用期。</p></li></ol><p>通过DHCP，网络管理员可以集中管理IP地址和其他网络配置信息，动态地为网络中的设备分配IP地址，从而提高了网络的灵活性和可管理性。</p><h2 id="9-DNS查询方式有哪些？"><a href="#9-DNS查询方式有哪些？" class="headerlink" title="9.DNS查询方式有哪些？"></a>9.DNS查询方式有哪些？</h2><ul><li><p>递归解析<br>当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。</p></li><li><p>迭代解析<br>当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。</p></li></ul><h2 id="10-HTTP中缓存的私有和共有字段？知道吗？"><a href="#10-HTTP中缓存的私有和共有字段？知道吗？" class="headerlink" title="10.HTTP中缓存的私有和共有字段？知道吗？"></a>10.HTTP中缓存的私有和共有字段？知道吗？</h2><ul><li>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</li></ul><pre><code>Cache-Control: private</code></pre><ul><li>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</li></ul><pre><code>Cache-Control: public</code></pre><h2 id="11-GET-方法参数写法是固定的吗？"><a href="#11-GET-方法参数写法是固定的吗？" class="headerlink" title="11.GET 方法参数写法是固定的吗？"></a>11.GET 方法参数写法是固定的吗？</h2><p>在约定中，我们的参数是写在 ? 后面，用 &amp; 分割。</p><p>我们知道，解析报文的过程是通过获取 TCP 数据，用正则等工具从数据中获取 Header 和 Body，从而提取参数。</p><p>比如header请求头中添加token，来验证用户是否登录等权限问题。</p><p>也就是说，我们可以自己约定参数的写法，只要服务端能够解释出来就行，万变不离其宗。</p><h2 id="12-GET-方法的长度限制是怎么回事？"><a href="#12-GET-方法的长度限制是怎么回事？" class="headerlink" title="12.GET 方法的长度限制是怎么回事？"></a>12.GET 方法的长度限制是怎么回事？</h2><p>网络上都会提到浏览器地址栏输入的参数是有限的。</p><p>首先说明一点，HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。</p><p>浏览器原因就不说了，服务器是因为处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。</p><h2 id="13-DDoS-攻击"><a href="#13-DDoS-攻击" class="headerlink" title="13.DDoS 攻击"></a>13.DDoS 攻击</h2><blockquote><p>DoS（Denial of Service）与DDoS（Distributed Denial of Service）区别，DOS是单一源，DDOS是分布式。</p></blockquote><p>DDoS（Distributed Denial of Service）攻击是一种网络攻击，旨在使目标系统无法提供正常的服务。在 DDoS 攻击中，攻击者利用大量的计算机或设备，通过同时向目标系统发送大量的请求或数据流量，耗尽目标系统的网络带宽、计算资源或其他系统资源，从而使其无法正常工作或提供服务。</p><p>以下是 DDoS 攻击的一般工作原理和特点：</p><ol><li><p>分布式攻击：DDoS 攻击通常利用大量分布在不同地理位置的计算机或设备，通过这些分布式的攻击节点向目标系统发起攻击。这些攻击节点被攻击者控制，组成了一个庞大的攻击网络。</p></li><li><p>洪水式攻击：DDoS 攻击通常采用洪水式（Flood）攻击方法，向目标系统发送大量的无效请求或数据包，以耗尽目标系统的网络带宽和资源。这些请求可能是 HTTP 请求、UDP 数据包、TCP SYN 数据包等。</p></li><li><p>层次化攻击：DDoS 攻击可以针对目标系统的不同层次进行攻击，包括网络层、传输层和应用层。例如，网络层攻击可以是对网络带宽的洪水攻击，传输层攻击可以是对 TCP 连接的 SYN 攻击，应用层攻击可以是对 Web 服务器的 HTTP 请求洪水攻击。</p></li><li><p>伪装和欺骗：攻击者可能会伪装攻击流量的源地址，使得目标系统难以识别和过滤攻击流量。此外，攻击者可能会利用反射攻击或放大攻击来增加攻击流量的规模。</p></li><li><p>目标多样性：DDoS 攻击的目标可以是任何连接到互联网的系统，包括网站、服务器、网络设备、云服务等。攻击目标通常是具有重要性或影响力的系统，以实现攻击者的目的。</p></li></ol><p>为了应对 DDoS 攻击，组织和个人可以采取各种防御措施，包括网络流量过滤、入侵检测和防御系统（IDS&#x2F;IPS）、使用 CDN（内容分发网络）、增强系统的容错性和弹性等。</p><h2 id="14-MTU和MSS分别是什么？"><a href="#14-MTU和MSS分别是什么？" class="headerlink" title="14.MTU和MSS分别是什么？"></a>14.MTU和MSS分别是什么？</h2><ul><li><p>MTU（Maximum Transmission Unit）是指在计算机网络中，数据链路层或网络层可以传输的最大数据包大小。简单来说，它表示在某个网络上一次能够传输的最大数据量，以字节为单位。MTU 的大小取决于网络技术和设备的规范，不同类型的网络通常具有不同的 MTU 值。</p></li><li><p>MSS（Maximum Segment Size）是指在 TCP 协议中，TCP 数据包中的 TCP 数据段的最大允许大小。由于在 TCP 通信中，数据通常被分割成多个 TCP 数据段进行传输，而每个 TCP 数据段的大小受限于 MTU 大小，因此 MSS 通常是 <code>MTU 减去 TCP 头部和 IP 头部的大小</code>。MSS 可以通过 TCP 握手阶段进行协商，并在后续的 TCP 通信中被使用。</p></li></ul><p>总的来说，MTU 表示网络传输中数据包的最大大小，而 MSS 表示 TCP 数据包中 TCP 数据段的最大大小。MTU 和 MSS 在网络通信中扮演着重要的角色，特别是在处理分段和分包的过程中。</p><h2 id="15-TCP头部中有哪些信息？"><a href="#15-TCP头部中有哪些信息？" class="headerlink" title="15.TCP头部中有哪些信息？"></a>15.TCP头部中有哪些信息？</h2><ol><li><p>源端口（Source Port）：占 16 位，用于标识发送方的端口号。</p></li><li><p>目标端口（Destination Port）：占 16 位，用于标识接收方的端口号。</p></li><li><p>序列号（Sequence Number）：占 32 位，用于标识 TCP 报文段中第一个数据字节的序号。序列号用于 TCP 的可靠传输机制，用于对报文段进行排序和重组。</p></li><li><p>确认号（Acknowledgment Number）：占 32 位，用于指示期望接收的下一个序列号。确认号用于 TCP 的可靠传输机制，用于确认接收到的报文段。</p></li><li><p>数据偏移（Data Offset）：占 4 位，表示 TCP 头部的长度，以 4 字节为单位。由于 TCP 头部长度可变，因此需要该字段来指示 TCP 头部的结束位置。</p></li><li><p>保留（Reserved）：占 6 位，保留用于将来的扩展。</p></li><li><p>控制标志（Flags）：包括以下控制标志，每个标志占 1 位：<br> URG：紧急指针（Urgent Pointer）有效。<br> ACK：确认序号有效。<br> PSH：推送数据。<br> RST：重置连接。<br> SYN：发起连接。<br> FIN：结束连接。  </p></li><li><p>窗口大小（Window Size）：占 16 位，用于指示发送方的接收窗口大小。接收窗口大小用于流量控制，用于指示发送方可以发送多少数据而不会导致接收方溢出。</p></li><li><p>校验和（Checksum）：占 16 位，用于检测 TCP 报文段是否在传输过程中发生了错误。</p></li><li><p>紧急指针（Urgent Pointer）：占 16 位，仅当 URG 标志被设置时有效。用于指示紧急数据的结束位置。</p></li><li><p>选项（Options）：可选字段，用于在 TCP 报文段中包含一些可选的信息，如最大报文段大小（MSS）、窗口扩大因子等。</p></li></ol><p>这些信息字段中的大多数都是 TCP 协议用于控制连接的传输过程和维护连接状态的。通过这些信息字段，TCP 协议能够提供可靠的、有序的、全双工的数据传输服务。</p><h2 id="16-常见TCP的连接状态有哪些？"><a href="#16-常见TCP的连接状态有哪些？" class="headerlink" title="16.常见TCP的连接状态有哪些？"></a>16.常见TCP的连接状态有哪些？</h2><ol><li><p>CLOSED（关闭）：初始状态，表示连接未被建立或已经终止。</p></li><li><p>LISTEN（监听）：服务器进入此状态，等待客户端连接请求。</p></li><li><p>SYN_SENT（同步已发送）：客户端发送SYN报文段以启动连接请求，并等待服务器的确认。</p></li><li><p>SYN_RECEIVED（同步已接收）：服务器收到客户端的SYN报文段，并发送自己的SYN和ACK报文段，以确认连接请求。</p></li><li><p>ESTABLISHED（已建立）：连接已经建立，双方可以进行数据传输。</p></li><li><p>FIN_WAIT_1（终止等待1）：客户端发送FIN报文段以关闭连接，等待服务器的确认。</p></li><li><p>FIN_WAIT_2（终止等待2）：客户端已经收到了服务器的确认，等待服务器发送自己的FIN报文段。</p></li><li><p>CLOSE_WAIT（关闭等待）：服务器收到客户端的FIN报文段，并发送自己的确认，等待客户端关闭连接。</p></li><li><p>CLOSING（关闭中）：双方同时发送了FIN报文段，等待对方的确认。</p></li><li><p>LAST_ACK（最后确认）：服务器发送FIN报文段，等待客户端的确认。</p></li><li><p>TIME_WAIT（时间等待）：连接已经关闭，等待可能延迟的数据报文段在网络中消失。这是为了防止出现重复的数据包，通常会在一段时间后自动释放。</p></li><li><p>CLOSE（关闭）：最终状态，连接已经完全关闭。</p></li></ol><p>这些状态描述了TCP连接在建立、数据传输和终止过程中的各种状态转换。不同的状态之间的转换是通过发送特定的TCP报文段来实现的。</p><h2 id="17-应用层常见协议知道多少？了解几个？"><a href="#17-应用层常见协议知道多少？了解几个？" class="headerlink" title="17.应用层常见协议知道多少？了解几个？"></a>17.应用层常见协议知道多少？了解几个？</h2><table><thead><tr><th>协议</th><th>名称</th><th>默认端口</th><th>底层协议</th></tr></thead><tbody><tr><td>HTTP</td><td>超文本传输协议</td><td>80</td><td>TCP</td></tr><tr><td>HTTPS</td><td>超文本传输安全协议</td><td>443</td><td>TCP</td></tr><tr><td>Telnet</td><td>远程登录服务的标准协议</td><td>23</td><td>TCP</td></tr><tr><td>FTP</td><td>文件传输协议</td><td>20传输和21连接</td><td>TCP</td></tr><tr><td>TFTP</td><td>简单文件传输协议</td><td>69</td><td>UDP</td></tr><tr><td>SMTP</td><td>简单邮件传输协议（发送用）</td><td>25</td><td>TCP</td></tr><tr><td>POP</td><td>邮局协议（接收用）</td><td>110</td><td>TCP</td></tr><tr><td>DNS</td><td>域名解析服务</td><td>53</td><td>服务器间进行域传输的时候用TCP 客户端查询DNS服务器时用 UDP</td></tr></tbody></table><h2 id="18-浏览器在与服务器建立了一个-TCP-连接后是否会在一个-HTTP-请求完成后断开？什么情况下会断开？"><a href="#18-浏览器在与服务器建立了一个-TCP-连接后是否会在一个-HTTP-请求完成后断开？什么情况下会断开？" class="headerlink" title="18.浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？"></a>18.浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</h2><p>在 HTTP&#x2F;1.0 中，一个服务器在发送完一个 HTTP 响应后，会断开 TCP 链接。但是这样每次请求都会重新建立和断开 TCP 连接，代价过大。所以虽然标准中没有设定，某些服务器对 Connection: keep-alive 的 Header 进行了支持。意思是说，完成这个 HTTP 请求之后，不要断开 HTTP 请求使用的 TCP 连接。这样的好处是连接可以被重新使用，之后发送 HTTP 请求的时候不需要重新建立 TCP 连接，以及如果维持连接，那么 SSL 的开销也可以避免。</p><p>持久连接：既然维持 TCP 连接好处这么多，HTTP&#x2F;1.1 就把 Connection 头写进标准，并且默认开启持久连接，除非请求中写明 Connection: close，那么浏览器和服务器之间是会维持一段时间的 TCP 连接，不会一个请求结束就断掉。</p><p>默认情况下建立 TCP 连接不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接。</p><h2 id="19-三次握手"><a href="#19-三次握手" class="headerlink" title="19.三次握手"></a>19.三次握手</h2><p><img src="/2023/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/handshake.png"></p><p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态，进行三次握手：</p><ul><li><p>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 <code>SYN_SEND</code> 状态。</p><p>  首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</p></li><li><p>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 <code>SYN_RCVD</code> 的状态。</p><p>  在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y。</p></li><li><p>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 <code>ESTABLISHED</code> 状态。服务器收到 ACK 报文之后，也处于 <code>ESTABLISHED</code> 状态，此时，双方已建立起了连接。</p><p>  确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p></li></ul><p>发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。</p><p>在socket编程中，客户端执行connect()时，将触发三次握手。</p><h2 id="20-什么是半连接队列？"><a href="#20-什么是半连接队列？" class="headerlink" title="20.什么是半连接队列？"></a>20.什么是半连接队列？</h2><p>半连接队列（Half-open connection queue），也称为半连接队列或半打开连接队列，是指TCP协议中用于存放未完成三次握手过程的连接请求的队列。在TCP的三次握手握手过程中，当客户端向服务器发送SYN报文段（同步序列号），服务器收到后会回复一个SYN+ACK报文段（同步序列号+确认序号），此时连接处于半开（Half-open）状态。在正常情况下，服务器会等待客户端发送最后的ACK报文段以完成握手，建立完全的TCP连接。</p><p><code>半连接队列</code>的作用是临时存放未完成的连接请求，等待服务器进程处理。当服务器的连接请求队列已满或者服务器进程无法及时处理连接请求时，新的连接请求将会被放置在半连接队列中，暂时保持半开状态。一旦服务器进程准备好处理连接请求，它会从半连接队列中取出连接请求，完成后续的握手过程，建立完整的TCP连接。</p><p>半连接队列的大小是有限制的，通常由操作系统的配置参数决定。如果半连接队列已满而新的连接请求到达，则服务器会拒绝这些连接请求，导致客户端收到连接超时或拒绝连接的错误。因此，合理调整半连接队列的大小对于保障服务器的稳定运行至关重要。</p><h2 id="21-ISN-Initial-Sequence-Number-是固定的吗？"><a href="#21-ISN-Initial-Sequence-Number-是固定的吗？" class="headerlink" title="21. ISN(Initial Sequence Number)是固定的吗？"></a>21. ISN(Initial Sequence Number)是固定的吗？</h2><p>不，ISN（Initial Sequence Number）并不是固定的，它是在建立TCP连接时动态生成的一个随机值。ISN的目的是确保每个TCP连接都有一个唯一的起始序号，以防止重放攻击等安全问题。</p><blockquote><p>重放攻击是一种常见的网络攻击方式，攻击者通过截获和重新发送先前成功的通信数据包，以达到非法获取信息、欺骗系统或者拒绝服务的目的。</p></blockquote><p>在TCP连接的建立过程中，客户端和服务器各自选择一个ISN值。通常情况下，ISN是基于当前的时间戳和一些其他随机因素生成的，这样可以尽可能地避免ISN的重复和可预测性。</p><p>通过随机生成ISN，可以增加攻击者猜测ISN的难度，提高TCP连接的安全性。如果ISN是固定的或者可预测的，攻击者可能会利用这个信息来实施攻击，例如重放攻击、序列号猜测攻击等。因此，生成随机的ISN对于TCP连接的安全性至关重要。</p><h2 id="22-三次握手过程中可以携带数据吗？"><a href="#22-三次握手过程中可以携带数据吗？" class="headerlink" title="22.三次握手过程中可以携带数据吗？"></a>22.三次握手过程中可以携带数据吗？</h2><p>在TCP的三次握手过程中，通常不会携带数据。三次握手的主要目的是建立起客户端和服务器之间的连接，并协商一些连接参数，例如序列号等。</p><p>虽然报文段中会携带一些连接参数，但通常不会携带实际的数据。这是因为在三次握手过程中，客户端和服务器还没有建立起完全的TCP连接，因此还不能进行数据传输。只有在三次握手完成后，建立了完整的TCP连接之后，客户端和服务器才能开始进行数据传输。</p><p>并且，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。</p><p>然而，在某些情况下，TCP协议的实现可能允许在三次握手的过程中携带少量的数据，这通常被称为<code>零窗口探测</code>。零窗口探测是为了解决一些特殊情况下的问题，例如当客户端和服务器都处于空闲状态，但服务器需要客户端发送一些数据来更新连接状态。在这种情况下，服务器可能会允许在SYN和SYN+ACK报文段中携带少量的数据。</p><h2 id="23-SYN攻击是什么？"><a href="#23-SYN攻击是什么？" class="headerlink" title="23.SYN攻击是什么？"></a>23.SYN攻击是什么？</h2><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 <code>DoS/DDoS</code> 攻击。</p><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux&#x2F;Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p><pre><code class="bash">netstat -n -p TCP | grep SYN_RECV</code></pre><p>常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）时间  </li><li>增加最大半连接数  </li><li>过滤网关防护  </li><li>SYN cookies技术</li></ul><h2 id="24-四次挥手相关内容"><a href="#24-四次挥手相关内容" class="headerlink" title="24.四次挥手相关内容"></a>24.四次挥手相关内容</h2><p><img src="/2023/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wave.png"><br>建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭（half-close）造成的。所谓的<code>半关闭</code>，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。</p><ol><li><p>第一次挥手（FIN1）：发送方（一般是客户端）向接收方（一般是服务器）发送一个FIN（Finish）报文段，表示发送方已经完成数据的发送，但仍然可以接收数据。</p></li><li><p>第二次挥手（ACK1）：接收方收到第一次挥手的FIN报文段后，会发送一个ACK（Acknowledgment）报文段作为确认，表示已经收到了发送方的关闭请求，并且同意关闭连接。</p></li><li><p>第三次挥手（FIN2）：接收方也可以在发送第二次挥手的ACK报文段之后，向发送方发送一个FIN报文段，表示接收方也已经完成数据的发送，但仍然可以接收数据。</p></li><li><p>第四次挥手（ACK2）：发送方收到第三次挥手的FIN报文段后，会发送一个ACK报文段作为确认，表示已经收到了接收方的关闭请求，并且同意关闭连接。此时连接处于完全关闭状态，双方都不再发送数据。</p></li></ol><p>需要注意的是，四次挥手过程中的ACK报文段可能携带数据，用于确认收到上一步的挥手请求。在第三次挥手和第四次挥手过程中，ACK报文段可以携带之前接收到的最后一批数据的确认序号。</p><p>四次挥手的目的是确保双方都能够确认连接的关闭，并且在关闭之前完成所有的数据传输。这个过程可以防止连接过早地关闭，导致数据丢失或者中断。</p><h2 id="25-对于FIN-WAIT-2，CLOSE-WAIT状态和TIME-WAIT状态？你知道多少"><a href="#25-对于FIN-WAIT-2，CLOSE-WAIT状态和TIME-WAIT状态？你知道多少" class="headerlink" title="25.对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？你知道多少?"></a>25.对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？你知道多少?</h2><ol><li><p>FIN_WAIT_2：</p><ul><li><p>半关闭状态。</p></li><li><p>发送断开请求一方还有接收数据能力，但已经没有发送数据能力。</p></li></ul></li><li><p>CLOSE_WAIT状态：</p><ul><li><p>被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。</p></li><li><p>被动关闭连接一方如果还有剩余数据要发送就会进入CLOSE_WAIT状态。</p></li></ul></li><li><p>TIME_WAIT状态：</p><ul><li>又叫2MSL等待状态。</li><li>如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。</li><li>在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。</li></ul></li></ol><h2 id="26-为什么挥手需要四次"><a href="#26-为什么挥手需要四次" class="headerlink" title="26.为什么挥手需要四次"></a>26.为什么挥手需要四次</h2><p>TCP连接的关闭需要四次挥手的原因是为了确保双方都能够确认连接的关闭，并且在关闭之前完成所有的数据传输。这个过程涉及到双向数据传输的结束和连接状态的维护，需要一定的步骤来完成。</p><h2 id="27-2MSL等待状态"><a href="#27-2MSL等待状态" class="headerlink" title="27.2MSL等待状态"></a>27.2MSL等待状态</h2><blockquote><p>MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。</p></blockquote><p>2MSL（Two Maximum Segment Lifetime）是TCP连接的最长生存时间，通常用来确定连接处于TIME_WAIT状态的持续时间。</p><p>在TCP连接的关闭过程中，当发送方发送了最后一个ACK报文段后，连接会进入<code>TIME_WAIT</code>状态，等待<code>2MSL</code>时间。这个等待时间的目的是<strong>确保在网络中的所有数据报文段都已经被丢弃，以防止这些报文段在网络中仍然存在，并可能被之后建立的连接误认为是当前连接的报文段，导致数据传输错误</strong>。</p><p>2MSL的时间是两个报文段的最长生存时间（Maximum Segment Lifetime）的两倍。在一般情况下，<strong>MSL是一个IP数据报文段在网络中可以存活的最长时间，它通常被设置为路由器或其他网络设备的缓存时间</strong>。因此，2MSL就是为了确保在TIME_WAIT状态期间，网络中的所有数据报文段都被丢弃，而不会误认为是当前连接的数据。</p><p>在TIME_WAIT状态期间，连接的相关资源（如端口号等）仍然被保留，以防止之后建立的连接使用相同的资源造成冲突。在2MSL等待时间结束后，连接的资源会被释放，连接完全关闭。</p><h2 id="28-为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？"><a href="#28-为什么TIME-WAIT状态需要经过2MSL才能返回到CLOSE状态？" class="headerlink" title="28.为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？"></a>28.为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？</h2><p>理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><h2 id="29-TCP粘包问题是什么？你会如何去解决它？"><a href="#29-TCP粘包问题是什么？你会如何去解决它？" class="headerlink" title="29.TCP粘包问题是什么？你会如何去解决它？"></a>29.TCP粘包问题是什么？你会如何去解决它？</h2><p>TCP粘包问题是指在TCP通信过程中，发送方连续发送的数据包在接收方处被合并成一个或多个大的数据包，导致接收方无法正确解析和处理。这种情况可能会发生在<code>数据包到达接收方时的缓冲区合并过程中</code>，造成数据粘在一起而无法分割开。</p><p>TCP粘包问题可能由于多种因素引起，包括<code>网络传输过程中的延迟</code>、<code>缓冲区大小设置不合理</code>、<code>发送方数据包大小不一致</code>等。</p><p>解决TCP粘包问题的方法主要包括以下几种：</p><ul><li><p>消息边界标记：在数据包中添加特定的边界标记或者长度字段，用于标识消息的开始和结束。接收方根据这些标记来正确分割接收到的数据，以确保每个消息被正确处理。</p></li><li><p>固定长度消息：发送方将每个消息固定长度进行发送，接收方按照固定的长度来接收和处理消息，无需额外的边界标记。</p></li><li><p>消息头中包含消息长度：在消息头中包含消息的长度信息，接收方先读取消息长度，然后按照消息长度读取数据，确保每个消息都被正确处理。</p></li><li><p>使用应用层协议：使用更高层次的应用层协议，如HTTP、WebSocket等，这些协议通常有自己的消息分割规则，可以帮助解决粘包问题。</p></li><li><p>缓冲区调优：调整接收方的缓冲区大小，使其能够容纳更大的数据量，减少发生粘包的可能性。</p></li><li><p>时间间隔控制：发送方发送数据时，可以通过控制发送数据的时间间隔，或者发送数据的速率来减少粘包发生的频率。</p></li></ul><h2 id="30-HTTPS采用的加密方式有哪些？是对称还是非对称？"><a href="#30-HTTPS采用的加密方式有哪些？是对称还是非对称？" class="headerlink" title="30.HTTPS采用的加密方式有哪些？是对称还是非对称？"></a>30.HTTPS采用的加密方式有哪些？是对称还是非对称？</h2><p>HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。</p><h2 id="31-网络层常见协议？可以说一下吗？"><a href="#31-网络层常见协议？可以说一下吗？" class="headerlink" title="31.网络层常见协议？可以说一下吗？"></a>31.网络层常见协议？可以说一下吗？</h2><table><thead><tr><th>协议</th><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>IP</td><td>网际协议</td><td>IP协议不但定义了数据传输时的基本单元和格式，还定义了数据报的递交方法和路由选择</td></tr><tr><td>ICMP</td><td>Internet控制报文协议</td><td>ICMP就是一个“错误侦测与回报机制”，其目的就是让我们能够检测网路的连线状况﹐也能确保连线的准确性，是ping和traceroute的工作协议</td></tr><tr><td>RIP</td><td>路由信息协议</td><td>使用“跳数”(即metric)来衡量到达目标地址的路由距离</td></tr><tr><td>IGMP</td><td>Internet组管理协议</td><td>用于实现组播、广播等通信</td></tr></tbody></table><h2 id="32-TCP四大拥塞控制算法总结"><a href="#32-TCP四大拥塞控制算法总结" class="headerlink" title="32.TCP四大拥塞控制算法总结"></a>32.TCP四大拥塞控制算法总结</h2><p><img src="/2023/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png"><br>TCP拥塞控制算法是用于在网络拥塞情况下调整TCP连接的发送速率，以避免网络拥塞并提高网络性能的一组算法。四大拥塞控制算法包括：<code>慢启动</code>、<code>拥塞避免</code>、<code>快重传</code>、<code>快恢复</code>。下面是对这四个算法的简要总结：</p><ol><li><p>慢启动（Slow Start）：</p><ul><li>慢启动算法用于在连接启动时快速增加发送速率，以尽快填满网络的可用带宽。</li><li>当连接开始时，发送方将初始拥塞窗口设置为一个较小的值（通常是1个或者几个报文段大小），然后在每次收到对应的ACK确认时，将拥塞窗口大小翻倍。</li><li>慢启动算法的目标是快速探测到可用的带宽，并尽快将发送速率提高到一个合适的水平。</li></ul></li><li><p>拥塞避免（Congestion Avoidance）：</p><ul><li>拥塞避免算法用于在慢启动阶段结束后，以一种较为谨慎的方式继续增加发送速率，以避免引起网络拥塞。</li><li>在拥塞避免阶段，发送方将拥塞窗口以线性增长的方式增加，而不是指数增长。</li><li>拥塞避免算法的目标是逐渐增加发送速率，同时观察网络的拥塞情况并避免触发网络拥塞。</li></ul></li><li><p>快重传（Fast Retransmit）：</p><ul><li>快重传算法用于快速检测和恢复丢失的数据报文段，以避免等待超时重传带来的长延迟。</li><li>当发送方收到连续的<code>三个相同的ACK确认</code>时，说明前面的一个报文段丢失了，发送方会立即重传该丢失的报文段，而不必等待超时定时器触发。</li></ul></li><li><p>快恢复（Fast Recovery）：</p><ul><li>快恢复算法用于在发生快重传后，有效地降低拥塞窗口，以减少丢失报文段引起的网络拥塞。</li><li>当发送方收到三个重复的ACK确认时，不仅触发快重传，还会将<code>拥塞窗口减半</code>，并且进入快恢复状态。</li><li>在快恢复状态中，发送方将拥塞窗口设置为拥塞避免阈值的一半，并开始以拥塞避免算法的方式增加拥塞窗口。</li></ul></li></ol><h2 id="33-为何快速重传是选择3次ACK？"><a href="#33-为何快速重传是选择3次ACK？" class="headerlink" title="33.为何快速重传是选择3次ACK？"></a>33.为何快速重传是选择3次ACK？</h2><p>主要的考虑还是要区分包的丢失是由于链路故障还是乱序等其他因素引发。</p><p>两次duplicated ACK时很可能是乱序造成的！三次duplicated ACK时很可能是丢包造成的！四次duplicated ACK更更更可能是丢包造成的，但是这样的响应策略太慢。丢包肯定会造成三次duplicated ACK!综上是选择收到三个重复确认时窗口减半效果最好，这是实践经验。</p><h2 id="34-TCP-协议如何保证可靠传输？"><a href="#34-TCP-协议如何保证可靠传输？" class="headerlink" title="34.TCP 协议如何保证可靠传输？"></a>34.TCP 协议如何保证可靠传输？</h2><p>TCP（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层协议。TCP保证可靠传输的主要机制包括：</p><ol><li><p>确认和重传机制：</p><p> TCP使用确认和重传机制来确保数据的可靠传输。接收方收到数据后会向发送方发送确认消息（ACK），表示已成功接收数据。如果发送方在一定时间内未收到确认消息，会认为数据丢失，并触发数据的重传机制，重新发送丢失的数据。</p></li><li><p>序号和确认号：</p><p> TCP使用序号（Sequence Number）和确认号（Acknowledgment Number）来标识数据包的顺序和确认情况。发送方将每个数据包标记上唯一的序号，接收方在收到数据包后会将确认号设置为下一个期望接收的序号。通过序号和确认号的配对，TCP可以实现对数据传输的准确追踪和控制。</p></li><li><p>滑动窗口：</p><p> TCP使用滑动窗口协议来实现流量控制和可靠传输。发送方和接收方维护一个窗口大小，用来控制发送数据的速率和接收数据的能力。通过滑动窗口机制，TCP可以动态调整数据传输的速率，确保发送的数据不会超过接收方的处理能力。</p></li><li><p>连接管理：</p><p> TCP通过建立连接、数据传输和断开连接的完整过程来管理通信连接。在建立连接时，双方交换一系列控制信息（SYN、SYN-ACK、ACK），以确保双方能够正常通信。在数据传输过程中，TCP会维护连接状态和序列号等信息，以保证数据的可靠传输。在断开连接时，TCP会进行适当的释放和清理工作，以确保连接的安全关闭。</p></li><li><p>超时和重传策略：</p><p> TCP使用超时和重传策略来处理丢失的数据包。如果发送方在一定时间内未收到确认消息，则认为数据丢失，并触发数据的重传机制。TCP会根据网络条件和重传次数动态调整超时时间，以提高数据传输的效率和可靠性。</p></li></ol><h2 id="35-TCP和UDP的区别"><a href="#35-TCP和UDP的区别" class="headerlink" title="35.TCP和UDP的区别"></a>35.TCP和UDP的区别</h2><ol><li><p>TCP<strong>面向连接</strong>（如打电话要先拨号建立连接）;UDP是<strong>无连接</strong>的，即发送数据之前不需要建立连接</p></li><li><p>TCP提供<strong>可靠</strong>的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即<strong>不保证可靠交付</strong></p></li><li><p>TCP<strong>面向字节流</strong>，实际上是TCP把数据看成一连串无结构的字节流;UDP是<strong>面向报文</strong>的</p></li><li><p>UDP没有<strong>拥塞控制</strong>，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</p></li><li><p>每一条TCP连接只能是<strong>点到点</strong>的;UDP支持<strong>一对一，一对多，多对一和多对多</strong>的交互通信</p></li><li><p>TCP首部开销20字节;UDP的首部开销小，只有8个字节</p></li><li><p>TCP的逻辑通信信道是<strong>全双工</strong>的可靠信道，UDP则是不可靠信道</p></li><li><p>UDP是面向报文的，发送方的UDP对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层，论应用层交给UDP多长的报文，它统统发送，一次发送一个。而对接收方，接到后直接去除首部，交给上面的应用层就完成任务了。因此，它需要应用层控制报文的大小</p></li><li><p>TCP是面向字节流的，它把上面应用层交下来的数据看成无结构的字节流会发送，可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着TCP会根据当前网络的拥塞状态来确定每个报文段的大小。</p></li></ol><h2 id="36-封包和拆包你听说过吗？它是基于TCP还是UDP的？"><a href="#36-封包和拆包你听说过吗？它是基于TCP还是UDP的？" class="headerlink" title="36.封包和拆包你听说过吗？它是基于TCP还是UDP的？"></a>36.封包和拆包你听说过吗？它是基于TCP还是UDP的？</h2><p>封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p><ul><li><p>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</p></li><li><p>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。</p></li></ul><h2 id="37-协议相关"><a href="#37-协议相关" class="headerlink" title="37.协议相关"></a>37.协议相关</h2><ul><li>TCP对应的应用层协议：<ul><li>HTTP</li><li>FTP</li><li>Telnet</li></ul></li><li>UDP对应的应用层协议：<ul><li>DNS</li><li>DHCP</li></ul></li><li>数据链路层常见协议:<ul><li>ARP</li><li>RARP</li><li>PPP</li></ul></li><li>Ping命令基于什么协议？原理是什么？<ul><li>ping是基于网络层的ICMP协议实现的。</li><li>通过向对方发送一个ICMP回送请求报文，如果对方主机可达的话会收到该报文，并响应一个ICMP回送回答报文。</li></ul></li></ul><h2 id="38-TCP-利用滑动窗口实现流量控制的机制？"><a href="#38-TCP-利用滑动窗口实现流量控制的机制？" class="headerlink" title="38.TCP 利用滑动窗口实现流量控制的机制？"></a>38.TCP 利用滑动窗口实现流量控制的机制？</h2><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。TCP 利用滑动窗口实现流量控制。</p><p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据。</p><p>例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p><h2 id="39-可以解释一下RTO，RTT和超时重传分别是什么吗？"><a href="#39-可以解释一下RTO，RTT和超时重传分别是什么吗？" class="headerlink" title="39.可以解释一下RTO，RTT和超时重传分别是什么吗？"></a>39.可以解释一下RTO，RTT和超时重传分别是什么吗？</h2><p>当使用 TCP 进行通信时，RTO（Retransmission Timeout）、RTT（Round-Trip Time）和超时重传是三个与 TCP 连接可靠性和性能密切相关的概念。</p><ol><li><p>RTO（Retransmission Timeout）：</p><ul><li>RTO 是指重新传输超时时间，即 TCP 在发送数据后等待接收确认的时间长度。当发送方发送数据后，会启动一个定时器，等待接收方发送确认消息。如果在 RTO 时间内未收到确认消息，则认为数据丢失，触发数据的重传机制。RTO 的设定是 TCP 的一个重要参数，影响着数据传输的可靠性和性能。</li></ul></li><li><p>RTT（Round-Trip Time）：</p><ul><li>RTT 是指往返时间，即从发送数据到接收到确认消息所经历的时间。RTT 反映了数据在网络中传输的延迟情况，包括数据在网络中的传播延迟、处理延迟和队列延迟等。RTT 的计算通常通过记录发送数据的时间戳和接收确认消息的时间戳来实现，可以用于调整 RTO 时间以适应网络条件的变化。</li></ul></li><li><p>超时重传：</p><ul><li>超时重传是指当发送方在 RTO 时间内未收到确认消息时，触发的数据重传机制。发送方会重新发送未确认的数据，以确保数据能够被正确接收。超时重传是 TCP 实现可靠数据传输的关键机制之一，通过对丢失数据的及时重传，可以保证数据传输的可靠性。</li></ul></li></ol><p>综上所述，RTO 是 TCP 设定的重新传输超时时间，用于判断数据是否丢失；RTT 是数据往返时间，用于评估网络延迟情况；超时重传是 TCP 在 RTO 时间内未收到确认消息时触发的数据重传机制，用于确保数据传输的可靠性。这些概念在 TCP 连接的性能优化和故障排查中起着重要作用。</p><h2 id="40-CSRF攻击"><a href="#40-CSRF攻击" class="headerlink" title="40.CSRF攻击"></a>40.CSRF攻击</h2><p>CSRF（Cross-Site Request Forgery）跨站请求伪造是一种网络安全攻击，利用用户已经认证过的会话来执行未经授权的操作。攻击者通过诱使用户在受信任的网站上执行恶意操作，利用用户当前的身份认证信息向目标网站发送请求，从而实现攻击目标。CSRF 攻击通常利用用户浏览器的身份验证信息来执行恶意操作，而无需直接获取用户的用户名和密码。</p><p>CSRF 攻击的原理如下：</p><ol><li><p>攻击者诱使受害者登录到目标网站，并获取了用户的身份验证凭据（如会话 Cookie）。</p></li><li><p>攻击者构造恶意网站或者恶意邮件，在页面中插入恶意的请求代码，例如隐藏的表单、图片、iframe 等。</p></li><li><p>受害者访问了攻击者构造的恶意页面，浏览器会自动发送已经认证过的请求给目标网站，执行攻击者预设的恶意操作。</p></li><li><p>目标网站无法区分这个请求是由受害者自己发起的还是攻击者伪造的，因此会执行这个请求，从而使攻击者达到其目的。</p></li></ol><p>防范 CSRF 攻击的常用方法包括：</p><ol><li><p>CSRF Token：在用户请求中添加随机生成的 CSRF Token，服务器端验证请求中的 Token 是否合法。</p></li><li><p>SameSite Cookie 属性：设置 Cookie 的 SameSite 属性为Strict或Lax，限制跨站请求。当设置为 Strict 时，浏览器完全禁止第三方 Cookie；设置为 Lax 时，只允许在顶级导航中发送 Cookie。</p></li><li><p>Referer 检查：服务器端校验请求的 Referer 头部，确保请求来源是合法的网站。</p></li><li><p>双重确认：对于敏感操作，要求用户进行二次确认，如输入密码或者进行其他身份验证。</p></li><li><p>添加验证码：对于一些敏感操作，要求用户输入验证码，以确保请求是由用户本人发起的。</p></li></ol><h2 id="41-如何防范文件上传漏洞"><a href="#41-如何防范文件上传漏洞" class="headerlink" title="41.如何防范文件上传漏洞"></a>41.如何防范文件上传漏洞</h2><p>文件上传的目录设置为不可执行。</p><ol><li><p>判断文件类型。在判断文件类型的时候，可以结合使用MIME Type，后缀检查等方式。因为对于上传文件，不能简单地通过后缀名称来判断文件的类型，因为攻击者可以将可执行文件的后缀名称改为图片或其他后缀类型，诱导用户执行。</p></li><li><p>对上传的文件类型进行白名单校验，只允许上传可靠类型。</p></li><li><p>上传的文件需要进行重新命名，使攻击者无法猜想上传文件的访问路径，将极大地增加攻击成本，同时向shell.php.rar.ara这种文件，因为重命名而无法成功实施攻击。</p></li><li><p>限制上传文件的大小。</p></li><li><p>单独设置文件服务器的域名。</p></li></ol><h2 id="42-如何区分流量控制和拥塞控制？"><a href="#42-如何区分流量控制和拥塞控制？" class="headerlink" title="42.如何区分流量控制和拥塞控制？"></a>42.如何区分流量控制和拥塞控制？</h2><ul><li><p>流量控制属于通信双方协商；拥塞控制涉及通信链路全局。</p></li><li><p>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</p></li><li><p>实际最终发送窗口 &#x3D; min{流控发送窗口，拥塞窗口}。</p></li></ul><h2 id="43-常见的HTTP状态码有哪些？"><a href="#43-常见的HTTP状态码有哪些？" class="headerlink" title="43.常见的HTTP状态码有哪些？"></a>43.常见的HTTP状态码有哪些？</h2><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>1XX</td><td>Informational（信息性状态码）</td><td>接收的请求正在处理</td></tr><tr><td>2XX</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>Redirection（重定向状态码）</td><td>需要进行附加操作以完成请求</td></tr><tr><td>4XX</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出</td></tr></tbody></table><ul><li><p>1xx 信息  </p><ul><li>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul></li><li><p>2xx 成功  </p><ul><li>200 OK</li><li>204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li><li>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li></ul></li><li><p>3xx 重定向</p><ul><li>301 Moved Permanently ：永久性重定向</li><li>302 Found ：临时性重定向</li><li>303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li><li>304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li><li>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li></ul></li><li><p>4xx 客户端错误</p><ul><li>400 Bad Request ：请求报文中存在语法错误。</li><li>401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li>403 Forbidden ：请求被拒绝。</li><li>404 Not Found</li></ul></li><li><p>5xx 服务器错误</p><ul><li>500 Internal Server Error ：服务器正在执行请求时发生错误。</li><li>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul></li></ul><h2 id="44-服务器出现大量close-wait的连接的原因是什么？有什么解决方法？"><a href="#44-服务器出现大量close-wait的连接的原因是什么？有什么解决方法？" class="headerlink" title="44.服务器出现大量close_wait的连接的原因是什么？有什么解决方法？"></a>44.服务器出现大量close_wait的连接的原因是什么？有什么解决方法？</h2><ul><li><p>close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：</p><ul><li>服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li><li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收</li></ul></li><li><p>处理方法：</p><ul><li>停止应用程序</li><li>修改程序里的bug</li></ul></li></ul><h2 id="45-一台机器能够使用的端口号上限是多少，是否可以修改？如果想要用的端口超过这个限制怎么办？"><a href="#45-一台机器能够使用的端口号上限是多少，是否可以修改？如果想要用的端口超过这个限制怎么办？" class="headerlink" title="45.一台机器能够使用的端口号上限是多少，是否可以修改？如果想要用的端口超过这个限制怎么办？"></a>45.一台机器能够使用的端口号上限是多少，是否可以修改？如果想要用的端口超过这个限制怎么办？</h2><ul><li><p>65536.因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16&#x3D;65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。</p></li><li><p>而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 常识类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2023/02/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/02/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-进程、线程和协程的区别和联系"><a href="#1-进程、线程和协程的区别和联系" class="headerlink" title="1.进程、线程和协程的区别和联系"></a>1.进程、线程和协程的区别和联系</h2><table><thead><tr><th></th><th>进程</th><th>线程</th><th>协程</th></tr></thead><tbody><tr><td>定义</td><td>资源分配和拥有的基本单位</td><td>程序执行的基本单位</td><td>用户态的轻量级线程，线程内部调度的基本单位</td></tr><tr><td>切换情况</td><td>进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td><td>保存和设置程序计数器、少量寄存器和栈的内容</td><td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td></tr><tr><td>切换者</td><td>操作系统</td><td>操作系统</td><td>用户</td></tr><tr><td>切换过程</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态-&gt;内核态-&gt;用户态</td><td>用户态(没有陷入内核)</td></tr><tr><td>调用栈</td><td>内核栈</td><td>内核栈</td><td>用户栈</td></tr><tr><td>拥有资源</td><td>CPU资源、内存资源、文件资源和句柄等</td><td>程序计数器、寄存器、栈和状态字</td><td>拥有自己的寄存器上下文和栈</td></tr><tr><td>并发性</td><td>不同进程之间切换实现并发，各自占有CPU实现并行</td><td>一个进程内部的多个线程并发执行</td><td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td></tr><tr><td>系统开销</td><td>切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td><td>切换时只需保存和设置少量寄存器内容，因此开销很小</td><td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td></tr><tr><td>通信方面</td><td>进程间通信需要借助操作系统</td><td>线程间可以直接读写进程数据段(如全局变量)来进行通信</td><td>共享内存、消息队列</td></tr></tbody></table><h2 id="2-外中断和异常有什么区别？"><a href="#2-外中断和异常有什么区别？" class="headerlink" title="2.外中断和异常有什么区别？"></a>2.外中断和异常有什么区别？</h2><p>外中断（Interrupt）和异常（Exception）是计算机体系结构中两种不同的概念，它们有以下区别：</p><ol><li>来源：<br>外中断是由外部设备（如键盘、鼠标、定时器等）触发的中断，通常用于与计算机外部设备进行通信和交互。<br>异常是由于程序执行过程中出现了某种错误或不正常情况而触发的事件，例如除零、访问非法内存、非法指令等。</li><li>触发时机：<br>外中断是在 CPU 执行指令的过程中由外部设备发出的中断请求，可以在任何时候发生，甚至在指令执行的中间。<br>异常是在指令执行过程中出现了错误或不正常情况时发生的，通常是由当前指令执行的结果导致的。</li><li>处理方式：<br>外中断通常由操作系统的中断处理程序进行处理，它会保存当前进程的状态，切换到相应的中断处理程序，并在处理完成后返回到原进程继续执行。<br>异常通常由异常处理机制（如操作系统或硬件）进行处理，它会根据异常类型执行相应的处理逻辑，可能包括异常处理程序的调用、异常信息的记录等。</li><li>举例：<br>外中断的例子包括定时器中断、IO 设备中断等。<br>异常的例子包括除零异常、内存访问异常、非法指令异常等。</li></ol><p>总的来说，外中断和异常都是计算机体系结构中的重要概念，它们分别用于处理外部设备的中断请求和程序执行过程中的错误或异常情况，但在触发时机、处理方式等方面有所不同。</p><h2 id="3-进程调度算法你了解多少？"><a href="#3-进程调度算法你了解多少？" class="headerlink" title="3.进程调度算法你了解多少？"></a>3.进程调度算法你了解多少？</h2><ol><li><p><strong>先来先服务 first-come first-serverd（FCFS）</strong><br> 非抢占式的调度算法，按照请求的顺序进行调度。</p><p> 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p></li><li><p><strong>短作业优先 shortest job first（SJF）</strong><br> 非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p><p> 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p></li><li><p><strong>最短剩余时间优先 shortest remaining time next（SRTN）</strong><br> 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。</p><p> 如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p></li><li><p><strong>时间片轮转</strong><br> 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。</p><p> 当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p><p> 时间片轮转算法的效率和时间片的大小有很大关系：</p><p> 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。</p></li><li><p><strong>优先级调度</strong><br> 为每个进程分配一个优先级，按优先级进行调度。</p><p> 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p></li><li><p><strong>多级反馈队列</strong><br> 一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p><p> 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。</p><p> 这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p><p> 可以将这种调度算法看成是<code>时间片轮转调度算法和优先级调度算法的结合</code>。</p></li></ol><h2 id="4-Linux下进程间通信方式？"><a href="#4-Linux下进程间通信方式？" class="headerlink" title="4.Linux下进程间通信方式？"></a>4.Linux下进程间通信方式？</h2><ul><li><p>管道：</p><ul><li><p>无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。</p></li><li><p>有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</p></li></ul></li><li><p>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。</p></li><li><p>消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li><li><p>套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</p></li><li><p>信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</p></li><li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。</p></li></ul><h2 id="5-如果系统中具有快表后，那么地址的转换过程变成什么样了？"><a href="#5-如果系统中具有快表后，那么地址的转换过程变成什么样了？" class="headerlink" title="5.如果系统中具有快表后，那么地址的转换过程变成什么样了？"></a>5.如果系统中具有快表后，那么地址的转换过程变成什么样了？</h2><ol><li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。  </li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。  </li><li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)</li></ol><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，–般来说快表的命中率可以达到90%以上。</p><ul><li><p>局部性原理:<br>局部性原理是计算机系统设计中的一个重要概念，它指的是在程序执行过程中，访问内存的趋势是倾向于集中在一小部分地址范围内。局部性原理分为两种类型：时间局部性和空间局部性。</p><ul><li>时间局部性（Temporal Locality）：</li></ul></li></ul><p>时间局部性指的是，如果在程序的某个时间点访问了某个存储单元，那么在不久之后的时间内，很可能会再次访问相同的存储单元。这意味着程序倾向于重复使用最近使用过的数据或指令。时间局部性的主要原因是程序中存在循环、子程序调用等结构，导致某些数据被反复使用。</p><pre><code>* 空间局部性（Spatial Locality）：</code></pre><p>空间局部性指的是，如果程序访问了某个存储单元，那么在不久之后的时间内，很可能会访问与该存储单元相邻的存储单元。这意味着程序倾向于顺序地访问相邻的内存位置，例如数组、矩阵等数据结构。空间局部性的主要原因是计算机系统中的缓存机制，通常会将相邻的内存位置加载到缓存中，以提高访问效率。</p><h2 id="6-动态分区分配算法有哪几种？可以分别说说吗？"><a href="#6-动态分区分配算法有哪几种？可以分别说说吗？" class="headerlink" title="6.动态分区分配算法有哪几种？可以分别说说吗？"></a>6.动态分区分配算法有哪几种？可以分别说说吗？</h2><table><thead><tr><th>算法</th><th>算法思想</th><th>分区排列顺序</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>首次适应</td><td>从头到尾找适合的分区</td><td>空闲分区以地址递增次序排列</td><td>综合看性能最好。算法开销小，回收分区后一.般不需要对空闲分区队列重新排序</td><td></td></tr><tr><td>最佳适应</td><td>优先使用更小的分区，以保留更多大分区</td><td>空闲分区以容量递增次序排列</td><td>会有更多的大分区被保留下来，更能满足大进程需求</td><td>会产生很多太小的、难以利用的碎片;算法开销大，回收分区后可能需要对空闲分区队列重新排序</td></tr><tr><td>最坏适应</td><td>优先使用更大的分区，以防止产生太小的不可用的碎片</td><td>空闲分区以容量递减次序排列</td><td>可以减少难以利用的小碎片</td><td>大分区容易被用完，不利于大进程;算法开销大(原因同上)</td></tr><tr><td>邻近适应</td><td>由首次适应演变而来，每次从上次查找结束位置开始查找</td><td>空闲分区以地址递增次序排列(可排列成循环链表)不</td><td>用每次都从低地址的小分区开始检索。算法开销小(原因同首次适应算法)</td><td>会使高地址的大分区也被用完</td></tr></tbody></table><h2 id="7-虚拟技术你了解吗？"><a href="#7-虚拟技术你了解吗？" class="headerlink" title="7.虚拟技术你了解吗？"></a>7.虚拟技术你了解吗？</h2><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p><p>主要有两种虚拟技术：<code>时（时间）分复用技术</code>和<code>空（空间）分复用技术</code>。</p><ul><li><p>多进程与多线程：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p></li><li><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p></li></ul><h2 id="8-虚拟内存的目的是什么？"><a href="#8-虚拟内存的目的是什么？" class="headerlink" title="8.虚拟内存的目的是什么？"></a>8.虚拟内存的目的是什么？</h2><p><strong>空分复用:</strong></p><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。</p><p>这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p><p>例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p><h2 id="9-一个C-C-程序从开始编译到生成可执行文件的完整过程，你能说出来多少？"><a href="#9-一个C-C-程序从开始编译到生成可执行文件的完整过程，你能说出来多少？" class="headerlink" title="9.一个C&#x2F;C++程序从开始编译到生成可执行文件的完整过程，你能说出来多少？"></a>9.一个C&#x2F;C++程序从开始编译到生成可执行文件的完整过程，你能说出来多少？</h2><p>四个过程：</p><p>（1）预编译 主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</p><ol><li><p>删除所有的#define，展开所有的宏定义。</p></li><li><p>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</p></li><li><p>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。</p></li><li><p>删除所有的注释，“&#x2F;&#x2F;”和“&#x2F;**&#x2F;”。</p></li><li><p>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。</p></li><li><p>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。</p></li></ol><p>（2）编译 把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p><ol><li><p>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</p></li><li><p>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</p></li><li><p>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</p></li><li><p>优化：源代码级别的一个优化过程。</p></li><li><p>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</p></li><li><p>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p></li></ol><p>（3）汇编</p><p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。</p><p>经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux下)、xxx.obj(Windows下)。</p><p>（4）链接</p><p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p><ol><li><p>静态链接： 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p><ul><li>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</li></ul></li><li><p>动态链接： 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p><ul><li><p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</p></li><li><p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p></li><li><p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p></li></ul></li></ol><h2 id="10-讲解逻辑地址转换为物理地址的基本过程"><a href="#10-讲解逻辑地址转换为物理地址的基本过程" class="headerlink" title="10.讲解逻辑地址转换为物理地址的基本过程"></a>10.讲解逻辑地址转换为物理地址的基本过程</h2><p><img src="/2023/02/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/addressing.png"></p><h2 id="11-进程同步的四种方法"><a href="#11-进程同步的四种方法" class="headerlink" title="11.进程同步的四种方法"></a>11.进程同步的四种方法</h2><ol><li><p>临界区  </p><p> 对临界资源进行访问的那段代码称为临界区。</p><p> 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p></li><li><p>同步与互斥  </p><p> 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。  </p><p> 互斥：多个进程在同一时刻只有一个进程能进入临界区。</p></li><li><p>信号量  </p><p> 信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p></li><li><p>管程  </p><p> 管程是一种高级的同步机制，它将数据结构和操作封装在一起，提供了对共享资源的访问和控制。只有通过管程提供的操作才能访问共享资源，从而确保了对共享资源的互斥访问。</p><p> 管程（Monitor）实质上可以看作是一个类或者一个抽象数据类型（ADT）。它封装了共享资源以及对该资源的访问和控制方法，提供了一种高级的同步机制。</p></li></ol><h2 id="12-进程通信方式"><a href="#12-进程通信方式" class="headerlink" title="12.进程通信方式"></a>12.进程通信方式</h2><ul><li><p>管道(pipe)：允许一个进程和另一个与它有共同祖先的进程之间进行通信</p></li><li><p>命名管道(FIFO)：类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建</p></li><li><p>消息队列(MQ)：消息队列是消息的连接表，包括POSIX消息对和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点；</p></li><li><p>信号量(semaphore)：信号量主要作为进程间以及同进程不同线程之间的同步手段；</p></li><li><p>共享内存(shared memory)：它使得多个进程可以访问同一块内存空间，<strong>是最快的可用IPC形式。</strong>这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥</p></li><li><p>信号(signal)：信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身<br>内存映射(mapped memory)：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它</p></li><li><p>Socket：它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信</p></li></ul><h2 id="13-介绍一下几种典型的锁？"><a href="#13-介绍一下几种典型的锁？" class="headerlink" title="13.介绍一下几种典型的锁？"></a>13.介绍一下几种典型的锁？</h2><ul><li><p>读写锁  </p><ul><li>多个读者可以同时进行读</li><li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li><li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li></ul></li><li><p>互斥锁</p><ul><li><p>一次只能一个线程拥有互斥锁，其他线程只有等待</p></li><li><p>互斥锁是在抢锁失败的情况下<strong>主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度</strong>，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p></li></ul></li><li><p>条件变量</p><ul><li>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。</li></ul></li><li><p>自旋锁</p><ul><li>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</li></ul></li></ul><h2 id="14-逻辑地址VS物理地址"><a href="#14-逻辑地址VS物理地址" class="headerlink" title="14.逻辑地址VS物理地址"></a>14.逻辑地址VS物理地址</h2><blockquote><p>注意：物理地址指的是程序在内存中的地址，而不是程序在硬盘中的地址。</p></blockquote><p>逻辑地址（Logical Address）和物理地址（Physical Address）是在计算机系统中用于访问内存的两种不同的地址类型，它们之间存在着映射关系。下面是它们的区别：</p><ol><li><p>逻辑地址：</p><ul><li>逻辑地址是由CPU产生的地址，用于访问内存中的数据和指令。它是一个虚拟地址，与实际的硬件内存地址无关。</li><li>在多道程序设计环境下，每个进程都有自己的逻辑地址空间。逻辑地址是相对于进程而言的，它从0开始，通常是一个连续的地址空间。</li><li>逻辑地址的映射是由操作系统的内存管理单元来完成的，包括地址翻译、分页机制、分段机制等。</li></ul></li><li><p>物理地址：</p><ul><li>物理地址是实际存储在计算机硬件中的地址，用于在内存中定位数据和指令的位置。它是相对于物理内存模块而言的，是真实存在的硬件地址。</li><li>物理地址是由内存管理单元（Memory Management Unit，MMU）根据逻辑地址的映射关系转换得到的。MMU负责将逻辑地址映射到相应的物理地址上，以便CPU可以正确地访问内存中的数据。</li></ul></li><li><p>映射关系：</p><ul><li>逻辑地址和物理地址之间存在着映射关系，这个映射关系由操作系统的内存管理单元来管理和维护。</li><li>当CPU发出一个逻辑地址时，MMU会根据逻辑地址的映射关系将其转换为相应的物理地址，然后用于实际的内存访问。</li></ul></li></ol><p>总的来说，逻辑地址是虚拟的地址空间，是由CPU产生的相对地址；而物理地址是真实的硬件地址，是内存中实际存储数据和指令的位置。通过逻辑地址和物理地址之间的映射关系，CPU可以正确地访问内存中的数据和指令。</p><h2 id="15-内存交换"><a href="#15-内存交换" class="headerlink" title="15.内存交换"></a>15.内存交换</h2><ol><li><p>内存覆盖（Memory Overlay）：</p><ul><li>内存覆盖是一种技术，用于在内存有限的情况下运行较大的程序。当程序的内存需求超过了系统的物理内存时，操作系统会将程序的一部分加载到内存中运行，然后根据需要逐步覆盖、替换加载的程序段。</li><li>内存覆盖通常用于早期的计算机系统，特别是在内存容量受限的环境下。它可以让大型程序在较小的内存空间中运行，但需要手动管理内存的分段和覆盖过程。</li></ul></li><li><p>内存交换（Memory Swapping）：</p><ul><li>内存交换是一种技术，用于在系统的物理内存不足时将部分内存中的数据和程序暂时移到辅助存储设备（如硬盘）中。这样可以腾出内存空间供其他程序使用。</li><li>当操作系统检测到物理内存不足时，它会将部分不活动的进程或者数据交换到硬盘上，以释放内存空间。当需要访问这些被交换出去的数据时，操作系统会将其再次交换回内存中，以满足程序的需求。</li><li>内存交换是一种动态的内存管理技术，操作系统可以根据系统的内存需求自动进行内存交换，无需用户干预。</li></ul></li></ol><p>总的来说，内存覆盖和内存交换都是用于解决内存有限的情况下运行大型程序的技术，但它们的实现方式和应用场景略有不同。<strong>内存覆盖主要用于早期计算机系统中，而内存交换则是现代操作系统中常用的内存管理技术之一</strong>。</p><h2 id="16-如何让进程后台运行"><a href="#16-如何让进程后台运行" class="headerlink" title="16.如何让进程后台运行"></a>16.如何让进程后台运行</h2><ol><li><p>使用后台运行命令：</p><ul><li>在 Unix&#x2F;Linux 系统中，可以使用 &amp; 符号将命令放置在后台运行。例如：.&#x2F;my_program &amp;。</li><li>实际上，这样是将命令放入到一个作业队列中了。这样可以使得该进程在后台运行，不会阻塞当前终端的使用。</li></ul></li><li><p>使用 nohup 命令：</p><ul><li>nohup 命令可以让进程在后台运行，并且不受终端关闭的影响。例如：nohup .&#x2F;my_program &amp;。</li><li>使用 nohup 后，即使关闭终端或者注销用户，进程仍然会继续在后台运行。</li></ul></li><li><p>使用 screen 或者 tmux：</p><ul><li>screen 或者 tmux 是终端复用工具，可以创建一个或多个终端窗口，并在其中运行进程。即使关闭了当前终端窗口，进程仍然会继续在后台运行。</li><li>具体使用方法请参考 screen 或者 tmux 的文档。</li></ul></li><li><p>使用后台运行守护进程：</p><ul><li>将需要后台运行的程序设计为守护进程，并使用系统服务管理工具（如 systemd、init.d 等）启动该守护进程。</li><li>守护进程是一种在后台运行的长期运行的进程，通常用于执行系统任务或服务。</li></ul></li></ol><h2 id="17-快表在什么位置"><a href="#17-快表在什么位置" class="headerlink" title="17.快表在什么位置"></a>17.快表在什么位置</h2><p>TLB（Translation Lookaside Buffer，快表）通常位于处理器的内部，是一个高速缓存结构，用于存储最近使用的逻辑地址到物理地址的映射关系。TLB的设计旨在加速逻辑地址到物理地址的转换过程，提高系统的性能和响应速度。</p><h2 id="18-守护进程、僵尸进程和孤儿进程"><a href="#18-守护进程、僵尸进程和孤儿进程" class="headerlink" title="18.守护进程、僵尸进程和孤儿进程"></a>18.守护进程、僵尸进程和孤儿进程</h2><ol><li><p>守护进程（Daemon Process）：</p><ul><li>守护进程是在后台运行的一种特殊进程，通常是由操作系统启动并且在后台运行的进程。它通常不与任何用户交互，而是执行一些系统任务或服务，例如网络服务、日志服务等。</li><li>守护进程通常在系统启动时被初始化，并且一直运行直到系统关闭。它们通常不会终止，除非出现严重的错误或者手动停止。</li></ul></li><li><p>僵尸进程（Zombie Process）：</p><ul><li>僵尸进程是已经完成执行但是其父进程尚未调用 <code>wait()</code> 或 <code>waitpid()</code> 函数来获取其终止状态的进程。在这种情况下，操作系统会将僵尸进程保留在进程表中，直到其父进程获取其终止状态。</li><li>僵尸进程不会占用系统资源，但是如果太多的僵尸进程积累，会导致系统的进程表被占满，从而影响系统的正常运行。</li></ul></li><li><p>孤儿进程（Orphan Process）：</p><ul><li>孤儿进程是指其父进程提前终止或者意外终止，而导致子进程成为没有父进程的进程。在这种情况下，子进程会被 <code>init</code> 进程（进程号为1）接管。</li><li>孤儿进程会继续在系统中运行，直到其自己终止或者被 <code>init</code> 进程接管。这样可以确保孤儿进程不会成为僵尸进程，因为 <code>init</code> 进程会及时调用 <code>wait()</code> 函数获取其终止状态。</li></ul></li></ol><h2 id="19-如何避免僵尸进程？"><a href="#19-如何避免僵尸进程？" class="headerlink" title="19.如何避免僵尸进程？"></a>19.如何避免僵尸进程？</h2><ol><li><p>父进程调用 wait() 或 waitpid() 函数：</p><ul><li>父进程可以通过调用 wait() 或 waitpid() 函数来等待子进程的退出，并获取子进程的终止状态。这样可以及时回收子进程的资源，并避免其成为僵尸进程。</li><li>在父进程中定期调用 wait() 或 waitpid() 函数可以确保及时处理子进程的退出。</li></ul></li><li><p>使用信号处理函数：</p><ul><li>父进程可以注册 <code>SIGCHLD</code> 信号的处理函数，在收到该信号时调用 <code>wait()</code> 或 <code>waitpid()</code> 函数来处理子进程的退出。</li><li>当子进程退出时，操作系统会向父进程发送 SIGCHLD 信号，父进程可以在信号处理函数中获取子进程的终止状态。</li></ul></li><li><p>设置信号处理方式为忽略（SIG_IGN）：</p><ul><li>父进程可以将 <code>SIGCHLD</code> 信号的处理方式设置为忽略，这样子进程退出时可让内核把僵尸子进程转交给init进程去处理，不会产生僵尸进程。</li><li>但是需要注意的是，这种方式下无法获取子进程的终止状态，可能会导致资源泄漏或者无法正确处理异常情况。</li></ul></li></ol><h2 id="20-Linux中异常和中断的区别"><a href="#20-Linux中异常和中断的区别" class="headerlink" title="20.Linux中异常和中断的区别"></a>20.Linux中异常和中断的区别</h2><p>在Linux系统中，异常（Exception）和中断（Interrupt）是两种不同的事件，它们的触发方式、处理方式以及产生的原因有所不同。</p><ol><li><p>异常（Exception）：</p><ul><li>异常是指在程序执行过程中发生的意外事件或错误情况，例如除零错误、内存访问越界等。异常通常是由CPU在执行指令过程中检测到的，它是指令执行的结果与预期不符导致的。</li><li>在Linux系统中，异常由CPU直接检测并触发，然后将控制权转移给操作系统内核。操作系统内核会根据异常的类型和原因采取相应的处理措施，例如向用户进程发送信号、终止异常进程等。</li></ul></li><li><p>中断（Interrupt）：</p><ul><li>中断是指外部设备或者硬件组件发送的信号，用于通知CPU需要处理某个事件或者执行某个操作。中断可以是来自硬件设备的信号（硬件中断），也可以是来自软件的信号（软件中断）。</li><li>在Linux系统中，中断通常由硬件设备发送给CPU，例如定时器中断、键盘输入中断等。当CPU接收到中断信号时，会暂停当前的执行流程，并转移到中断处理程序（中断服务程序）中执行。中断处理程序负责处理中断事件，并进行相应的处理，例如读取设备数据、响应用户输入等。</li></ul></li></ol><p>总的来说，异常是程序执行过程中的错误情况，由CPU直接检测并触发；而中断是外部设备发送的信号，用于通知CPU需要处理某个事件或者执行某个操作。异常和中断在触发方式、处理方式以及产生原因上有着明显的区别。</p><h2 id="21-一般情况下在Linux-windows平台下栈空间的大小"><a href="#21-一般情况下在Linux-windows平台下栈空间的大小" class="headerlink" title="21.一般情况下在Linux&#x2F;windows平台下栈空间的大小"></a>21.一般情况下在Linux&#x2F;windows平台下栈空间的大小</h2><ul><li><p>Linux环境下有操作系统决定，一般是8MB，8192KB，通过<code>ulimit</code>命令查看以及修改</p></li><li><p>Windows环境下由编译器决定，VC++6.0一般是1M</p></li></ul><h2 id="22-交换空间是什么"><a href="#22-交换空间是什么" class="headerlink" title="22.交换空间是什么"></a>22.交换空间是什么</h2><p>交换空间（Swap Space）是指操作系统用于扩展虚拟内存的一种技术，它将部分内存数据临时存储到磁盘上以释放物理内存空间。交换空间通常用于以下几种情况：</p><ol><li><p>内存不足：当系统的物理内存不足以容纳所有的进程和数据时，操作系统会将部分不经常使用的数据存储到交换空间中，以释放物理内存空间给更重要的进程使用。</p></li><li><p>内存回收：操作系统可以使用交换空间来回收不活动的内存页面，以便将其分配给其他进程使用。这有助于优化内存的使用效率和系统的性能。</p></li><li><p>休眠和恢复：在某些情况下，操作系统可以使用交换空间来存储休眠进程的状态，以便在系统重新启动或恢复时能够快速恢复进程的状态。</p></li></ol><p>交换空间通常由操作系统预先分配，并且可以是一个专门的交换分区，也可以是一个交换文件。交换空间的大小可以根据系统的配置和需求进行调整，但是过度使用交换空间可能会影响系统的性能，因为磁盘访问速度远远低于内存访问速度。因此，合理配置交换空间是系统性能优化的重要一环。</p><h2 id="23-常见的几种磁盘调度算法"><a href="#23-常见的几种磁盘调度算法" class="headerlink" title="23.常见的几种磁盘调度算法"></a>23.常见的几种磁盘调度算法</h2><ol><li><p>先来先服务（First-Come, First-Served，FCFS）：</p><ul><li>FCFS 是最简单的磁盘调度算法，按照请求到达的顺序依次处理磁盘访问请求。</li><li>这种算法的优点是公平性，即所有的请求都能够得到处理。但是它可能会导致磁盘头在磁盘上来回移动，造成平均响应时间较长。</li></ul></li><li><p>最短寻道时间优先（Shortest Seek Time First，SSTF）：</p><ul><li>SSTF 算法会优先处理与磁头当前位置最接近的磁盘访问请求。</li><li>这种算法能够减少磁盘头的移动距离，从而缩短平均响应时间。但是它可能会导致部分请求长时间等待，造成请求饥饿现象。</li></ul></li><li><p>电梯算法（Elevator Algorithm）：</p><ul><li>电梯算法模拟了电梯在多层楼间上下运动的过程，磁盘头会沿着一个方向移动，直到该方向上没有未处理的请求，然后改变方向。</li><li>这种算法能够有效地减少磁盘头的移动次数，从而提高磁盘访问的效率。但是它可能会导致一些请求长时间等待，特别是当磁盘请求集中在一个方向时。</li></ul></li><li><p>扫描算法（SCAN）：</p><ul><li>扫描算法（也称为电梯算法的变种）从磁盘上的一个端点开始沿着一个方向移动，处理所有的请求，直到达到另一个端点，然后返回，继续处理另一侧的请求。</li><li>这种算法能够平衡磁盘头的移动，避免了某些请求长时间等待的情况，但是可能会导致磁盘头在两端之间频繁切换，造成磁盘头的忙碌。</li></ul></li></ol><h2 id="24-抖动你知道是什么吗？它也叫颠簸现象"><a href="#24-抖动你知道是什么吗？它也叫颠簸现象" class="headerlink" title="24.抖动你知道是什么吗？它也叫颠簸现象"></a>24.抖动你知道是什么吗？它也叫颠簸现象</h2><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)</p><h2 id="25-内存交换中，被换出的进程保存在哪里？"><a href="#25-内存交换中，被换出的进程保存在哪里？" class="headerlink" title="25.内存交换中，被换出的进程保存在哪里？"></a>25.内存交换中，被换出的进程保存在哪里？</h2><p>保存在磁盘中，也就是外存中。具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I&#x2F;O速度比文件区的更快。</p><h2 id="26-ASCII、Unicode和UTF-8编码的区别？"><a href="#26-ASCII、Unicode和UTF-8编码的区别？" class="headerlink" title="26.ASCII、Unicode和UTF-8编码的区别？"></a>26.ASCII、Unicode和UTF-8编码的区别？</h2><ul><li><p>ASCII<br>  ASCII 只有127个字符，表示英文字母的大小写、数字和一些符号，但由于其他语言用ASCII 编码表示字节不够，例如：常用中文需要两个字节，且不能和ASCII冲突，中国定制了GB2312编码格式，相同的，其他国家的语言也有属于自己的编码格式。</p></li><li><p>Unicode<br>  由于每个国家的语言都有属于自己的编码格式，在多语言编辑文本中会出现乱码，这样Unicode应运而生，Unicode就是将这些语言统一到一套编码格式中，通常两个字节表示一个字符，而ASCII是一个字节表示一个字符，这样如果你编译的文本是全英文的，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p></li><li><p>UTF-8<br>  为了解决上述问题，又出现了把Unicode编码转化为<code>可变长编码</code>UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为1-6个字节，英文字母被编码成一个字节，常用汉字被编码成三个字节，如果你编译的文本是纯英文的，那么用UTF-8就会非常节省空间，并且ASCII码也是UTF-8的一部分。</p></li><li><p>三者之间的联系<br>  搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p><ol><li><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码:</p></li><li><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。如下图<br>  <img src="/2023/02/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/code1.png"></p></li><li><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：<br>  <img src="/2023/02/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/code2.png"></p></li></ol></li></ul><h2 id="27-页面置换算法"><a href="#27-页面置换算法" class="headerlink" title="27.页面置换算法"></a>27.页面置换算法</h2><ol><li><p>最佳置换法(OPT)</p><ul><li>最佳置换算法(OPT，Optimal) :每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</li><li>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的</li></ul></li><li><p>先进先出置换算法(FIFO)</p><ul><li><p>先进先出置换算法(FIFO) :每次选择淘汰的页面是最早进入内存的页面 实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面队列的最大长度取决于系统为进程分配了多少个内存块。</p></li><li><p><strong>Belady异常—当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</strong></p></li><li><p>只有FIFO算法会产生Belady异常，而LRU和OPT算法永远不会出现Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差</p></li><li><p>FIFO的性能较差，因为较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出，并且有Belady现象。所谓Belady现象是指：采用FIFO算法时，如果对—个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。</p></li></ul></li><li><p>最近最久未使用置换算法(LRU)</p><ul><li><p>最近最久未使用置换算法(LRU，least recently used) :每次淘汰的页面是最近最久未使用的页面 实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自.上次被访问以来所经历的时间t(该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大)。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p></li><li><p>LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类算法，理论上可以证明，堆栈类算法不可能出现Belady异常。</p></li></ul></li><li><p>时钟置换算法(CLOCK)</p><ul><li><p>最佳置换算法性OPT能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p></li><li><p>所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体，因为算法要循环扫描缓冲区像时钟一样转动。所以叫clock算法。</p></li><li><p>时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used)</p></li><li><p>简单的CLOCK算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰-一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第- - ~轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择–个淘汰页面最多会经过两轮扫描)</p></li></ul></li><li><p>改进型的时钟置换算法</p><ul><li><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过,就不需要执行I&#x2F;O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p></li><li><p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I&#x2F;O操作。这就是改进型的时钟置换算法的思想。修改位&#x3D;0，表示页面没有被修改过;修改位&#x3D;1，表示页面被修改过。</p></li></ul></li></ol><ul><li>总结</li></ul><table><thead><tr><th></th><th>算法规则</th><th>优缺点</th></tr></thead><tbody><tr><td>OPT</td><td>优先淘汰最长时间内不会被访问的页面</td><td>缺页率最小，性能最好;但无法实现</td></tr><tr><td>FIFO</td><td>优先淘汰最先进入内存的页面</td><td>实现简单;但性能很差，可能出现Belady异常</td></tr><tr><td>LRU</td><td>优先淘汰最近最久没访问的页面</td><td>性能很好;但需要硬件支持，算法开销大</td></tr><tr><td>CLOCK (NRU)</td><td>循环扫描各页面 第一轮淘汰访问位&#x3D;0的，并将扫描过的页面访问位改为1。若第-轮没选中，则进行第二轮扫描。</td><td>实现简单，算法开销小;但未考虑页面是否被修改过。</td></tr><tr><td>改进型CLOCK (改进型NRU)</td><td>若用(访问位，修改位)的形式表述，则 第一轮:淘汰(0,0) 第二轮:淘汰(O,1)，并将扫描过的页面访问位都置为0 第三轮:淘汰(O, 0) 第四轮:淘汰(0, 1)</td><td>算法开销较小，性能也不错</td></tr></tbody></table><h2 id="28-Belady异常"><a href="#28-Belady异常" class="headerlink" title="28.Belady异常"></a>28.Belady异常</h2><ol><li><p>LRU为什么不会发生Belady异常？  </p><ul><li><p>实页数增加 —&gt; 能贮存的页数增加 —&gt; 哪些页？—&gt; 访问频率高的页</p></li><li><p>LRU当中替换的是使用频率最低的页，留下的都是使用频率高的页。当实页数增加，能够留下的高频访问的页也就更多，这直接关系到命中率的增加。</p></li></ul></li><li><p>FIFO为什么会发生Belady异常？</p><ul><li><p>实页数增加 —&gt; 能贮存的页数增加 —&gt; 哪些页？—&gt; 后面来的页</p></li><li><p>先进先出的替换算法，完全不考虑使用频率，即使增加了实页数，多贮存的部分接下来常访问可能性也不一定大（看运气），也就并不一定能增加命中率。</p></li></ul></li></ol><h2 id="29-死锁产生原因"><a href="#29-死锁产生原因" class="headerlink" title="29.死锁产生原因"></a>29.死锁产生原因</h2><p>举个例子：两个线程A和B，两个数据1和2。线程A在执行过程中，首先对资源1加锁，然后再去给资源2加锁，但是由于线程的切换，导致线程A没能给资源2加锁。线程切换到B后，线程B先对资源2加锁，然后再去给资源1加锁，由于资源1已经被线程A加锁，因此线程B无法加锁成功，当线程切换为A时，A也无法成功对资源2加锁，由此就造成了线程AB双方相互对一个已加锁资源的等待，死锁产生。</p><p>理论上认为死锁产生有以下四个必要条件，缺一不可：</p><ul><li><p>互斥条件：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。</p></li><li><p>不剥夺条件：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。</p></li><li><p>请求和保持条件：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。</p></li><li><p>循环等待条件：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</p></li></ul><h2 id="30-银行家算法"><a href="#30-银行家算法" class="headerlink" title="30.银行家算法"></a>30.银行家算法</h2><p>银行家算法是一种用于避免死锁（Deadlock）的资源分配和调度算法，最初由Dijkstra在1965年提出。它通过合理地分配和释放资源，避免了进程之间因争夺资源而导致的死锁问题。银行家算法主要用于操作系统中的进程管理和资源分配。</p><p>银行家算法的基本思想是通过检查分配资源的安全性来决定是否允许进程继续运行。它通过维护一个系统资源分配的最大需求矩阵、可用资源向量和已分配资源矩阵，来判断系统当前是否处于安全状态。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 常识类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++八股文</title>
      <link href="/2023/01/23/C++%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2023/01/23/C++%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="C-八股文"><a href="#C-八股文" class="headerlink" title="C++八股文"></a>C++八股文</h1><h2 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h2><h3 id="1-1-在main执行之前和之后执行的代码可能是什么？"><a href="#1-1-在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="1.1 在main执行之前和之后执行的代码可能是什么？"></a>1.1 在main执行之前和之后执行的代码可能是什么？</h3><p><strong>main函数执行之前，主要就是初始化系统相关资源：</strong></p><ul><li>设置栈指针</li><li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li><li>将未初始化部分的全局变量赋初值：数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，<code>bool</code>为<code>FALSE</code>，<code>指针</code>为<code>NULL</code>等等，即<code>.bss</code>段的内容</li><li>将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li><li>执行<code>__attribute__((constructor))</code>，与golang的init()函数类似</li></ul><p><strong>main函数完成后：</strong></p><ul><li>全局对象的析构函数</li><li>可以用<code>atexit</code>注册一个函数，它会在<code>main</code>之后执行;</li><li><code>__attribute__((destructor))</code></li></ul><h3 id="1-2-结构体内存对齐问题？"><a href="#1-2-结构体内存对齐问题？" class="headerlink" title="1.2 结构体内存对齐问题？"></a>1.2 结构体内存对齐问题？</h3><ul><li>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</li><li>未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）</li></ul><p>c++11以后引入两个关键字<a href="https://zh.cppreference.com/w/cpp/language/alignas"><code>alignas</code></a>与<a href="https://zh.cppreference.com/w/cpp/language/alignof"><code>alignof</code></a>。其中<code>alignof</code>可以计算出类型的对齐方式，<code>alignas</code>可以指定结构体的对齐方式。但是仍有需要注意的点：</p><ul><li>若<code>alignas</code>小于自然对齐的最小单位，则被忽略。</li><li>如果想使用单字节对齐的方式，使用<code>alignas</code>是无效的。应该使用<code>#pragma pack(push,1)</code>或者使用<code>__attribute__((packed))</code>。</li></ul><p>用法如下：</p><pre><code class="C++">// 无效的指定 因为2小于自然对齐的大小uint32_t(4)struct alignas(2) Info2 &#123;  uint8_t a;  uint32_t b;  uint8_t c;&#125;;</code></pre><h3 id="1-3-指针和引用的区别"><a href="#1-3-指针和引用的区别" class="headerlink" title="1.3 指针和引用的区别"></a>1.3 指针和引用的区别</h3><ul><li>指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名</li><li>指针可以有多级，引用只有一级</li><li>指针可以为空，引用不能为NULL且在定义时必须初始化</li><li>指针在初始化后可以改变指向，而引用在初始化之后不可再改变</li><li>sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</li><li>引用本质是一个指针，同样会占4&#x2F;8字节内存，不过编译器对它进行了一些处理，使得程序认为它不单独占用内存空间；指针是具体变量，需要占用存储空间。</li><li>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</li><li>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</li></ul><h3 id="1-4-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"><a href="#1-4-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？" class="headerlink" title="1.4 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"></a>1.4 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</h3><ul><li>需要操作内存的时候传指针。</li><li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小。</li><li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式。</li></ul><h3 id="1-5-堆和栈的区别"><a href="#1-5-堆和栈的区别" class="headerlink" title="1.5 堆和栈的区别"></a>1.5 堆和栈的区别</h3><ul><li><p>申请方式不同。</p><p>栈由系统自动分配。<br>堆是自己申请和释放的。</p></li><li><p>申请大小限制不同。</p><p>栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。<br>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。<br>栈空间默认是4M, 堆区一般是 1G - 4G</p></li><li><p>申请效率不同。</p><p>栈由系统分配，速度快，不会有碎片。<br>堆由程序员分配，速度慢，且会有碎片。</p></li></ul><h3 id="1-6-栈为什么比堆执行快？"><a href="#1-6-栈为什么比堆执行快？" class="headerlink" title="1.6 栈为什么比堆执行快？"></a>1.6 栈为什么比堆执行快？</h3><ol><li><p>栈内存的快速访问主要是因为它通常位于主存中的相对较小的内存区域，这使得 CPU 缓存（包括一级缓存）中的数据能够快速加载到处理器中。此外，栈内存的顺序访问模式也有助于提高缓存的命中率。    </p></li><li><p>堆内存访问首先要从内存读指针地址，然后再用这个指针地址加偏移量去访问堆内存，这就导致了多一个读指令。另外，堆内存很可能不处于缓存里，尤其是第一次访问，如果再发生缺页中断会导致堆和栈出现巨大的速度差异。</p></li><li><p>堆内存需要做内存申请，这是极为耗时的操作，如果把内存申请的消耗计算在内，那栈内存的综合速度优势就又多了一项。</p></li></ol><h3 id="1-7-区别以下指针类型？"><a href="#1-7-区别以下指针类型？" class="headerlink" title="1.7 区别以下指针类型？"></a>1.7 区别以下指针类型？</h3><pre><code class="C++">int *p[10]int (*p)[10]int *p(int)int (*p)(int)</code></pre><ul><li><p>int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</p></li><li><p>int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</p></li><li><p>int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</p></li><li><p>int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</p></li></ul><h3 id="1-8-new-delete-与-malloc-free的异同"><a href="#1-8-new-delete-与-malloc-free的异同" class="headerlink" title="1.8 new &#x2F; delete 与 malloc &#x2F; free的异同"></a>1.8 new &#x2F; delete 与 malloc &#x2F; free的异同</h3><ul><li><p>相同点</p><ul><li>都可用于内存的动态申请和释放</li></ul></li><li><p>不同点</p><ul><li>前者是C++运算符，后者是C&#x2F;C++语言标准库函数</li><li>new自动计算要分配的空间大小，malloc需要手工计算</li><li>new是类型安全的，malloc不是。例如：</li></ul><pre><code>int *p = new float[2]; //编译错误*p = (int*)malloc(2 * sizeof(double));//编译无错误</code></pre><ul><li>new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者均没有相关调用</li><li>后者需要库文件支持，前者不用</li><li>new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象</li></ul></li></ul><h3 id="1-9-被free回收的内存是立即返还给操作系统吗？"><a href="#1-9-被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="1.9 被free回收的内存是立即返还给操作系统吗？"></a>1.9 被free回收的内存是立即返还给操作系统吗？</h3><ul><li>不是的，被free回收的内存会首先被内存管理系统的自由列表（free list）保存起来。常见的如ptmalloc使用双链表保存内存块，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</li></ul><h3 id="1-10-宏定义和typedef区别？"><a href="#1-10-宏定义和typedef区别？" class="headerlink" title="1.10 宏定义和typedef区别？"></a>1.10 宏定义和typedef区别？</h3><ul><li><p>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</p></li><li><p>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</p></li><li><p>宏不检查类型；typedef会检查数据类型。</p></li><li><p>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</p></li><li><p>注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。</p></li></ul><h3 id="1-11-strlen和sizeof区别？"><a href="#1-11-strlen和sizeof区别？" class="headerlink" title="1.11 strlen和sizeof区别？"></a>1.11 strlen和sizeof区别？</h3><ul><li><p>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</p></li><li><p>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</p></li><li><p>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</p></li></ul><h3 id="1-12-一个指针占多少字节？"><a href="#1-12-一个指针占多少字节？" class="headerlink" title="1.12 一个指针占多少字节？"></a>1.12 一个指针占多少字节？</h3><ul><li><p>在64位的编译环境下，指针的占用大小为8字节；</p></li><li><p>而在32位环境下，指针占用大小为4字节。</p></li><li><p>一个指针占内存的大小跟编译环境有关，而与机器的位数无关。</p></li><li><p>还有疑问的，可以自行打开Visual Studio编译器自己实验一番。</p></li></ul><h3 id="1-13-常量指针和指针常量区别？"><a href="#1-13-常量指针和指针常量区别？" class="headerlink" title="1.13 常量指针和指针常量区别？"></a>1.13 常量指针和指针常量区别？</h3><ul><li><strong>常量指针</strong>是一个指针，读成常量的指针，指向一个只读变量，也就是后面所指明的int const 和 const int，都是一个常量，可以写作：<ul><li>int const *<strong>p</strong></li><li>const int *<strong>p</strong>。</li></ul></li></ul><blockquote><p><strong>常量指针</strong>-&gt;指向常量的指针<br><strong>常量指针</strong>-&gt;不可改变内容，但可以改变指向的地址。 </p></blockquote><ul><li><strong>指针常量</strong>是一个常量，必须初始化，一旦初始化完成，它的值（也就是存放在指针中的地址）就不能在改变了，即不能中途改变指向，如：<ul><li>int *const <strong>p</strong>。<blockquote><p><strong>指针常量</strong>-&gt;常量<br><strong>指针常量</strong>-&gt;不可改变指向的地址，但可以改变地址存放的数据。</p></blockquote></li></ul></li></ul><h3 id="1-13-2-顶层const与底层const"><a href="#1-13-2-顶层const与底层const" class="headerlink" title="1.13.2 顶层const与底层const"></a>1.13.2 顶层const与底层const</h3><ul><li>顶层const：指针本身是一个常量；</li><li>底层const：指针所指对象是一个常量；</li></ul><h3 id="1-14-C-和C语言的区别"><a href="#1-14-C-和C语言的区别" class="headerlink" title="1.14 C++和C语言的区别"></a>1.14 C++和C语言的区别</h3><ul><li><strong>面向对象编程（OOP）</strong>：<br>C++ 是一种支持面向对象编程的语言，它引入了类和对象的概念，以及封装、继承和多态等面向对象的特性。<br>C 语言虽然也可以编写面向对象的代码，但它没有内建的语言特性来支持面向对象编程，因此需要使用结构体和函数来模拟类和对象。</li><li><strong>标准库</strong>：<br>C++ 标准库（STL）提供了许多丰富的数据结构和算法，如向量、列表、映射、排序和搜索等。<br>C 语言的标准库相对较小，只提供了一些基本的数据类型和函数，如整数、字符、字符串和文件处理等。</li><li><strong>内存管理</strong>：<br>C++ 支持动态内存分配和释放，引入了 new 和 delete 运算符用于动态分配和释放内存。<br>C 语言也支持动态内存分配和释放，但是使用的是 malloc() 和 free() 函数。</li><li><strong>异常处理</strong>：<br>C++ 支持异常处理机制，可以使用 try、catch 和 throw 关键字来处理异常情况。<br>C 语言没有内建的异常处理机制，通常通过返回值或错误码来处理异常情况。</li><li><strong>其他特性</strong>：<br>C++ 还引入了许多其他特性，如模板、命名空间、运算符重载和函数重载等，以提高代码的灵活性和可复用性。<br>C 语言相对较简单，更加接近硬件和操作系统，因此更适用于系统级编程和嵌入式开发。</li></ul><p>总的来说，C++ 是在 C 语言基础上发展而来的，它继承了 C 语言的一些特性，并引入了更多的高级特性，如面向对象编程和异常处理等，使得它更加适用于大型项目和复杂的软件开发。</p><h3 id="1-15-C-中struct和class的区别"><a href="#1-15-C-中struct和class的区别" class="headerlink" title="1.15 C++中struct和class的区别"></a>1.15 C++中struct和class的区别</h3><ul><li><p>相同点  </p><p>两者都拥有成员函数、公有和私有部分<br>任何可以使用class完成的工作，同样可以使用struct完成</p></li><li><p>不同点</p><p>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</p><p>class默认是private继承， 而struct默认是public继承</p></li></ul><h3 id="1-16-define宏定义和const的区别"><a href="#1-16-define宏定义和const的区别" class="headerlink" title="1.16 define宏定义和const的区别"></a>1.16 define宏定义和const的区别</h3><p><strong>编译阶段</strong></p><ul><li>define是在编译的<code>预处理阶段</code>起作用，而const是在<code>编译、运行</code>的时候起作用</li></ul><p><strong>安全性</strong></p><ul><li>define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错  </li><li>const常量有数据类型，编译器可以对其进行类型安全检查</li></ul><p><strong>内存占用</strong></p><ul><li>define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表</li></ul><h3 id="1-17-数组名和指针（这里为指向数组首元素的指针）区别？"><a href="#1-17-数组名和指针（这里为指向数组首元素的指针）区别？" class="headerlink" title="1.17 数组名和指针（这里为指向数组首元素的指针）区别？"></a>1.17 数组名和指针（这里为指向数组首元素的指针）区别？</h3><ul><li><p>二者均可通过增减偏移量来访问数组中的元素。</p></li><li><p>数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</p></li><li><p><strong>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</strong></p></li></ul><h3 id="1-18-extern”C”的用法"><a href="#1-18-extern”C”的用法" class="headerlink" title="1.18 extern”C”的用法"></a>1.18 extern”C”的用法</h3><ul><li>为了能够正确的在C++代码中调用C语言的代码：在程序中加上extern “C”后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++。</li></ul><h3 id="1-19-野指针和悬空指针"><a href="#1-19-野指针和悬空指针" class="headerlink" title="1.19 野指针和悬空指针"></a>1.19 野指针和悬空指针</h3><pre><code>都是是指向无效内存区域(这里的无效指的是&quot;不安全不可控&quot;)的指针，访问行为将会导致未定义行为。</code></pre><ul><li><strong>野指针</strong><br>野指针，指的是没有被初始化过的指针</li><li><strong>悬空指针</strong><br>悬空指针，指针最初指向的内存已经被释放了的一种指针。</li></ul><p>使用智能指针可以有效解决问题。</p><h3 id="1-20-C-中的重载、重写（覆盖）和隐藏的区别"><a href="#1-20-C-中的重载、重写（覆盖）和隐藏的区别" class="headerlink" title="1.20 C++中的重载、重写（覆盖）和隐藏的区别"></a>1.20 C++中的重载、重写（覆盖）和隐藏的区别</h3><ol><li><p><strong>重载（overload）</strong><br>  重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是<code>返回类型</code>和<code>函数名</code>相同，<code>参数类型和数目</code>有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个例子：</p></li><li><p><strong>重写（覆盖）（override）</strong><br>  重写指的是在派生类中覆盖基类中的同名函数，重写就是重写函数体，要求基类函数必须是虚函数且：</p><ul><li>与基类的虚函数有相同的参数个数</li><li>与基类的虚函数有相同的参数类型</li><li>与基类的虚函数有相同的返回值类型</li></ul></li><li><p><strong>隐藏（hide）</strong><br>  隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：</p><ul><li>两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。</li></ul><pre><code class="C++">  //父类  class A&#123;  public:      void fun(int a)&#123;      cout &lt;&lt; &quot;A中的fun函数&quot; &lt;&lt; endl;    &#125;  &#125;;  //子类  class B : public A&#123;  public:      //隐藏父类的fun函数      void fun(int a)&#123;      cout &lt;&lt; &quot;B中的fun函数&quot; &lt;&lt; endl;    &#125;  &#125;;  int main()&#123;      B b;      b.fun(2); //调用的是B中的fun函数      b.A::fun(2); //调用A中fun函数      return 0;  &#125;</code></pre><ul><li>两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。</li></ul><pre><code class="C++">  //父类  class A&#123;  public:      virtual void fun(int a)&#123;      cout &lt;&lt; &quot;A中的fun函数&quot; &lt;&lt; endl;    &#125;  &#125;;  //子类  class B : public A&#123;  public:      //隐藏父类的fun函数    virtual void fun(char* a)&#123;      cout &lt;&lt; &quot;A中的fun函数&quot; &lt;&lt; endl;    &#125;  &#125;;  int main()&#123;      B b;      b.fun(2); //报错，调用的是B中的fun函数，参数类型不对      b.A::fun(2); //调用A中fun函数      return 0;  &#125;</code></pre></li></ol><h3 id="1-21-浅拷贝和深拷贝的区别"><a href="#1-21-浅拷贝和深拷贝的区别" class="headerlink" title="1.21 浅拷贝和深拷贝的区别"></a>1.21 浅拷贝和深拷贝的区别</h3><ul><li><p><strong>浅拷贝</strong>  </p><p>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p></li><li><p><strong>深拷贝</strong></p><p>深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。</p></li></ul><h3 id="1-22-内联函数和宏定义的区别"><a href="#1-22-内联函数和宏定义的区别" class="headerlink" title="1.22 内联函数和宏定义的区别"></a>1.22 内联函数和宏定义的区别</h3><ul><li>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。</li><li>内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。</li><li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义<br>内联函数有类型检测、语法判断等功能，而宏没有<blockquote><p>注意：使用<code>inline</code>关键字只是建议编译器内联函数，内联函数是否真的内联还需要编译器判断。</p></blockquote></li></ul><h3 id="1-23-public，protected和private访问和继承权限-public-protected-private的区别？"><a href="#1-23-public，protected和private访问和继承权限-public-protected-private的区别？" class="headerlink" title="1.23 public，protected和private访问和继承权限&#x2F;public&#x2F;protected&#x2F;private的区别？"></a>1.23 public，protected和private访问和继承权限&#x2F;public&#x2F;protected&#x2F;private的区别？</h3><ul><li><p><strong>访问权限</strong></p><ul><li><p>public的变量和函数在类的内部外部都可以访问。</p></li><li><p>protected的变量和函数只能在类的内部和其派生类中访问。</p></li><li><p>private修饰的元素只能在类内访问。</p></li></ul></li><li><p><strong>继承权限</strong></p><ul><li><p>public继承（公有继承）的特点是基类的公有成员和保护成员作为派生类的成员时，都保持原有的状态，而基类的私有成员任然是私有的，不能被这个派生类的子类所访问</p></li><li><p>protected继承（保护继承）的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元函数访问，基类的私有成员仍然是私有的</p></li><li><p>private继承（私有继承）的特点是基类的所有公有成员和保护成员都成为派生类的私有成员，并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承</p></li></ul></li></ul><h3 id="1-24-如何用代码判断大小端存储？"><a href="#1-24-如何用代码判断大小端存储？" class="headerlink" title="1.24 如何用代码判断大小端存储？"></a>1.24 如何用代码判断大小端存储？</h3><ul><li><p>大端存储：字数据的高字节存储在低地址中  –&gt; 高位在前</p></li><li><p>小端存储：字数据的低字节存储在低地址中  –&gt; 高位在后</p><p>使用强制类型转换判断大小端存储</p><pre><code class="C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int a = 0x1234;    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分    char c = (char)(a);    if (c == 0x12)        cout &lt;&lt; &quot;big endian&quot; &lt;&lt; endl;    else if(c == 0x34)        cout &lt;&lt; &quot;little endian&quot; &lt;&lt; endl;&#125;</code></pre></li></ul><h3 id="1-25-volatile、mutable和explicit关键字的用法"><a href="#1-25-volatile、mutable和explicit关键字的用法" class="headerlink" title="1.25 volatile、mutable和explicit关键字的用法"></a>1.25 volatile、mutable和explicit关键字的用法</h3><ol><li><p><strong>volatile</strong><br>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</p></li><li><p><strong>mutable</strong><br>mutable的中文意思是“可变的，易变的”，跟constant（即C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要<code>在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置</code>。</p></li></ol><pre><code class="C++">class person&#123;    int m_A;    mutable int m_B;//特殊变量 在常函数里值也可以被修改public:    void add() const//在函数里不可修改this指针指向的值 常量指针    &#123;        m_A = 10;//错误  不可修改值，this已经被修饰为常量指针        m_B = 20;//正确    &#125;&#125;;</code></pre><pre><code class="C++">class person&#123;public:    int m_A;    mutable int m_B;//特殊变量 在常函数里值也可以被修改&#125;;int main()&#123;    const person p = person();//修饰常对象 不可修改类成员的值    p.m_A = 10;//错误，被修饰了指针常量    p.m_B = 200;//正确，特殊变量，修饰了mutable&#125;</code></pre><ol start="3"><li><p><strong>explicit</strong><br>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显式的方式进行类型转换，注意以下几点：</p><ul><li>explicit 关键字只能用于类内部的构造函数声明上</li><li>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</li></ul></li></ol><h3 id="1-26-C-的异常处理的方法"><a href="#1-26-C-的异常处理的方法" class="headerlink" title="1.26 C++的异常处理的方法"></a>1.26 C++的异常处理的方法</h3><p>在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：</p><ul><li>数组下标越界</li><li>除法计算时除数为0</li><li>动态分配空间时空间不足</li></ul><p>如果不及时对这些异常进行处理，程序多数情况下都会崩溃。</p><p>C++中的异常处理机制主要使用try、throw和catch三个关键字，其在程序中的用法如下：</p><pre><code class="C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    double m = 1, n = 0;    try &#123;        cout &lt;&lt; &quot;before dividing.&quot; &lt;&lt; endl;        if (n == 0)            throw - 1;  //抛出int型异常        else if (m == 0)            throw - 1.0;  //拋出 double 型异常        else            cout &lt;&lt; m / n &lt;&lt; endl;        cout &lt;&lt; &quot;after dividing.&quot; &lt;&lt; endl;    &#125;    catch (double d) &#123;        cout &lt;&lt; &quot;catch (double)&quot; &lt;&lt; d &lt;&lt; endl;    &#125;    catch (...) &#123;        cout &lt;&lt; &quot;catch (...)&quot; &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;finished&quot; &lt;&lt; endl;    return 0;&#125;</code></pre><p>代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。<br><strong>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）。</strong><br>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以<code>在catch里面再throw异常</code>。</p><h3 id="1-27-static的用法和作用？"><a href="#1-27-static的用法和作用？" class="headerlink" title="1.27 static的用法和作用？"></a>1.27 static的用法和作用？</h3><ol><li><p>先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）<br>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</p></li><li><p>static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。</p></li><li><p>static的第三个作用是默认初始化为0（static变量）<br>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。</p></li><li><p>static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；</p></li><li><p>由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问static修饰的类成员；</p></li><li><p>static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this-&gt;vptr-&gt;ctable-&gt;virtual function</p></li></ol><h3 id="1-28-成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？"><a href="#1-28-成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？" class="headerlink" title="1.28 成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"></a>1.28 成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</h3><p>赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化。<br>这两种方式的主要区别在于：</p><ul><li><p>对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。</p></li><li><p>列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。</p></li></ul><h3 id="1-29-有哪些情况必须用到成员列表初始化？作用是什么？"><a href="#1-29-有哪些情况必须用到成员列表初始化？作用是什么？" class="headerlink" title="1.29 有哪些情况必须用到成员列表初始化？作用是什么？"></a>1.29 有哪些情况必须用到成员列表初始化？作用是什么？</h3><ul><li><p><strong>常量成员变量：</strong></p><p>如果类中包含<code>const</code>或者<code>引用类型</code>的成员变量，则必须使用成员列表初始化对它们进行初始化。<br>因为常量成员变量和引用类型成员变量无法在构造函数内部进行赋值，只能通过成员列表初始化来初始化它们。  </p></li><li><p><strong>继承的成员变量：</strong></p><p>如果<code>派生类继承了基类的成员变量，且基类没有默认构造函数</code>，则必须使用成员列表初始化来调用基类的构造函数对基类成员变量进行初始化。  </p></li><li><p><strong>成员对象：</strong></p><p>如果<code>类中包含其他类对象作为成员变量</code>，则最好使用成员列表初始化对这些成员对象进行初始化。<br>这样可以避免在构造函数体内部对成员对象进行默认初始化后再赋值，而直接在构造函数的初始化列表中完成初始化。</p></li></ul><h3 id="1-30-什么是内存泄露，如何检测与避免"><a href="#1-30-什么是内存泄露，如何检测与避免" class="headerlink" title="1.30 什么是内存泄露，如何检测与避免"></a>1.30 什么是内存泄露，如何检测与避免</h3><ul><li><p>内存泄露</p><p>一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了</p></li><li><p>避免内存泄露的几种方式</p><ul><li>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</li><li>一定要将基类的析构函数声明为虚函数</li><li>对象数组的释放一定要用delete []</li><li>有new就有delete，有malloc就有free，保证它们一定成对出现</li></ul></li><li><p>检测工具</p><ul><li>Linux下可以使用Valgrind工具  </li><li>Windows下可以使用CRT库</li></ul></li></ul><h3 id="1-31-对象复用的了解，零拷贝的了解"><a href="#1-31-对象复用的了解，零拷贝的了解" class="headerlink" title="1.31 对象复用的了解，零拷贝的了解"></a>1.31 对象复用的了解，零拷贝的了解</h3><ul><li><p>对象复用：</p><ul><li>对象复用是指在程序执行过程中，重复使用已经创建的对象，而不是频繁地创建新的对象。通过对象复用，可以减少资源的消耗和提高性能。</li><li>对象复用通常适用于那些需要频繁创建和销毁的对象，比如线程池中的线程对象、连接池中的数据库连接等。通过将这些对象创建一次，然后在需要时重复利用，可以避免反复创建对象的开销，提高系统的效率。</li></ul></li><li><p>零拷贝：</p><ul><li>零拷贝是一种优化技术，用于在数据传输过程中减少或消除不必要的数据拷贝操作。通过零拷贝技术，可以提高数据传输的效率和降低系统的负载。</li><li>零拷贝通常应用于文件传输、网络通信等场景中。例如，在网络通信中，零拷贝技术可以避免将数据从用户空间拷贝到内核空间，再从内核空间拷贝到网络缓冲区的过程，而是直接在用户空间和网络缓冲区之间进行数据传输，从而提高了数据传输的效率。</li><li>零拷贝的主要实现有mmap() （内存映射）</li></ul></li></ul><blockquote><p>DMA(Direct Memory Access-直接内存访问)和零拷贝详细介绍 -&gt; <a href="https://zhuanlan.zhihu.com/p/360343446">【linux】图文并茂|彻底搞懂零拷贝（Zero-Copy）技术</a></p></blockquote><h3 id="1-32-C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast"><a href="#1-32-C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast" class="headerlink" title="1.32 C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast &#x2F;dynamic_cast"></a>1.32 C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast &#x2F;dynamic_cast</h3><ul><li><p>reinterpret_cast：</p><ul><li>reinterpret_cast 可以用于将一个指针或引用转换为另一种不同类型的指针或引用。它可以执行任意类型之间的转换，甚至是不兼容的类型。</li><li>reinterpret_cast 对转换的类型没有限制，它不进行类型检查，因此需要谨慎使用。</li><li>reinterpret_cast 主要用于进行底层的类型转换，如指针之间的转换或者将整数类型转换为指针类型等。</li></ul></li><li><p>const_cast：</p><ul><li>const_cast 主要用于去除表达式中的 const 或 volatile 修饰符，以便修改被修饰对象的值。</li><li>const_cast 只能用于去除 const 或 volatile 限定符，不能进行其他类型的转换。</li><li>const_cast 的使用场景通常是在需要对 const 对象进行修改时，或者在调用函数时需要去除函数参数的 const 修饰符。</li></ul></li><li><p>static_cast：</p><ul><li>static_cast 用于执行静态类型转换，可以在编译时进行类型检查，因此比较安全。</li><li>static_cast 可以执行基本类型之间的转换，如整数之间的转换、指针类型之间的转换，以及类之间的上行转换（派生类指针向基类指针的转换）和下行转换（基类指针向派生类指针的转换）。</li><li>static_cast 也可以用于显式调用构造函数和转换构造函数进行类型转换。</li></ul></li><li><p>dynamic_cast：</p><ul><li>dynamic_cast 用于执行动态类型转换，主要用于在运行时进行类型检查和转换，通常用于处理继承关系的类。</li><li>dynamic_cast 只能用于类类型之间的转换，并且其中至少一个类必须具有虚函数。它用于在类层次结构中安全地进行上行转换和下行转换，并且在转换失败时返回 nullptr（对于指针类型）或抛出 std::bad_cast 异常（对于引用类型）。</li></ul></li></ul><h3 id="1-33-写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？"><a href="#1-33-写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？" class="headerlink" title="1.33 写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？"></a>1.33 写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？</h3><p>  coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p><p>  如何使用gdb调试coredump：</p><ul><li>分析core dump：使用调试工具（如gdb）来分析core dump文件。可以通过以下命令来启动gdb并加载core dump文件：  <pre><code class="bash">gdb [可执行文件名] [core文件名]</code></pre></li><li>查看崩溃位置：在gdb中可以使用backtrace命令（简写为bt）来查看程序崩溃时的调用栈，这可以帮助你找到崩溃位置。命令如下：<pre><code class="bash">(gdb) bt</code></pre></li><li>查看变量状态：通过在崩溃位置设置断点，并使用print命令来查看变量的值，可以帮助你理解程序崩溃的原因。例如：<pre><code class="bash">(gdb) break &lt;line_number&gt;(gdb) run(gdb) print &lt;variable_name&gt;</code></pre></li></ul><h3 id="1-34-说说移动构造函数"><a href="#1-34-说说移动构造函数" class="headerlink" title="1.34 说说移动构造函数"></a>1.34 说说移动构造函数</h3><p>移动构造函数是C++11引入的一个特性，它允许在对象的所有权转移时执行高效的资源移动，而不是传统的拷贝。移动构造函数通常用于实现在不再需要源对象的情况下，将其内容“移动”到新创建的对象中，从而避免不必要的内存分配和数据复制。</p><p>移动构造函数的语法如下：</p><pre><code class="c++">class MyClass &#123;public:    // 移动构造函数    MyClass(MyClass&amp;&amp; other) noexcept &#123;        // 在此处执行资源的移动操作        // 将other对象的资源转移到当前对象中    &#125;&#125;;</code></pre><p>在移动构造函数中，参数通常是一个右值引用（通过使用双引号&amp;&amp;），表示将要被移动的对象。关键字<code>noexcept</code>是一个可选的说明符，表示该函数不会抛出异常。这对于某些情况下的优化是有帮助的。</p><p>移动构造函数通常用于以下几种情况：</p><ol><li>当返回临时对象时，避免不必要的拷贝。例如：<pre><code class="c++">MyClass createObject() &#123;    MyClass temp;    // 初始化temp对象    return temp; // 调用移动构造函数而不是拷贝构造函数&#125;</code></pre></li><li>当将一个对象插入容器时，可以使用移动构造函数将对象移入容器中，而不是复制：<pre><code class="c++">std::vector&lt;MyClass&gt; myVector;MyClass obj;myVector.push_back(std::move(obj)); // 使用 std::move 将对象移入容器中</code></pre></li><li>当需要动态分配内存时，可以使用移动语义来避免额外的内存拷贝。</li></ol><h3 id="1-35-C-中将临时变量作为返回值时的处理过程"><a href="#1-35-C-中将临时变量作为返回值时的处理过程" class="headerlink" title="1.35 C++中将临时变量作为返回值时的处理过程"></a>1.35 C++中将临时变量作为返回值时的处理过程</h3><p>首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</p><p>C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit</p><p>由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系</p><p>如果我们需要返回值，一般使用赋值语句就可以了。</p><h3 id="1-36-如何获得结构成员相对于结构开头的字节偏移量"><a href="#1-36-如何获得结构成员相对于结构开头的字节偏移量" class="headerlink" title="1.36 如何获得结构成员相对于结构开头的字节偏移量"></a>1.36 如何获得结构成员相对于结构开头的字节偏移量</h3><p>使用&lt;stddef.h&gt;头文件中的，offsetof宏。</p><pre><code class="C++">#include &lt;cstddef&gt;#include &lt;iostream&gt;struct MyStruct &#123;    int a;    char b;    double c;&#125;;int main() &#123;    std::cout &lt;&lt; &quot;Offset of &#39;a&#39; in MyStruct: &quot; &lt;&lt; offsetof(MyStruct, a) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Offset of &#39;b&#39; in MyStruct: &quot; &lt;&lt; offsetof(MyStruct, b) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Offset of &#39;c&#39; in MyStruct: &quot; &lt;&lt; offsetof(MyStruct, c) &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>输出：</p><pre><code class="sql">Offset of &#39;a&#39; in MyStruct: 0Offset of &#39;b&#39; in MyStruct: 4Offset of &#39;c&#39; in MyStruct: 8</code></pre><h3 id="1-37-怎样判断两个浮点数是否相等？"><a href="#1-37-怎样判断两个浮点数是否相等？" class="headerlink" title="1.37 怎样判断两个浮点数是否相等？"></a>1.37 怎样判断两个浮点数是否相等？</h3><p>对两个浮点数判断大小和是否相等不能直接用&#x3D;&#x3D;来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过<code>相减并与预先设定的精度比较</code>，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。</p><h3 id="1-38-C-的标准库，STL及std的区别"><a href="#1-38-C-的标准库，STL及std的区别" class="headerlink" title="1.38 C++的标准库，STL及std的区别"></a>1.38 C++的标准库，STL及std的区别</h3><ul><li>std（Standard）</li><li>STL（Standard Template Library）  </li><li>STL是标准模板库，是标准库的子集。主要是容器、算法、迭代器。标准库还包括stream，string等，STL大约占了标准库内容得80%</li><li>std是命名空间的名字，目的是为了避免命名空间污染。模板库（包括stl）的设计者，特意在库文件里面加上了命名空间。这样，我们使用者就可以在定义自己的函数时，定义自己的命名空间。然后在自己定义的命名空间作用域范围内，使用我们自己定义的、但可能和标准库里的函数重名的函数。这样就不会有函数冲突了，使用时注意命名空间的作用域就好了！</li><li>模板库（包括stl，stream,string）中的所有名字的使用都得通过std::。</li></ul><h3 id="1-39-C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"><a href="#1-39-C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？" class="headerlink" title="1.39 C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"></a>1.39 C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</h3><p>在 C++ 中，指针参数传递和引用参数传递都可以用于实现函数之间的参数传递，它们之间有一些区别：</p><ol><li>指针参数传递：  <ul><li>指针参数传递是通过将参数声明为指针类型来实现的。在函数内部，可以通过解引用指针来访问参数所指向的对象。</li><li>指针参数传递需要在函数调用时传递指针的地址，因此需要额外的内存空间存储指针地址。（本质上是值传递，它所传递的是一个地址值。）</li><li>指针参数可以为空（即指向空指针），因此需要在函数内部进行空指针检查，以防止出现空指针异常。</li></ul></li><li>引用参数传递：  <ul><li>引用参数传递是通过将参数声明为引用类型来实现的。在函数内部，引用参数直接绑定到传递给函数的对象上，不需要解引用操作。</li><li>引用参数传递不需要额外的内存空间存储地址，因为引用本身就是目标对象的别名。</li><li>引用参数不能为空，因为引用必须引用一个有效的对象。</li></ul></li></ol><p>底层原理：  </p><ul><li>指针参数传递的底层原理是将指针的值（即地址）传递给函数，函数内部通过解引用指针来访问所指向的对象。</li><li>引用参数传递的底层原理是将引用绑定到传递给函数的对象上，因此在函数内部直接操作引用就相当于操作原始对象。</li></ul><p>总的来说，引用参数传递更加简洁和安全，因为它不需要对空指针进行检查，并且在函数调用时不会产生额外的开销。但是在某些情况下，指针参数传递可能更加灵活，例如需要允许空指针传递的情况。</p><h3 id="1-40-类如何实现只能静态分配和只能动态分配"><a href="#1-40-类如何实现只能静态分配和只能动态分配" class="headerlink" title="1.40 类如何实现只能静态分配和只能动态分配"></a>1.40 类如何实现只能静态分配和只能动态分配</h3><ul><li><strong>只能静态分配的类：</strong><br>如果希望类的对象只能在栈上分配，可以通过禁用类的动态内存分配来实现：<ul><li>删除<code>new</code>和<code>delete</code>运算符的重载</li><li>将它们声明为私有成员，以阻止类的用户使用动态内存分配<pre><code class="cpp">class StaticAllocatedClass &#123;public:    // 禁用 new 和 delete 运算符    void* operator new(std::size_t) = delete;    void operator delete(void*) = delete;&#125;;</code></pre></li></ul></li><li><strong>只能动态分配的类：</strong>  <ul><li>如果希望类的对象只能在堆上分配，可以在类中重载<code>new</code>和<code>delete</code>运算符，并将它们设置为私有或者保护成员，以防止用户直接调用。<pre><code class="cpp">class DynamicAllocatedClass &#123;public:    // 重载 new 和 delete 运算符    void* operator new(std::size_t size) &#123;        return ::operator new(size);    &#125;    void operator delete(void* ptr) &#123;        ::operator delete(ptr);    &#125;private:    // 防止直接创建对象    DynamicAllocatedClass() &#123;&#125;&#125;;</code></pre></li></ul></li></ul><h3 id="1-41-知道C-中的组合吗？它与继承相比有什么优缺点吗？"><a href="#1-41-知道C-中的组合吗？它与继承相比有什么优缺点吗？" class="headerlink" title="1.41 知道C++中的组合吗？它与继承相比有什么优缺点吗？"></a>1.41 知道C++中的组合吗？它与继承相比有什么优缺点吗？</h3><p>在面向对象编程中，组合（Composition）是一种将多个类组合在一起创建新的类的方式。在组合关系中，一个类包含另一个类的实例作为其成员变量，这种关系表达了“具有”的关系，而不是“是一个”的关系。</p><p>与继承相比，组合的优缺点如下：</p><ul><li><p>优点：</p><ul><li>灵活性： 组合关系更灵活，因为它不会限制子类必须继承特定的行为或属性，而是通过组合已有的类来实现新的功能。</li><li>松耦合： 组合关系降低了类之间的耦合度，因为类之间的关系更加简单明确，不会引入不必要的依赖。</li><li>封装性： 组合可以带来更好的封装性，因为组合的类可以选择性地暴露其内部成员，对外部隐藏实现细节。</li><li>易于维护： 组合关系使得代码结构更清晰，易于理解和维护。</li></ul></li><li><p>缺点：</p><ul><li>代码重复： 在组合关系中，如果多个类都需要相同的功能或属性，可能会导致代码重复，增加了代码量和维护成本。</li><li>初始化复杂： 当一个类包含多个其他类的实例作为成员变量时，初始化对象可能变得更加复杂。</li><li>性能开销： 在运行时，由于需要额外的内存分配和对象构造，组合关系可能会引入一定的性能开销。</li></ul></li></ul><p>总的来说，组合关系提供了一种更加灵活和松耦合的方式来构建对象，可以避免继承带来的一些问题，但也需要注意代码重复和初始化复杂性等缺点。选择组合还是继承取决于具体的设计需求和问题领域，需要综合考虑各方面的因素来做出合适的选择。</p><h3 id="1-42-函数指针？"><a href="#1-42-函数指针？" class="headerlink" title="1.42 函数指针？"></a>1.42 函数指针？</h3><p>函数指针是指向函数的指针变量，它存储了函数的地址，可以用来间接地调用函数。在 C 和 C++ 中，函数指针的语法如下：</p><pre><code class="cpp">return_type (*pointer_name)(parameter_types);</code></pre><p>函数指针在 C 和 C++ 中具有多种用途，包括但不限于以下几个方面：</p><ul><li><p>回调函数： 函数指针可以作为参数传递给其他函数，从而实现回调函数的机制。通过回调函数，可以在运行时指定需要调用的函数，从而实现灵活的控制流程。这在事件处理、信号处理等场景中非常常见。</p></li><li><p>动态选择函数： 函数指针可以根据不同的条件动态地选择调用不同的函数，从而实现更灵活的程序逻辑。这种技术常用于状态机、策略模式等场景。</p></li><li><p>实现多态性： 在 C++ 中，函数指针可以用于实现简单的多态性，虽然它不如虚函数表那样灵活，但可以实现类似的功能。通过函数指针，可以在运行时选择不同的函数实现，从而实现对象的多态行为。</p></li><li><p>动态加载库函数： 在动态链接库（DLL）和共享对象（SO）中，函数指针可以用于动态加载库函数，从而实现在运行时加载和调用特定库函数的功能。这在插件系统、动态扩展功能等场景中非常有用。</p></li></ul><h3 id="1-43-为什么要进行内存对齐"><a href="#1-43-为什么要进行内存对齐" class="headerlink" title="1.43 为什么要进行内存对齐"></a>1.43 为什么要进行内存对齐</h3><p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.</p><p>现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。</p><p>假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的连续四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.</p><h3 id="1-44-内存对齐规则"><a href="#1-44-内存对齐规则" class="headerlink" title="1.44 内存对齐规则"></a>1.44 内存对齐规则</h3><ul><li>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认<code>#pragma pack(4)</code>，可以通过预编译命令#pragma pack(n)，n &#x3D; 1,2,4,8,16来改变这一系数。</li></ul><p>有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。</p><p>了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：</p><ul><li><p><strong>基本类型的对齐规则：</strong> 基本数据类型在内存中的存储位置通常要求是其自身大小的整数倍。例如，一个字节大小的字符通常需要对齐到地址为1的位置，一个四字节大小的整数通常需要对齐到地址为4的位置。</p></li><li><p><strong>结构体和类的对齐规则：</strong> 结构体和类的对齐规则是其成员中大小最大的成员大小的整数倍。这样做的目的是为了保证结构体或类的成员都能够按照其自身的对齐要求存储，从而保证结构体或类的实例的起始地址是合法的。</p></li><li><p><strong>指针类型的对齐规则：</strong> 指针类型的大小通常与机器的地址长度相等，因此指针类型的对齐规则通常与基本类型的对齐规则相同。</p></li></ul><h3 id="1-45-static变量"><a href="#1-45-static变量" class="headerlink" title="1.45 static变量"></a>1.45 static变量</h3><p>静态变量是在程序执行期间存在且只初始化一次的变量，它的生存周期与程序的运行周期相同。在C和C++中，静态变量可以分为两种类型：</p><ul><li><p>局部静态变量（Static Local Variable）： 在函数内部声明的静态变量称为局部静态变量。这些变量在函数被调用时被创建，在程序的整个生命周期内保持存在，并且只被初始化一次。局部静态变量的作用域仅限于声明它们的函数内部。</p><pre><code class="cpp">void func() &#123;    static int count = 0; // 局部静态变量    count++;    printf(&quot;Count: %d\n&quot;, count);&#125;</code></pre></li><li><p>全局静态变量（Static Global Variable）： 在函数外部声明的静态变量称为全局静态变量。这些变量在程序启动时被创建，在程序的整个生命周期内保持存在，并且只被初始化一次。全局静态变量的作用域为<code>整个文件</code>，对其他文件不可见（除非使用<code>extern</code>关键字进行声明）。</p><pre><code class="cpp">static int globalVar = 5; // 全局静态变量</code></pre></li><li><p>静态变量的特点包括：</p><ul><li>在内存中分配固定的存储空间，存储在静态存储区域。</li><li>生命周期与程序运行周期相同，程序结束时才被销毁。</li><li>未初始化时，默认值为0。</li><li>局部静态变量在函数内部可见，全局静态变量在整个文件内可见。</li><li>静态变量的值在函数调用之间保持不变。</li><li>静态变量在程序中的应用包括：存储全局状态、实现单例模式、记录函数调用次数等。由于静态变量的生存周期和作用域特性，它们通常用于需要持久存储数据的情况。</li></ul></li></ul><h3 id="1-46-extern和static"><a href="#1-46-extern和static" class="headerlink" title="1.46 extern和static"></a>1.46 extern和static</h3><p><code>extern</code>和<code>static</code>都是用来限定变量或函数的作用域和链接属性的关键字，但它们的作用方式有所不同。</p><ul><li><p>extern：</p><ul><li><p>extern 用于声明变量或函数，表示该变量或函数是在其他源文件中定义的，当前源文件中只是进行了声明，实际定义在其他地方。</p></li><li><p>当使用 extern 声明变量时，编译器不会为该变量分配存储空间，只是告诉编译器该变量是在其他地方定义的。</p></li><li><p>extern 声明通常用于在多个源文件中共享全局变量或函数的声明。</p></li></ul><p>例如：</p><pre><code class="cpp">// File1.cppint globalVar = 5; // 定义全局变量// File2.cppextern int globalVar; // 声明全局变量</code></pre></li><li><p>static：</p><ul><li><p>static 用于声明静态变量或函数，限定其作用域为当前文件，在其他文件中无法访问。</p></li><li><p>当使用 static 声明变量或函数时，它们的作用域仅限于当前源文件，对其他源文件不可见。</p></li><li><p>对于全局变量，static 关键字也可以用于限定其链接属性，使其只能在当前文件中访问，称为文件作用域全局变量。</p></li></ul><p>例如：</p><pre><code class="cpp">// File1.cppstatic int localVar = 10; // 声明文件作用域的静态变量// File2.cpp// 在 File2.cpp 中无法访问 localVar</code></pre></li></ul><p>总结：</p><ul><li><p>extern 用于声明外部变量或函数，使得在当前文件中可以引用其他文件中定义的全局变量或函数。</p></li><li><p>static 用于限定变量或函数的作用域为当前文件，使得它们只能在当前文件中可见，对其他文件不可见。</p></li></ul><h3 id="1-47-如何在不使用额外空间的情况下，交换两个数？你有几种方法"><a href="#1-47-如何在不使用额外空间的情况下，交换两个数？你有几种方法" class="headerlink" title="1.47 如何在不使用额外空间的情况下，交换两个数？你有几种方法"></a>1.47 如何在不使用额外空间的情况下，交换两个数？你有几种方法</h3><ol><li>使用加法和减法：<pre><code class="cpp">a = a + b;b = a - b;a = a - b;</code></pre></li><li>使用异或操作：<pre><code class="cpp">a = a ^ b;b = a ^ b;a = a ^ b;</code></pre></li><li>使用加法和位移：<pre><code class="cpp">a = a + b;b = a - b;a = (a - b) &gt;&gt; 1;</code></pre></li><li>使用乘法和除法：<pre><code class="cpp">a = a * b;b = a / b;a = a / b;</code></pre></li></ol><p>这些方法都是在不使用额外空间的情况下，通过数学运算来交换两个数的值。其中，使用异或操作是最常见的方法，因为它既简单又高效。</p><h3 id="1-48-strcpy-和-memcpy-的区别"><a href="#1-48-strcpy-和-memcpy-的区别" class="headerlink" title="1.48 strcpy 和 memcpy 的区别"></a>1.48 strcpy 和 memcpy 的区别</h3><ol><li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 </li><li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 </li><li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li></ol><h3 id="1-49-程序在执行int-main-int-argc-char-argv-时的内存结构"><a href="#1-49-程序在执行int-main-int-argc-char-argv-时的内存结构" class="headerlink" title="1.49 程序在执行int main(int argc, char *argv[])时的内存结构"></a>1.49 程序在执行int main(int argc, char *argv[])时的内存结构</h3><p>参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针</p><p><code>char *</code>指向的内存中，数组的中元素的个数为<code>argc</code>个，第一个参数为<code>程序的名称</code>。</p><h3 id="1-50-volatile关键字的作用？"><a href="#1-50-volatile关键字的作用？" class="headerlink" title="1.50 volatile关键字的作用？"></a>1.50 volatile关键字的作用？</h3><p><code>volatile</code>关键字用于告诉编译器，被 volatile 修饰的变量可能会在程序执行过程中被意外修改，因此编译器不应该对这些变量进行优化。</p><p>具体来说，volatile 关键字的作用包括：</p><ul><li><p><code>防止编译器优化</code>： 声明变量为 volatile 后，编译器会将对该变量的访问、赋值等操作视为有可能受到外部因素影响，因此不会对这些操作进行优化，确保编译后的代码与源代码中的操作顺序一致。</p></li><li><p><code>指示变量可能被多线程或中断处理程序修改</code>： 在多线程或中断处理程序的环境中，某些变量的值可能会被其他线程或中断处理程序修改，而这些修改对于程序的正确执行具有重要影响。通过使用 volatile 关键字，可以告诉编译器这些变量的值可能会在程序执行过程中被修改，因此需要每次访问都重新从内存中读取值，而不是使用缓存中的值。</p></li></ul><p><code>volatile</code>关键字通常在以下情况下使用：</p><ol><li><p><code>硬件操作或内存映射</code>： 当变量代表硬件寄存器或内存映射的状态时，可能会被外部设备或中断处理程序修改。在这种情况下，将变量声明为 volatile 可以确保编译器不会对其进行优化，以防止意外的行为。</p></li><li><p><code>多线程环境下共享变量</code>： 在多线程程序中，共享变量可能会被多个线程同时访问和修改。如果这些变量没有使用同步机制进行保护，那么在读取和写入这些变量时可能会发生竞态条件。在这种情况下，将共享变量声明为 volatile 可以告诉编译器不要对其进行优化，以确保每次访问都是从内存中读取最新值。</p></li><li><p><code>信号处理程序中使用的全局变量</code>： 在信号处理程序中，全局变量的值可能会在程序的正常执行流程之外被修改。为了确保信号处理程序能够正确地读取和修改这些变量，通常会将它们声明为 volatile。</p></li></ol><h3 id="1-51-如果有一个空类，它会默认添加哪些函数？"><a href="#1-51-如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="1.51 如果有一个空类，它会默认添加哪些函数？"></a>1.51 如果有一个空类，它会默认添加哪些函数？</h3><pre><code class="C++">MyClass(); // 缺省构造函数MyClass( const MyClass&amp; ); // 拷贝构造函数~MyClass(); // 析构函数MyClass&amp; operator=( const MyClass&amp; ); // 赋值运算符</code></pre><h3 id="1-52-说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#1-52-说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="1.52 说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>1.52 说一说strcpy、sprintf与memcpy这三个函数的不同之处</h3><ol><li><strong>操作对象不同</strong></li></ol><ul><li><p>strcpy的两个操作对象均为字符串</p></li><li><p>sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串</p></li><li><p>memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</p></li></ul><ol start="2"><li><p><strong>执行效率不同</strong><br>memcpy最高，strcpy次之，sprintf的效率最低。</p></li><li><p><strong>实现功能不同</strong></p></li></ol><ul><li><p>strcpy主要实现字符串变量间的拷贝</p></li><li><p>sprintf主要实现其他数据类型格式到字符串的转化</p></li><li><p>memcpy主要是内存块间的拷贝</p></li></ul><h3 id="1-53-如何阻止一个类被实例化？有哪些方法"><a href="#1-53-如何阻止一个类被实例化？有哪些方法" class="headerlink" title="1.53 如何阻止一个类被实例化？有哪些方法"></a>1.53 如何阻止一个类被实例化？有哪些方法</h3><ol><li><code>将构造函数声明为私有（private）</code>： 将类的构造函数声明为私有，这样外部代码就无法直接调用该构造函数实例化对象。但是需要注意的是，类的静态成员函数仍然可以访问私有构造函数，因此可以在类的静态成员函数中实现对象的创建，从而控制对象的实例化。</li><li><code>删除构造函数的定义</code>： C++11 引入了删除函数的特性，可以通过将构造函数的定义删除来阻止对象的实例化。删除构造函数的定义后，任何尝试调用该构造函数的操作都会导致编译错误。</li><li><code>将构造函数声明为纯虚函数</code>： 将构造函数声明为纯虚函数，这样派生类必须实现自己的构造函数，而基类则无法被实例化。</li></ol><h3 id="1-54-strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#1-54-strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="1.54 strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>1.54 strcpy函数和strncpy函数的区别？哪个函数更安全？</h3><ul><li><code>strcpy</code>：<ul><li>函数原型：char *strcpy(char *dest, const char *src);  </li><li>功能：将源字符串（以空字符结尾）拷贝到目标字符串中，包括空字符。</li><li>安全性：strcpy 不检查目标字符串的长度，如果源字符串比目标字符串长，可能会发生缓冲区溢出，导致未定义的行为。</li></ul></li><li><code>strncpy</code>：<ul><li>函数原型：char *strncpy(char *dest, const char *src, size_t n);</li><li>功能：将源字符串的前 n 个字符拷贝到目标字符串中，如果源字符串长度小于 n，则在目标字符串中用空字符填充剩余部分。</li><li>安全性：相比于 strcpy，strncpy 更安全，因为它可以指定拷贝的最大长度，避免了缓冲区溢出的风险。但需要注意，如果源字符串的长度大于 n，则目标字符串不会以空字符结尾，因此可能需要<code>手动添加空字符</code>。</li></ul></li></ul><p>因此，从安全性的角度来看，strncpy 更安全一些，但需要确保目标字符串足够大以容纳指定长度的内容。另外，使用 strncpy 时应格外小心，确保目标字符串始终以空字符结尾，以避免字符串操作中出现意外行为。</p><h3 id="1-55-写一个比较大小的模板函数"><a href="#1-55-写一个比较大小的模板函数" class="headerlink" title="1.55 写一个比较大小的模板函数"></a>1.55 写一个比较大小的模板函数</h3><pre><code class="C++">template &lt;typename T&gt;T max(T a, T b)&#123;  return a &gt; b ? a : b;&#125;</code></pre><h3 id="1-56-成员函数里memset-this-0-sizeof-this-会发生什么"><a href="#1-56-成员函数里memset-this-0-sizeof-this-会发生什么" class="headerlink" title="1.56 成员函数里memset(this,0,sizeof(*this))会发生什么"></a>1.56 成员函数里memset(this,0,sizeof(*this))会发生什么</h3><p>在成员函数中调用<code>memset(this, 0, sizeof(*this))</code>将会把当前对象所占内存的前<code>sizeof(*this)</code>字节全部设置为零。这样做会将对象的所有成员变量都设置为零值，但这种做法可能会导致一些问题，特别是对于<code>含有虚函数或虚继承的类</code>。</p><p>具体来说，<code>memset</code>函数是用来将一段内存块设置为指定的值的，但它只是简单地按字节设置，对于非 POD（Plain Old Data）类型的对象，这种简单的内存设置可能会导致对象中的某些数据结构被破坏，从而导致程序出错。</p><p>对于含有虚函数的类，调用<code>memset</code>可能会破坏虚<code>函数表（vtable）指针</code>，导致虚函数调用出错。对于含有虚继承的类，调用<code>memset</code>会破坏<code>虚基类指针（vptr）</code>，同样会导致程序出错。</p><p>因此，一般情况下不建议在成员函数中直接使用 memset 来清零对象的内存，而是应该使用更安全的方式来初始化对象的成员变量。</p><h3 id="1-57-C-从代码到可执行程序经历了什么"><a href="#1-57-C-从代码到可执行程序经历了什么" class="headerlink" title="1.57 C++从代码到可执行程序经历了什么"></a>1.57 C++从代码到可执行程序经历了什么</h3><ol><li><p><strong>编写代码</strong>：首先，程序员编写C++源代码，这些代码通常包含在一个或多个源文件中。</p></li><li><p><strong>预处理</strong>：在编译之前，源代码经过预处理器处理。预处理器执行诸如<code>宏替换</code>、<code>条件编译</code>等操作，生成经过预处理的源代码文件。</p></li><li><p><strong>编译</strong>：编译器将预处理后的源代码转换为汇编代码。这个阶段的任务是将高级语言代码转换为机器语言代码，生成相应的目标文件。</p></li><li><p><strong>汇编</strong>：汇编器将汇编代码转换为机器可执行的二进制代码。它将每条汇编指令翻译成机器指令，并生成目标文件。</p></li><li><p><strong>链接</strong>：链接器将生成的目标文件与所需的库文件链接在一起，创建一个完整的可执行程序。它解析程序中使用的符号引用，将它们与符号定义关联起来，并解决外部符号的引用。最终，链接器产生一个可执行文件，其中包含程序的所有指令和数据。</p></li><li><p><strong>优化</strong>：在编译和链接过程中，还可以应用各种优化技术来提高程序的性能和效率。这些优化包括但不限于代码优化、内联函数、循环优化等。</p></li><li><p><strong>生成可执行文件</strong>：经过链接和优化后，最终生成可执行文件，即可以在特定平台上运行的二进制文件。这个可执行文件包含了程序的所有代码和数据，可以直接在计算机上执行。</p></li><li><p><strong>运行程序</strong>：最终，用户可以运行生成的可执行程序，执行程序中定义的操作和功能。</p></li></ol><p>这些步骤通常由编译器和链接器自动完成，用户只需要编写和调试源代码即可。</p><h3 id="1-58-友元函数和友元类"><a href="#1-58-友元函数和友元类" class="headerlink" title="1.58 友元函数和友元类"></a>1.58 友元函数和友元类</h3><p>在C++中，友元函数和友元类是用来提供对类的私有成员的访问权限的机制，它们可以访问类的私有成员，即使这些成员在类的定义中被声明为私有的也可以。它们的区别在于：</p><ul><li>友元函数：友元函数是在类的外部声明的普通函数，可以访问类的所有成员。要声明一个函数为类的友元函数，需要在类的定义中使用 friend 关键字来声明。友元函数并不属于类的成员函数，它们可以通过对象或类名来调用。<pre><code class="cpp">class MyClass &#123;    friend void friendFunction();private:    int privateMember;&#125;;void friendFunction() &#123;    MyClass obj;    obj.privateMember = 10; // 可以访问私有成员&#125;</code></pre></li><li>友元类：友元类是指一个类可以访问另一个类的私有成员。同样地，在类的定义中使用 friend 关键字来声明一个类为友元类。友元类可以访问被声明为友元类的类的所有成员，包括私有成员和保护成员。<pre><code class="cpp">class MyClass &#123;    friend class FriendClass;private:    int privateMember;&#125;;class FriendClass &#123;public:    void accessPrivateMember(MyClass&amp; obj) &#123;        obj.privateMember = 10; // 可以访问私有成员    &#125;&#125;;</code></pre></li></ul><p>友元函数和友元类的使用可以提供更灵活的访问控制，但同时也会破坏了类的封装性，因此应该谨慎使用。</p><h3 id="1-59-自旋锁"><a href="#1-59-自旋锁" class="headerlink" title="1.59 自旋锁"></a>1.59 自旋锁</h3><p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p><h3 id="1-60-为什么C-没有垃圾回收机制？这点跟Java不太一样。"><a href="#1-60-为什么C-没有垃圾回收机制？这点跟Java不太一样。" class="headerlink" title="1.60 为什么C++没有垃圾回收机制？这点跟Java不太一样。"></a>1.60 为什么C++没有垃圾回收机制？这点跟Java不太一样。</h3><ul><li>实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。</li><li>垃圾回收会使得C++不适合进行很多底层的操作。</li></ul><h2 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h2><h3 id="2-1-简要说明C-的内存分区"><a href="#2-1-简要说明C-的内存分区" class="headerlink" title="2.1 简要说明C++的内存分区"></a>2.1 简要说明C++的内存分区</h3><p>C++中的内存分区，分别是堆、栈、自由存储区、全局&#x2F;静态存储区、常量存储区和代码区。  </p><ul><li><p><strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p></li><li><p><strong>堆</strong>：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete。<code>如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</code></p></li><li><p><strong>自由存储区</strong>：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，<code>自由存储区和堆比较像，但不等价</code></p></li><li><p><strong>全局&#x2F;静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，<code>在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</code></p></li><li><p><strong>常量存储区</strong>：这是一块比较特殊的存储区，这里面存放的是常量，<code>不允许修改</code></p></li><li><p><strong>代码区</strong>：存放函数体的二进制代码</p></li></ul><h3 id="2-2-什么是内存池，如何实现"><a href="#2-2-什么是内存池，如何实现" class="headerlink" title="2.2 什么是内存池，如何实现"></a>2.2 什么是内存池，如何实现</h3><p>内存池（Memory Pool） 是一种内存分配方式。通常我们习惯直接使用new、malloc 等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。</p><pre><code class="cpp">// 内存池#include &quot;list&quot;class MemoryPool&#123;private:    std::list&lt;char*&gt; m_blocks;    unsigned int m_bloackNum;public:    MemoryPool(size_t size, unsigned int num)&#123;        m_bloackNum = num;        for(unsigned int i = 0; i &lt; num; ++i)&#123;            m_blocks.push_back(new char[size]);        &#125;    &#125;    ~MemoryPool()&#123;        for(auto b : m_blocks)&#123;            delete[] b;            b = nullptr;        &#125;    &#125;    char* allocate()&#123;        if(m_blocks.empty())&#123;            throw std::bad_alloc();        &#125;        char* b = m_blocks.front();        m_blocks.pop_front();        return b;    &#125;    void deallocate(void* block)&#123;        m_blocks.push_back(static_cast&lt;char*&gt;(block));    &#125;&#125;;</code></pre><h3 id="2-3-几个this指针的易混问题"><a href="#2-3-几个this指针的易混问题" class="headerlink" title="2.3 几个this指针的易混问题"></a>2.3 几个this指针的易混问题</h3><ul><li><p><strong>this指针是什么时候创建的？</strong><br>this在成员函数的开始执行前构造，在成员的执行结束后清除。</p></li><li><p><strong>this指针存放在何处？堆、栈、全局变量，还是其他？</strong><br>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。</p></li><li><p><strong>每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</strong><br>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。</p></li></ul><h3 id="2-4-内存泄漏的后果？如何监测？解决方法？"><a href="#2-4-内存泄漏的后果？如何监测？解决方法？" class="headerlink" title="2.4 内存泄漏的后果？如何监测？解决方法？"></a>2.4 内存泄漏的后果？如何监测？解决方法？</h3><ul><li>后果<br>只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种症状：性能下降到内存逐渐用完，导致另一个程序失败；  </li><li>如何监测<br>使用专门的内存泄漏检测工具，例如Valgrind、AddressSanitizer(ASan)、LeakSanitizer等，这些工具能够帮助检测程序中的内存泄漏问题，并给出详细的报告和堆栈信息。<ul><li>使用 -g 编译选项开启符号信息生成，然后使用Valgrind执行测试<br><img src="/2023/01/23/C++%E5%85%AB%E8%82%A1%E6%96%87/debug001.png"></li><li>编译时使用<code>-fsanitize=address</code>选项来开启<code>AddressSanitizer</code><pre><code class="bash">g++ -fsanitize=address -g your_code.cpp -o your_executable</code></pre>或使用<code>-fsanitize=leak</code>选项来开启<code>LeakSanitizer</code><br><img src="/2023/01/23/C++%E5%85%AB%E8%82%A1%E6%96%87/debug002.png"><br><img src="/2023/01/23/C++%E5%85%AB%E8%82%A1%E6%96%87/debug003.png"></li></ul></li><li>解决方法<br>智能指针。代码审查。</li></ul><h4 id="2-4-1-使用-g-选项编译程序有什么作用"><a href="#2-4-1-使用-g-选项编译程序有什么作用" class="headerlink" title="2.4.1.使用 -g 选项编译程序有什么作用"></a>2.4.1.使用 -g 选项编译程序有什么作用</h4><p>使用 -g 选项编译程序的作用是生成调试信息（debug information），这些调试信息包含了源代码和目标代码之间的映射关系，以及变量名、函数名等符号信息。具体来说，-g 选项会将调试信息嵌入到可执行文件中，以便在程序执行时能够进行调试和分析。</p><p>主要作用包括：</p><ol><li><p>源代码和目标代码映射关系：调试信息可以帮助调试器将源代码的行号和目标代码的地址进行映射，从而在调试过程中能够准确地定位到源代码的位置。这样可以更方便地进行断点设置、单步调试等操作。</p></li><li><p>变量名、函数名等符号信息：调试信息中包含了变量名、函数名等符号信息，使得调试器能够识别和显示这些符号，从而更容易地理解程序的结构和逻辑。</p></li><li><p>错误信息定位：当程序发生错误时，调试信息可以帮助调试器准确地定位到错误的源代码位置，从而更容易地进行错误排查和修复。</p></li><li><p>内存检测工具支持：一些内存检测工具（如 Valgrind 的 Memcheck）需要在调试信息的基础上进行分析和检测，因此编译时需要使用 -g 选项生成调试信息。</p></li></ol><h3 id="2-5-在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#2-5-在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="2.5 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>2.5 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h3><p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</p><blockquote><p><strong>为什么是不可预期的问题？</strong><br>delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p></blockquote><h3 id="2-6-如果在类的析构函数中调用delete-this，会发生什么？"><a href="#2-6-如果在类的析构函数中调用delete-this，会发生什么？" class="headerlink" title="2.6 如果在类的析构函数中调用delete this，会发生什么？"></a>2.6 如果在类的析构函数中调用delete this，会发生什么？</h3><p>可能会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p><h3 id="2-7-请说一下以下几种情况下，下面几个类的大小各是多少？"><a href="#2-7-请说一下以下几种情况下，下面几个类的大小各是多少？" class="headerlink" title="2.7 请说一下以下几种情况下，下面几个类的大小各是多少？"></a>2.7 请说一下以下几种情况下，下面几个类的大小各是多少？</h3><pre><code class="cpp">class A &#123;&#125;;int main()&#123;  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1;  A a;   cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1;  return 0;&#125;/*空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。*/</code></pre><pre><code class="cpp">class A &#123; virtual void Fun()&#123;&#125; &#125;;int main()&#123;  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器);  A a;   cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器);  return 0;&#125;// 因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节</code></pre><pre><code class="cpp">class A &#123; static int a; &#125;;int main()&#123;  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1;  A a;   cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1;  return 0;&#125;// 静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</code></pre><pre><code class="cpp">class A &#123; int a; &#125;;int main()&#123;  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4;  A a;   cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4;  return 0;&#125;</code></pre><h3 id="2-8-类对象的大小受哪些因素影响？"><a href="#2-8-类对象的大小受哪些因素影响？" class="headerlink" title="2.8 类对象的大小受哪些因素影响？"></a>2.8 类对象的大小受哪些因素影响？</h3><ul><li><p>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</p></li><li><p>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</p></li><li><p>虚函数的话，会在类对象插入vptr指针，加上指针大小；</p></li><li><p>当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。</p></li></ul><h2 id="三、C-11新标准"><a href="#三、C-11新标准" class="headerlink" title="三、C++11新标准"></a>三、C++11新标准</h2><h3 id="3-1-C-11有哪些新特性？"><a href="#3-1-C-11有哪些新特性？" class="headerlink" title="3.1 C++ 11有哪些新特性？"></a>3.1 C++ 11有哪些新特性？</h3><ul><li>nullptr替代 NULL</li><li>引入了 auto 和 decltype 这两个关键字实现了类型推导</li><li>基于范围的 for 循环for(auto&amp; i : res){}</li><li>类和结构体的中初始化列表</li><li>Lambda 表达式（匿名函数）</li><li>std::forward_list（单向链表）</li><li>右值引用和move语义</li><li>…</li></ul><h3 id="3-2-智能指针的原理、常用的智能指针及实现"><a href="#3-2-智能指针的原理、常用的智能指针及实现" class="headerlink" title="3.2 智能指针的原理、常用的智能指针及实现"></a>3.2 智能指针的原理、常用的智能指针及实现</h3><ul><li><p><strong>原理</strong><br>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源</p></li><li><p><strong>常用的智能指针</strong>  </p><ul><li><p><strong>unique_ptr</strong><br>它是一种独占所有权的智能指针，即它不能被复制或拷贝。当unique_ptr被销毁时，它所指向的对象会被自动释放。这使得unique_ptr非常适合管理动态分配的单个对象。</p></li><li><p><strong>shared_ptr</strong><br>它是一种共享所有权的智能指针，可以被多个shared_ptr共享同一个对象。它使用引用计数来跟踪指向对象的指针数量，并在没有指针指向对象时自动释放对象。当最后一个shared_ptr销毁时，对象会被释放。</p></li><li><p><strong>weak_ptr</strong><br>它是一种弱引用的智能指针，用于解决shared_ptr的循环引用问题。weak_ptr可以从shared_ptr创建，但不会增加引用计数。因此，它不会阻止对象的销毁。通常在需要访问shared_ptr所管理的对象，但又不需要拥有所有权时使用。</p></li><li><p><strong>auto_ptr（C++11之前）</strong><br>它是早期版本的C++标准中提供的智能指针，类似于unique_ptr，但具有一些缺陷，并在C++11中被std::unique_ptr取代。auto_ptr没有明确定义的行为来处理拷贝和赋值操作，因此容易导致问题。</p></li></ul></li><li><p><strong>智能指针shared_ptr代码实现</strong></p></li></ul><pre><code class="cpp">template&lt;typename T&gt;class SharedPtr&#123;public:    SharedPtr(T* ptr = NULL):_ptr(ptr), _pcount(new int(1))    &#123;&#125;    SharedPtr(const SharedPtr&amp; s):_ptr(s._ptr), _pcount(s._pcount)&#123;        (*_pcount)++;    &#125;    SharedPtr&lt;T&gt;&amp; operator=(const SharedPtr&amp; s)&#123;        if (this != &amp;s)        &#123;            if (--(*(this-&gt;_pcount)) == 0)            &#123;                delete this-&gt;_ptr;                delete this-&gt;_pcount;            &#125;            _ptr = s._ptr;            _pcount = s._pcount;            (*_pcount)++;        &#125;        return *this;    &#125;    T&amp; operator*()    &#123;        return *(this-&gt;_ptr);    &#125;    T* operator-&gt;()    &#123;        return this-&gt;_ptr;    &#125;    ~SharedPtr()    &#123;        --(*(this-&gt;_pcount));        if (*(this-&gt;_pcount) == 0)        &#123;            delete _ptr;            _ptr = NULL;            delete _pcount;            _pcount = NULL;        &#125;    &#125;private:    T* _ptr;    int* _pcount;//指向引用计数的指针&#125;;</code></pre><h3 id="3-3-lambda函数"><a href="#3-3-lambda函数" class="headerlink" title="3.3 lambda函数"></a>3.3 lambda函数</h3><pre><code class="cpp">[capture-list] (parameter-list) -&gt; return-type &#123;    // 函数体&#125;</code></pre><ul><li>capture-list：捕获列表，用于捕获外部变量。可以是值传递方式（[var]）或引用传递方式（[&amp;var]）。还可以使用[&#x3D;]表示以值传递方式捕获所有外部变量，或使用[&amp;]表示以引用传递方式捕获所有外部变量。</li><li>parameter-list：参数列表，与普通函数的参数列表类似。</li><li>return-type：返回类型，可以省略，编译器会根据返回语句自动推断返回类型。</li><li>{}：函数体，与普通函数的函数体类似。</li></ul><pre><code class="cpp">#include &lt;iostream&gt;int main() &#123;    // Lambda表达式求两个数的和    auto sum = [](int a, int b) -&gt; int &#123;        return a + b;    &#125;;    // 调用lambda表达式    int result = sum(3, 4);    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; result &lt;&lt; std::endl;    return 0;&#125;</code></pre><h3 id="3-4-shared-ptr的循环引用问题"><a href="#3-4-shared-ptr的循环引用问题" class="headerlink" title="3.4 shared_ptr的循环引用问题"></a>3.4 shared_ptr的循环引用问题</h3><p>当两个对象相互引用并使用<code>shared_ptr</code>时，就会形成循环引用。例如，考虑一个简单的场景：</p><pre><code class="cpp">#include &lt;memory&gt;#include &lt;iostream&gt;class B; // 前置声明class A &#123;public:    std::shared_ptr&lt;B&gt; b_ptr;    A() &#123; std::cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; std::endl; &#125;    ~A() &#123; std::cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; std::endl; &#125;&#125;;class B &#123;public:    std::shared_ptr&lt;A&gt; a_ptr;    B() &#123; std::cout &lt;&lt; &quot;B constructor&quot; &lt;&lt; std::endl; &#125;    ~B() &#123; std::cout &lt;&lt; &quot;B destructor&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123;    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;();    std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;();        a-&gt;b_ptr = b;    b-&gt;a_ptr = a;    return 0;&#125;</code></pre><p>在这个例子中，类 <code>A</code> 拥有一个指向类 <code>B</code> 的 <code>shared_ptr</code>，而类 <code>B</code> 拥有一个指向类 <code>A</code> 的 <code>shared_ptr</code>。这样就形成了循环引用。</p><p>为了避免循环引用，我们可以改用 <code>weak_ptr</code> 来解决这个问题：</p><pre><code class="cpp">#include &lt;memory&gt;#include &lt;iostream&gt;class B; // 前置声明class A &#123;public:    std::shared_ptr&lt;B&gt; b_ptr;    A() &#123; std::cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; std::endl; &#125;    ~A() &#123; std::cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; std::endl; &#125;&#125;;class B &#123;public:    std::weak_ptr&lt;A&gt; a_weak_ptr;  // 使用 weak_ptr    B() &#123; std::cout &lt;&lt; &quot;B constructor&quot; &lt;&lt; std::endl; &#125;    ~B() &#123; std::cout &lt;&lt; &quot;B destructor&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123;    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;();    std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;();        a-&gt;b_ptr = b;    b-&gt;a_weak_ptr = a;  // 使用 weak_ptr    return 0;&#125;</code></pre><p>通过将类 <code>B</code> 中指向类 <code>A</code> 的指针改为 <code>weak_ptr</code>，我们成功地避免了循环引用问题。</p><h2 id="四、STL"><a href="#四、STL" class="headerlink" title="四、STL"></a>四、STL</h2><p>部分<a href="https://blog.51cto.com/u_15127564/4871878">面试题</a></p><h3 id="4-1-什么是STL"><a href="#4-1-什么是STL" class="headerlink" title="4.1 什么是STL"></a>4.1 什么是STL</h3><p>STL通常指的是“标准模板库”（Standard Template Library）。这是C++编程语言的一部分，包含一组用于常见数据结构和算法的模板库。这些模板库是泛型的，允许程序员使用单个代码库来处理各种数据类型。</p><p>广义上讲，STL分为3类：Algorithm（算法）、Container（容器）和Iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。</p><p>详细的说，STL由6部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。</p><h4 id="1-容器（Containers）"><a href="#1-容器（Containers）" class="headerlink" title="1. 容器（Containers）"></a>1. 容器（Containers）</h4><p>容器是STL中用于存储和组织数据的基础结构。它们提供了一系列操作，如插入、删除、查找、迭代等。STL中的主要容器包括：</p><ul><li><p>序列容器（Sequence Containers）：这些容器按顺序存储元素。</p><ul><li>vector: 动态数组，提供随机访问，支持快速添加和删除末尾的元素。</li><li>list: <strong>双向链表</strong>，适合在中间插入或删除元素。</li><li>deque: 双端队列，支持在头部和尾部快速添加或删除元素。</li></ul></li><li><p>关联容器（Associative Containers）：这些容器基于键来存储和检索数据。</p><ul><li>set: 集合，存储唯一元素，元素按特定顺序排列。</li><li>map: 映射，键-值对，按键排序。</li><li>multiset: 允许重复元素的集合。</li><li>multimap: 允许重复键的映射。</li></ul></li><li><p>无序关联容器（Unordered Associative Containers）：这些容器使用哈希表进行数据存储。</p><ul><li>unordered_set: 无序集合，元素顺序不固定。</li><li>unordered_map: 无序映射，键-值对，元素顺序不固定。</li><li>unordered_multiset: 无序多重集合。</li><li>unordered_multimap: 无序多重映射。</li></ul></li></ul><h4 id="2-迭代器（Iterators）"><a href="#2-迭代器（Iterators）" class="headerlink" title="2. 迭代器（Iterators）"></a>2. 迭代器（Iterators）</h4><p>迭代器是用于遍历容器中元素的对象。不同的迭代器支持不同程度的访问能力。主要的迭代器类型包括：</p><ul><li><p>正向迭代器（Forward Iterator）：可以从头到尾顺序遍历。</p></li><li><p>双向迭代器（Bidirectional Iterator）：支持向前和向后遍历。</p></li><li><p>随机访问迭代器（Random Access Iterator）：支持随机访问元素，如vector中的迭代器。</p></li><li><p>输入迭代器（Input Iterator）：只能向前读取数据。</p></li><li><p>输出迭代器（Output Iterator）：只能向前写入数据。</p></li></ul><p>迭代器的设计与指针类似，因此可以使用类似于指针的语法进行迭代。</p><blockquote><p>PS: 迭代器类型不是由程序员显式选择，而是由容器决定的 直接使用就好：auto it &#x3D; xxx.begin();</p></blockquote><h4 id="3-算法（Algorithms）"><a href="#3-算法（Algorithms）" class="headerlink" title="3. 算法（Algorithms）"></a>3. 算法（Algorithms）</h4><p>STL提供了大量的算法，用于操作容器中的数据。这些算法可以应用于不同的容器类型，因为它们是泛型的。常见的STL算法包括：</p><ul><li>排序算法：sort, stable_sort(稳定排序), partial_sort(部分排序), nth_element(将最好的n个元素放在widgets的前部，但并不关心它们的具体排列顺序)等。</li><li>查找算法：find, binary_search, count, equal_range等。</li><li>修改算法：copy, fill, generate, remove, replace等。</li><li>排列算法：next_permutation, prev_permutation等。</li><li>其他算法：accumulate, transform, rotate, reverse, shuffle等。</li></ul><p>这些算法以泛型方式实现，可以与迭代器结合使用。</p><h4 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h4><p>行为类函数，可作为算法的某种策略，从实现角度看，仿函数是一种重载了operator()的class或class template。一般函数指针可视为狭义的仿函数。</p><ul><li>与普通函数：仿函数与普通函数不同，它们可以保存状态，而普通函数通常是无状态的。</li><li>与lambda表达式：仿函数与lambda表达式相似，但lambda表达式通常更简洁，适用于简短的函数体，而仿函数适合更复杂的操作和持有状态。</li></ul><p>和golang的闭包有相似之处。</p><h4 id="容器配接器"><a href="#容器配接器" class="headerlink" title="容器配接器"></a>容器配接器</h4><p>一种用来修饰容器或者仿函数或迭代器接口的东西。比如<code>queue</code>和<code>stack</code>，看着像容器，其实就是<code>deque</code>包了一层皮。</p><h4 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h4><p>负责空间配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放额class template。用户可以自定义分配策略。</p><h3 id="4-2-使用智能指针管理内存资源，RAII是怎么回事？"><a href="#4-2-使用智能指针管理内存资源，RAII是怎么回事？" class="headerlink" title="4.2 使用智能指针管理内存资源，RAII是怎么回事？"></a>4.2 使用智能指针管理内存资源，RAII是怎么回事？</h3><p>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。<br>因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</p><p>智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。<br>毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</p><h3 id="4-3-迭代器：-it、it-哪个好，为什么"><a href="#4-3-迭代器：-it、it-哪个好，为什么" class="headerlink" title="4.3 迭代器：++it、it++哪个好，为什么"></a>4.3 迭代器：++it、it++哪个好，为什么</h3><p>前置返回一个引用，后置返回一个对象</p><ul><li>++i实现代码为：</li></ul><pre><code class="cpp">int&amp; operator++()&#123;  *this += 1;  return *this;&#125; </code></pre><p>前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低</p><ul><li>i++实现代码为：</li></ul><pre><code class="cpp">int operator++(int)                 &#123;  int temp = *this;                     ++*this;                         return temp;                  &#125; </code></pre><p>对于大多数现代编译器来说，在合适的情况下，它们可能会对代码进行优化，包括将后置自增 it++ 转换为前置自增 ++it。但是，这种优化是否发生取决于编译器的实现以及优化级别。</p><h3 id="4-4-右值"><a href="#4-4-右值" class="headerlink" title="4.4 右值"></a>4.4 右值</h3><p>C++11引入了右值引用，用来支持移动语义和完美转发。</p><ol><li>移动语义：传统的复制操作需要额外的时间和空间，而有了移动语义后，可以直接将资源（如内存）从一个对象转移到另一个对象，而不必创建并删除临时对象。这对于大对象或者拥有独占所有权资源的对象特别有用。例如，unique_ptr和std::vector等STL容器就利用了移动语义实现了高效的操作。</li><li>完美转发：在函数模板中，我们想把参数原封不动地传递给其他函数。由于传参可能存在值传递、左值引用、常量左值引用、右值引用等情况，为了保证参数的属性和类型不发生变化，我们需要使用std::forward实现完美转发。</li></ol><p>右值引用主要用于两种场景：一是对象的移动（Move），二是万能引用（Forwarding Reference）。对于第一种情况，它是为了解决对象的复制效率问题；对于第二种情况，则是为了实现参数的完美传递，避免不必要的拷贝。</p><h3 id="4-5-简单说一下traits技法"><a href="#4-5-简单说一下traits技法" class="headerlink" title="4.5 简单说一下traits技法"></a>4.5 简单说一下traits技法</h3><p>Traits 技法是一种在编程中使用的模式，用于实现泛型编程和类型参数化。它的基本思想是将类型的某些特性（或特征）提取出来，并将其定义为独立的类或结构体，然后通过模板或泛型编程技术将这些特性与具体的类型进行关联。</p><p>Traits 技法的主要目的是将类型的行为和属性与类型本身解耦，使得代码更具灵活性和可重用性。通过定义一组通用的接口或函数，可以将这些接口或函数应用于不同的类型，而无需对每种类型都进行单独的实现。</p><p>在 C++ 中，Traits 技法通常通过模板编程来实现。可以定义一组模板类或结构体，用于描述类型的特性，然后在模板函数或模板类中使用这些特性。通过特化或偏特化，可以针对不同类型提供不同的实现，从而实现更高级的泛型编程。</p><p>例如，在 C++ 中，STL 中的迭代器就是一种典型的 Traits 技法的应用。迭代器通过一组接口描述了迭代器的特性，然后通过模板函数和模板类来处理不同类型的迭代器，而无需知道具体的迭代器类型。这种设计使得算法可以与任何支持相应接口的迭代器一起使用，从而提高了代码的灵活性和可重用性。</p><h3 id="4-6-STL的两级空间配置器"><a href="#4-6-STL的两级空间配置器" class="headerlink" title="4.6 STL的两级空间配置器"></a>4.6 STL的两级空间配置器</h3><p>STL（Standard Template Library）的空间配置器是用于在堆上分配内存的组件，它们被用来支持STL容器（如vector、list、map等）的内存管理。STL中的空间配置器通常包括单级空间配置器和双级空间配置器。</p><p>双级空间配置器由两部分组成：</p><ol><li><p>第一级空间配置器（第一级分配器）：使用malloc和free等全局内存分配函数来分配内存。这一级的分配器适用于大块内存的分配，它通过调用全局的malloc和free函数来分配和释放内存，通常是通过模板参数指定的分配策略来实现。</p></li><li><p>第二级空间配置器（第二级分配器）：由于第一级空间配置器在处理小块内存时效率较低，因此第二级空间配置器通常会对小块内存进行优化，它通常使用内存池等技术来管理和分配小块内存，以提高内存分配和释放的效率。</p></li></ol><p>双级空间配置器的设计可以在大块内存和小块内存之间取得平衡，从而在不同大小的内存分配场景中提供更好的性能和效率。这种设计使得STL容器在不同的内存分配场景下都能够有效地工作，并且具有较好的性能表现。</p><h3 id="4-7-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"><a href="#4-7-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素" class="headerlink" title="4.7 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"></a>4.7 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素</h3><ul><li><p><strong>vector数据结构</strong>  </p><ul><li><p>vector和<code>数组</code>类似，拥有一段连续的内存空间，并且起始地址不变。因此能高效的进行随机存取，时间复杂度为o(1);但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。</p></li><li><p>当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。连续存储结构：vector是可以实现动态增长的对象数组，支持对数组高效率的访问和在数组尾端的删除和插入操作，在中间和头部删除和插入相对不易，需要挪动大量的数据。</p></li><li><p>它与数组最大的区别就是vector不需程序员自己去考虑容量问题，库里面本身已经实现了容量的动态增长，而数组需要程序员手动写入扩容函数进形扩容。</p></li><li><p>找某vector或者list的倒数第二个元素使用迭代器就行。</p></li></ul></li><li><p><strong>list数据结构</strong>  </p><ul><li>list是由<code>双向链表</code>实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);但由于链表的特点，能高效地进行插入和删除。非连续存储结构：list是一个双链表结构，支持对链表的双向遍历。每个节点包括三个信息：元素本身，指向前一个元素的节点（prev）和指向下一个元素的节点（next）。因此list可以高效率的对数据元素任意位置进行访问和插入删除等操作。由于涉及对额外指针的维护，所以开销比较大。<br>区别：</li></ul></li></ul><p>vector的随机访问效率高，但在插入和删除时（不包括尾部）需要挪动数据，不易操作。<br>list的访问要遍历整个链表，它的随机访问效率低。但对数据的插入和删除操作等都比较方便，改变指针的指向即可。</p><p>从遍历上来说，list是单向的，vector是双向的。<br>vector中的迭代器在使用后就失效了，而list的迭代器在使用之后还可以继续使用。<br>int mySize &#x3D; vec.size();vec.at(mySize -2);</p><p>list不提供随机访问，所以不能用下标直接访问到某个位置的元素，要访问list里的元素只能遍历，不过你要是只需要访问list的最后N个元素的话，可以用<code>反向迭代器</code>来遍历</p><h3 id="4-8-reserve与resize"><a href="#4-8-reserve与resize" class="headerlink" title="4.8 reserve与resize"></a>4.8 reserve与resize</h3><p>在 C++ 中，reserve() 和 resize() 是与标准库中的容器（例如 vector、list、deque 等）相关的两个重要函数，它们的作用如下：</p><ul><li><p><strong>reserve():</strong><br>这个函数用于预留容器的存储空间，但不改变容器的大小。预留的存储空间可以用来避免容器在添加新元素时频繁地重新分配内存，从而提高性能。reserve() 函数的参数是要预留的元素个数。如果当前容器的容量小于指定的元素个数，reserve() 函数会分配额外的内存空间以容纳指定数量的元素。</p></li><li><p><strong>resize():</strong><br>这个函数用于更改容器中元素的数量。当调用 resize() 时，如果指定的大小比当前大小小，则容器中的元素数量会减少到指定大小；如果指定的大小比当前大小大，则容器会扩展以容纳额外的元素。如果容器扩展，新添加的元素将以容器元素的默认值进行初始化。</p></li></ul><blockquote><p>在调用 reserve() 函数之后，如果你直接访问预留的空间，将会导致未定义行为，因为这些空间并没有被初始化为有效的元素。</p></blockquote><h3 id="4-9-STL迭代器如何实现"><a href="#4-9-STL迭代器如何实现" class="headerlink" title="4.9 STL迭代器如何实现"></a>4.9 STL迭代器如何实现</h3><ol><li><p>迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。</p></li><li><p>迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与-&gt;运算符，以及++、–等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。</p></li><li><p>最常用的迭代器的相应型别有五种：value type、difference type、pointer、reference、iterator catagoly;</p></li></ol><h3 id="4-10-map插入方式有哪几种？"><a href="#4-10-map插入方式有哪几种？" class="headerlink" title="4.10 map插入方式有哪几种？"></a>4.10 map插入方式有哪几种？</h3><ol><li>用insert函数插入pair数据：</li></ol><pre><code class="cpp">mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;)); </code></pre><ol start="2"><li>用insert函数插入value_type数据：</li></ol><pre><code class="cpp">mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));</code></pre><ol start="3"><li>在insert函数中使用make_pair()函数：</li></ol><pre><code class="cpp">mapStudent.insert(make_pair(1, &quot;student_one&quot;)); </code></pre><ol start="4"><li>用数组方式插入数据：</li></ol><pre><code class="cpp">mapStudent[1] = &quot;student_one&quot;; </code></pre><h3 id="4-20-map中-与find的区别？"><a href="#4-20-map中-与find的区别？" class="headerlink" title="4.20 map中[]与find的区别？"></a>4.20 map中[]与find的区别？</h3><ul><li><p>map的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。</p></li><li><p>map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。</p></li></ul><h3 id="4-21-STL中list与deque之间的区别"><a href="#4-21-STL中list与deque之间的区别" class="headerlink" title="4.21 STL中list与deque之间的区别"></a>4.21 STL中list与deque之间的区别</h3><p>STL（标准模板库）中的list（双向链表）和deque（双端队列）是两种不同的容器，它们有以下区别：</p><ul><li><p>底层数据结构：</p><ul><li>list：<br>采用<strong>双向链表</strong>作为底层数据结构。每个节点包含数据以及指向前驱节点和后继节点的指针。</li><li>deque：<br>采用分段数组（双端队列）作为底层数据结构。它<strong>由多个较小的数组块组成</strong>，每个数组块都包含一定数量的元素，并通过指针连接起来，形成一个逻辑上的双端队列。</li></ul></li><li><p>访问元素的效率：</p><ul><li>list：<br>由于采用链表结构，list在任意位置插入或删除元素的效率都很高，为O(1)。但是，随机访问元素的效率较低，为O(n)，因为需要遍历链表找到指定位置的元素。</li><li>deque：<br>由于采用分段数组结构，deque支持高效的随机访问，其时间复杂度为O(1)。同时，deque还支持在两端进行快速插入和删除操作，时间复杂度也为O(1)。</li></ul></li><li><p>内存分配方式：</p><ul><li>list：<br>由于采用链表结构，每次插入或删除元素时都需要动态分配内存，因此在频繁插入或删除大量元素时，可能会产生较多的内存分配和释放操作，导致性能下降。</li><li>deque：<br>由于采用分段数组结构，内存是分块预先分配的，因此在插入或删除元素时不需要频繁进行内存分配和释放操作，性能相对较好。</li></ul></li><li><p>空间占用：</p><ul><li>list：<br>由于每个节点都需要额外的指针来指向前驱节点和后继节点，因此相比于deque，list的空间占用通常更大。</li><li>deque：<br>由于采用分段数组结构，每个数组块的大小是固定的，因此deque的空间占用更为灵活，不会产生额外的指针开销。</li></ul></li></ul><p>根据以上区别，选择使用list还是deque取决于你的具体需求。如果需要频繁进行插入和删除操作，且不关心随机访问的效率，可以选择list；如果需要支持高效的随机访问，并且在两端进行快速插入和删除操作，可以选择deque。</p><h3 id="4-22-STL中的allocator、deallocator"><a href="#4-22-STL中的allocator、deallocator" class="headerlink" title="4.22 STL中的allocator、deallocator"></a>4.22 STL中的allocator、deallocator</h3><p>第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器；</p><p>第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块；</p><p>空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间；</p><p>空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存。</p><h3 id="4-23-常见容器性质总结？"><a href="#4-23-常见容器性质总结？" class="headerlink" title="4.23 常见容器性质总结？"></a>4.23 常见容器性质总结？</h3><p>1.vector 底层数据结构为数组 ，支持快速随机访问</p><p>2.list 底层数据结构为双向链表，支持快速增删</p><p>3.deque 底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问</p><p>deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:</p><p>[堆1] –&gt; [堆2] –&gt;[堆3] –&gt; …</p><p>每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.</p><p>4.stack 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</p><p>5.queue 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）</p><p>6.priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</p><p>7.set 底层数据结构为红黑树，有序，不重复</p><p>8.multiset 底层数据结构为红黑树，有序，可重复</p><p>9.map 底层数据结构为红黑树，有序，不重复</p><p>10.multimap 底层数据结构为红黑树，有序，可重复</p><p>11.unordered_set 底层数据结构为hash表，无序，不重复</p><p>12.unordered_multiset 底层数据结构为hash表，无序，可重复</p><p>13.unordered_map 底层数据结构为hash表，无序，不重复</p><p>14.unordered_multimap 底层数据结构为hash表，无序，可重复</p><h3 id="4-24-说一下STL每种容器对应的迭代器"><a href="#4-24-说一下STL每种容器对应的迭代器" class="headerlink" title="4.24 说一下STL每种容器对应的迭代器"></a>4.24 说一下STL每种容器对应的迭代器</h3><p>| 容器    |迭代器 |<br>| —     |—   |<br>| vector、deque  | 随机访问迭代器 |<br>| stack、queue、priority_queue  | 无 |<br>| list、(multi)set&#x2F;map  | 双向迭代器 |<br>| unordered_(multi)set&#x2F;map、forward_list  | 前向迭代器 |</p><h3 id="4-25-STL中迭代器失效的情况有哪些？"><a href="#4-25-STL中迭代器失效的情况有哪些？" class="headerlink" title="4.25 STL中迭代器失效的情况有哪些？"></a>4.25 STL中迭代器失效的情况有哪些？</h3><p>以vector为例：</p><p>插入元素：</p><ol><li><p>尾后插入：size &lt; capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size &#x3D;&#x3D; capacity时，所有迭代器均失效（需要重新分配空间）。</p></li><li><p>中间插入：中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size &#x3D;&#x3D; capacity时，所有迭代器均失效。</p></li></ol><p>删除元素：</p><ol><li><p>尾后删除：只有尾迭代失效。</p></li><li><p>中间删除：删除位置之后所有迭代失效。</p></li></ol><p>deque 和 vector 的情况类似,</p><p>而list双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器;</p><p>map&#x2F;set等关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器 mmp.erase(iter++);</p><p>unordered_(hash) 迭代器意义不大, rehash之后, 迭代器应该也是全部失效.</p><h3 id="4-26-hashtable中解决冲突有哪些方法？"><a href="#4-26-hashtable中解决冲突有哪些方法？" class="headerlink" title="4.26 hashtable中解决冲突有哪些方法？"></a>4.26 hashtable中解决冲突有哪些方法？</h3><p><strong>记住前三个：</strong></p><ul><li><p>线性探测<br>使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位</p></li><li><p>开链<br>每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中</p></li><li><p>再散列<br>发生冲突时使用另一种hash函数再计算一个地址，直到不冲突</p></li><li><p>二次探测<br>使用hash函数计算出的位置如果已经有元素占用了，按照$1^2$、$2^2$、$3^2$…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测</p></li><li><p>公共溢出区<br>一旦hash函数计算的结果相同，就放入公共溢出区</p></li></ul><h2 id="五、其余问题"><a href="#五、其余问题" class="headerlink" title="五、其余问题"></a>五、其余问题</h2><h3 id="5-1-C-多态"><a href="#5-1-C-多态" class="headerlink" title="5.1 C++多态"></a>5.1 C++多态</h3><p>C++中，多态性主要通过两种方式实现：编译时多态（静态多态）和运行时多态（动态多态）。这两种多态的机制、特点和用途有所不同。</p><ul><li>编译时多态（静态多态）:<br>编译时多态是在程序编译阶段实现的多态性。主要通过函数重载、运算符重载和模板来实现。</li></ul><p>函数重载: 同一个作用域内存在多个同名函数，但它们的参数类型或数量不同。根据调用时实际传递的参数类型和数量，编译器决定调用哪个函数。<br>运算符重载: 允许定义或重新定义大部分C++内置的运算符，使得它们可以根据操作数的类型执行不同的操作。<br>编译时多态的决策是在编译时做出的，因此它不支持在运行时根据对象的实际类型来选择相应的成员函数。</p><ul><li>运行时多态（动态多态）: 运行时多态是在程序运行阶段实现的多态性。它主要通过虚函数和继承来实现。</li></ul><p>虚函数: 通过在基类中声明虚函数，允许派生类中重写该函数。当通过基类的指针或引用调用虚函数时，实际执行的是与指针或引用所指对象的实际类型相对应的函数版本。<br>抽象类和纯虚函数: 抽象类至少包含一个纯虚函数。纯虚函数在基类中没有实现，派生类必须重写这个函数。抽象类不能被实例化。</p><h3 id="5-2-什么时候的析构函数必须写成虚函数"><a href="#5-2-什么时候的析构函数必须写成虚函数" class="headerlink" title="5.2 什么时候的析构函数必须写成虚函数"></a>5.2 什么时候的析构函数必须写成虚函数</h3><p>一般情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。这样做是为了当<code>用一个基类的指针删除一个派生类的对象时</code>，派生类的析构函数会被调用。 </p><p>当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有<code>当一个类被用来作为基类的时候</code>，才把析构函数写成虚函数。</p><h3 id="5-3-构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"><a href="#5-3-构造函数能否声明为虚函数或者纯虚函数，析构函数呢？" class="headerlink" title="5.3 构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"></a>5.3 构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</h3><ul><li>析构函数：  <ul><li>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。<br>只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</li><li>析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。</li></ul></li><li>构造函数：  <ul><li>根据《effective C++》的条款09：绝不在构造和析构过程中调用虚函数可知，在构造函数中虽然可以调用虚函数，但是强烈建议不要这样做。因为基类的构造的过程中，虚函数不能算作是虚函数。若构造函数中调用虚函数，可能会导致不确定行为的发生.</li><li>虚函数对应一个vtable(虚函数表)，类中存储一个vptr指向这个vtable。如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数。</li></ul></li></ul><h3 id="5-4-目标文件存储结构"><a href="#5-4-目标文件存储结构" class="headerlink" title="5.4 目标文件存储结构"></a>5.4 目标文件存储结构</h3><table><thead><tr><th>段</th><th>功能</th></tr></thead><tbody><tr><td>File Header</td><td>文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）</td></tr><tr><td>.text section</td><td>代码段，执行语句编译成的机器代码</td></tr><tr><td>.data section</td><td>数据段，已初始化的全局变量和局部静态变量</td></tr><tr><td>.bss section</td><td>BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）</td></tr><tr><td>.rodata section</td><td>只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量</td></tr><tr><td>.comment section</td><td>注释信息段，存放编译器版本信息</td></tr><tr><td>.note.GNU-stack section</td><td>堆栈提示段</td></tr></tbody></table><blockquote><p>其他段略</p></blockquote><h3 id="5-5-基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#5-5-基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="5.5 基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>5.5 基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h3><ul><li>C++中<code>虚函数表</code>位于<code>只读数据段（.rodata）</code>，也就是C++内存模型中的<code>常量区</code></li><li>而<code>虚函数</code>则位于<code>代码段（.text）</code>，也就是C++内存模型中的<code>代码区</code>。</li><li>在构造函数执行时会对虚表指针进行初始化，并且存在对象<code>内存布局的最前面</code>。</li></ul><h3 id="5-6-模板函数和模板类的特例化"><a href="#5-6-模板函数和模板类的特例化" class="headerlink" title="5.6 模板函数和模板类的特例化"></a>5.6 模板函数和模板类的特例化</h3><ul><li><p>引入原因：<br>编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</p></li><li><p>定义：<br>对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上</p></li></ul><p>（1）模板函数特例化</p><p>必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对&lt;&gt;，表明将原模板的所有模板参数提供实参，举例如下：</p><pre><code class="cpp">template&lt;typename T&gt; //模板函数int compare(const T &amp;v1,const T &amp;v2)&#123;    if(v1 &gt; v2) return -1;    if(v2 &gt; v1) return 1;    return 0;&#125;//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个Ttemplate&lt;&gt; int compare(const char* const &amp;v1,const char* const &amp;v2)&#123;    return strcmp(p1,p2);&#125;</code></pre><ul><li><p>本质<br>特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用特例化版本（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。</p></li><li><p>注意<br>模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</p></li></ul><p>（2）类模板特例化</p><p>原理类似函数模板，<strong>不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。</strong>对类进行特例化时，仍然用template&lt;&gt;表示是一个特例化版本，例如：</p><pre><code class="cpp">template&lt;&gt;class hash&lt;sales_data&gt;&#123;    size_t operator()(sales_data&amp; s);    //里面所有T都换成特例化类型版本sales_data    //按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。&#125;;</code></pre><p>类模板的部分特例化</p><p>不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)</p><p>特例化类中的部分成员</p><p>可以特例化类中的部分成员函数而不是整个类，举个例子：</p><pre><code class="cpp">template&lt;typename T&gt;class Foo&#123;    void Bar();    void Barst(T a)();&#125;;template&lt;&gt;void Foo&lt;int&gt;::Bar()&#123;    //进行int类型的特例化处理    cout &lt;&lt; &quot;我是int型特例化&quot; &lt;&lt; endl;&#125;Foo&lt;string&gt; fs;Foo&lt;int&gt; fi;//使用特例化fs.Bar();//使用的是普通模板，即Foo&lt;string&gt;::Bar()fi.Bar();//特例化版本，执行Foo&lt;int&gt;::Bar()//Foo&lt;string&gt;::Bar()和Foo&lt;int&gt;::Bar()功能不同</code></pre><h3 id="5-7-模板定义和实现可不可以不写在一个文件里面？为什么？"><a href="#5-7-模板定义和实现可不可以不写在一个文件里面？为什么？" class="headerlink" title="5.7 模板定义和实现可不可以不写在一个文件里面？为什么？"></a>5.7 模板定义和实现可不可以不写在一个文件里面？为什么？</h3><p>模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着**编译器在当时不为它分配存储空间(没有具体的函数时不会对模板实例化)**，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p><p>定义一个类一般都是在头文件中进行类声明，在cpp文件中实现，但使用模板时应注意目前的C++编译器还无法分离编译，最好将实现代码和声明代码均放在头文件中。如：</p><pre><code class="cpp">// test.htemplate &lt;class T&gt;class CTest&#123;  public:          T&amp; GetValue();        protected:  T m_Value;&#125;; // test.cpptemplate &lt;class T&gt;T&amp; CTest&lt;T&gt;::GetValue()&#123;       return m_Value;  &#125;</code></pre><p>在这儿test.cpp中的内容应放在test.h中，否则在生成最终可执行程序时就会出现错误(在链接时会出错)。因为<code>在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现</code>，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。</p><h3 id="5-8-构造函数、析构函数、虚函数可否声明为内联函数"><a href="#5-8-构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="5.8 构造函数、析构函数、虚函数可否声明为内联函数"></a>5.8 构造函数、析构函数、虚函数可否声明为内联函数</h3><p>首先，将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。</p><blockquote><p>register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率</p></blockquote><p>构造函数和析构函数声明为内联函数是没有意义的</p><p>《Effective C++》中所阐述的是：将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请&#x2F;释放内存，构造&#x2F;析构对象等），致使构造函数&#x2F;析构函数并不像看上去的那么精简。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。</p><p>将虚函数声明为inline，要分情况讨论</p><p>有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联呢？</p><p>上述观点看似正确，其实不然，如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当用对象调用虚函数（此时不具有多态性）时，就内联展开</p><p>综上，当是<code>指向派生类的指针（多态性）</code>调用声明为inline的虚函数时，不会内联展开；当是<code>对象本身调用虚函数</code>时，会内联展开，当然前提依然是函数并不复杂的情况下。</p><h3 id="5-9-C-模板是什么，你知道底层怎么实现的？"><a href="#5-9-C-模板是什么，你知道底层怎么实现的？" class="headerlink" title="5.9 C++模板是什么，你知道底层怎么实现的？"></a>5.9 C++模板是什么，你知道底层怎么实现的？</h3><ul><li><p>编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</p></li><li><p>这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</p></li></ul><h3 id="5-10-构造函数和析构函数可以调用虚函数吗，为什么"><a href="#5-10-构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="5.10 构造函数和析构函数可以调用虚函数吗，为什么"></a>5.10 构造函数和析构函数可以调用虚函数吗，为什么</h3><p>在C++中，提倡不在构造函数和析构函数中调用虚函数；</p><p>构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；</p><p>因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；</p><p>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</p><h3 id="5-11-如何解决菱形继承"><a href="#5-11-如何解决菱形继承" class="headerlink" title="5.11 如何解决菱形继承"></a>5.11 如何解决菱形继承</h3><p>使用虚继承：</p><p>虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。 如:类D继承自类B1、B2，而类B1、B2都继 承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为虚拟继承，而A就成了虚拟基类,虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。</p><p>虚继承的特点是，在任何派生类中的virtual基类总用同一个（共享）对象表示，</p><h3 id="5-12-将字符串“hello-world”从开始到打印到屏幕上的全过程"><a href="#5-12-将字符串“hello-world”从开始到打印到屏幕上的全过程" class="headerlink" title="5.12 将字符串“hello world”从开始到打印到屏幕上的全过程?"></a>5.12 将字符串“hello world”从开始到打印到屏幕上的全过程?</h3><ol><li><p>用户告诉操作系统执行HelloWorld程序（通过键盘输入等）</p></li><li><p>操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。</p></li><li><p>操作系统：创建一个新进程，将HelloWorld可执行文件映射到该进程结构，表示由该进程执行helloworld程序。</p></li><li><p>操作系统：为helloworld程序设置cpu上下文环境，并跳到程序开始处。</p></li><li><p>执行helloworld程序的第一条指令，发生缺页异常</p></li><li><p>操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序</p></li><li><p>helloword程序执行puts函数（系统调用），在显示器上写一字符串</p></li><li><p>操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程</p></li><li><p>操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区</p></li><li><p>视频硬件将像素转换成显示器可接收和一组控制数据信号</p></li><li><p>显示器解释信号，激发液晶屏</p></li><li><p>OK，我们在屏幕上看到了HelloWorld</p></li></ol><h3 id="5-13-为什么拷贝构造函数必须传引用不能传值？"><a href="#5-13-为什么拷贝构造函数必须传引用不能传值？" class="headerlink" title="5.13 为什么拷贝构造函数必须传引用不能传值？"></a>5.13 为什么拷贝构造函数必须传引用不能传值？</h3><p>拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。</p><h3 id="5-14-虚函数的调用关系"><a href="#5-14-虚函数的调用关系" class="headerlink" title="5.14 虚函数的调用关系"></a>5.14 虚函数的调用关系</h3><p>this -&gt; vptr -&gt; vtable -&gt;virtual function</p><h3 id="5-15-说一说你了解到的移动构造函数？"><a href="#5-15-说一说你了解到的移动构造函数？" class="headerlink" title="5.15 说一说你了解到的移动构造函数？"></a>5.15 说一说你了解到的移动构造函数？</h3><ol><li><p>有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</p></li><li><p>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；</p></li><li><p>C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；</p></li><li><p>与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作；</p></li></ol><pre><code class="cpp">Example6 (Example6&amp;&amp; x) : ptr(x.ptr)   &#123;    x.ptr = nullptr;  &#125;  // move assignment  Example6&amp; operator= (Example6&amp;&amp; x)   &#123;   delete ptr;    ptr = x.ptr;   x.ptr=nullptr;    return *this;&#125;</code></pre><h3 id="5-16-哪些函数不能是虚函数？把你知道的都说一说"><a href="#5-16-哪些函数不能是虚函数？把你知道的都说一说" class="headerlink" title="5.16 哪些函数不能是虚函数？把你知道的都说一说"></a>5.16 哪些函数不能是虚函数？把你知道的都说一说</h3><ol><li><p>构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；</p></li><li><p>内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；</p></li><li><p>静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。</p></li><li><p>友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</p></li><li><p>普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。</p></li></ol><h3 id="5-17-什么是纯虚函数，与虚函数的区别"><a href="#5-17-什么是纯虚函数，与虚函数的区别" class="headerlink" title="5.17 什么是纯虚函数，与虚函数的区别"></a>5.17 什么是纯虚函数，与虚函数的区别</h3><ul><li><p>虚函数和纯虚函数区别？<br>虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。</p></li><li><p>纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。</p></li><li><p>纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“&#x3D;0”。</p></li><li><p>既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。</p></li><li><p>一个类中如果有纯虚函数的话，称其为抽象类。抽象类不能用于实例化对象，否则会报错。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象。</p></li></ul><h3 id="5-18-DLL劫持"><a href="#5-18-DLL劫持" class="headerlink" title="5.18 DLL劫持"></a>5.18 DLL劫持</h3><p>DLL 劫持（DLL hijacking）是一种安全漏洞，利用该漏洞，攻击者可以将恶意 DLL 文件伪装成系统或应用程序所需的 DLL 文件，并放置在系统搜索路径中，以便在程序运行时被加载并执行恶意代码。</p><p>攻击者通常利用以下几种方法进行 DLL 劫持：</p><ol><li><strong>将恶意 DLL 放置在可被系统搜索到的目录中</strong>：攻击者可以将恶意 DLL 文件放置在系统搜索路径中的一个或多个目录中，例如程序所在目录、当前工作目录、系统目录（如 System32）或者应用程序目录等。当程序启动时，系统会按照一定的搜索顺序查找并加载所需的 DLL 文件，如果发现了恶意 DLL，就会加载并执行其中的恶意代码。</li><li><strong>利用缺陷的搜索顺序</strong>：有些程序在加载 DLL 文件时存在搜索顺序上的缺陷，例如优先从当前工作目录加载 DLL 文件而不是系统目录。攻击者可以利用这种缺陷，将恶意 DLL 文件放置在当前工作目录下，并等待程序启动时被加载执行。</li><li><strong>利用自定义环境变量</strong>：攻击者可以利用自定义的环境变量来修改程序的搜索路径，从而加载恶意 DLL 文件。例如，攻击者可以通过修改 PATH 环境变量，将恶意 DLL 文件所在的目录添加到系统搜索路径中。</li></ol><p>为了防止 DLL 劫持攻击，可以采取以下几种措施：</p><ol><li><strong>使用绝对路径加载 DLL 文件</strong>：在程序中明确指定 DLL 文件的绝对路径，而不是依赖系统搜索路径。这样可以确保程序只加载所需的 DLL 文件，并避免加载恶意 DLL 文件。</li><li><strong>加强权限控制</strong>：限制用户对系统目录和应用程序目录的写入权限，防止恶意 DLL 文件被放置在系统搜索路径中。<br>更新程序：及时更新程序，修复可能存在的 DLL 劫持漏洞。一些程序已经针对 DLL 劫持进行了修复，并提供了安全更新。</li><li><strong>使用数字签名</strong>：对 DLL 文件进行数字签名，确保文件的完整性和来源可信。程序在加载 DLL 文件时可以验证其数字签名，以确保文件未被篡改。<br>启用安全策略：在操作系统和应用程序中启用相应的安全策略，限制恶意代码的执行。例如，使用应用程序白名单、启用应用程序沙盒等。</li></ol><p>通过采取以上措施，可以有效地防止 DLL 劫持攻击，并保护系统和应用程序的安全。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> 常识类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2022/08/22/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/08/22/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p>由于md文件同一个效果可能有不同写法，我只记录下我喜欢的用法，方便后续查询使用。</p><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><pre><code class="txt"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h2 id="二、段落样式"><a href="#二、段落样式" class="headerlink" title="二、段落样式"></a>二、段落样式</h2><h3 id="2-1-换行"><a href="#2-1-换行" class="headerlink" title="2.1 换行"></a>2.1 换行</h3><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用<code>两个以上空格加上回车</code>。<br>而在<code>换行基础上加一个回车</code>或者直接<code>两次回车</code>会导致空出一行。</p><h3 id="2-2-字体"><a href="#2-2-字体" class="headerlink" title="2.2 字体"></a>2.2 字体</h3><p>Markdown 可以使用<code>*</code>或者<code>_</code>切换字体<br>示例如下：</p><pre><code class="txt">*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___</code></pre><h3 id="2-3-分隔线"><a href="#2-3-分隔线" class="headerlink" title="2.3 分隔线"></a>2.3 分隔线</h3><p>你可以在一行中用<code>三个以上的星号、减号、底线</code>来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><pre><code class="txt">**** * ******- - -----------</code></pre><h3 id="2-4-删除线"><a href="#2-4-删除线" class="headerlink" title="2.4 删除线"></a>2.4 删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线<code>~~</code>即可，实例如下：</p><pre><code class="txt">~~BAIDU.COM~~</code></pre><p>效果：<del>BAIDU.COM</del></p><h3 id="2-5-下划线"><a href="#2-5-下划线" class="headerlink" title="2.5 下划线"></a>2.5 下划线</h3><p>下划线可以通过HTML的<code>&lt;u&gt;</code>标签来实现：</p><pre><code class="txt">&lt;u&gt;带下划线文本&lt;/u&gt;</code></pre><p>效果：<u>带下划线文本</u></p><h2 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h2><p>Markdown 支持有序列表和无序列表。</p><h3 id="3-1-无序列表"><a href="#3-1-无序列表" class="headerlink" title="3.1 无序列表"></a>3.1 无序列表</h3><p>无序列表使用<code>星号(*)</code>、<code>加号(+)</code>或是<code>减号(-)</code>作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><pre><code class="txt">* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>效果如下：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><h3 id="3-2-有序列表"><a href="#3-2-有序列表" class="headerlink" title="3.2 有序列表"></a>3.2 有序列表</h3><p>有序列表使用数字并加上 . 号来表示，如：</p><pre><code class="txt">1. 第一项2. 第二项3. 第三项</code></pre><p>效果如下：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="3-3-列表嵌套"><a href="#3-3-列表嵌套" class="headerlink" title="3.3 列表嵌套"></a>3.3 列表嵌套</h3><p>列表嵌套只需在子列表中的选项前面添加两个或四个空格即可：</p><pre><code class="txt">1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><p>效果如下：</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h2 id="四、区块"><a href="#四、区块" class="headerlink" title="四、区块"></a>四、区块</h2><h3 id="4-1-区块使用"><a href="#4-1-区块使用" class="headerlink" title="4.1 区块使用"></a>4.1 区块使用</h3><p>Markdown 区块引用是在段落开头使用<code>&gt;</code>符号 ，然后后面紧跟<code>一个空格</code>符号：</p><pre><code class="txt">&gt; 区块引用</code></pre><p>效果如下：</p><blockquote><p>Tips：在vscode里面使用markdown的时候，可以拆分编辑器，一边预览，一边写作。</p></blockquote><h3 id="4-2-区块嵌套"><a href="#4-2-区块嵌套" class="headerlink" title="4.2 区块嵌套"></a>4.2 区块嵌套</h3><p>另外区块是可以嵌套的，一个<code>&gt;</code>符号是最外层，两个<code>&gt;</code>符号是第一层嵌套，以此类推：</p><pre><code class="txt">&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><p>效果如下：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h3 id="4-3-区块与列表"><a href="#4-3-区块与列表" class="headerlink" title="4.3 区块与列表"></a>4.3 区块与列表</h3><p>区块中使用列表<br>区块中使用列表实例如下：</p><pre><code class="txt">&gt; 区块中使用列表&gt; 1. 第一项&gt; + 第一项</code></pre><p>效果如下：</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li></ol><ul><li>第一项</li></ul></blockquote><h2 id="五、代码"><a href="#五、代码" class="headerlink" title="五、代码"></a>五、代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（&#96;），例如：</p><pre><code class="txt">`printf()` 函数</code></pre><p>效果如下：<br><code>printf()</code> 函数</p><p>你也可以用<code>```</code>包裹一段代码，并指定一种语言（也可以不指定）<br>例如指定为javascript：<br><code> ```javascript</code><br><code>代码块</code><br><code>```</code><br>效果如下：</p><pre><code class="javascript">$(document).ready(function () &#123;    alert(&#39;RUNOOB&#39;);&#125;);</code></pre><h2 id="六、链接"><a href="#六、链接" class="headerlink" title="六、链接"></a>六、链接</h2><h3 id="6-1-直接链接"><a href="#6-1-直接链接" class="headerlink" title="6.1 直接链接"></a>6.1 直接链接</h3><pre><code class="txt">&lt;链接地址&gt;</code></pre><p>效果：<br><a href="https://hualog.dns.navy/">https://hualog.dns.navy</a></p><h3 id="6-2-别名链接"><a href="#6-2-别名链接" class="headerlink" title="6.2 别名链接"></a>6.2 别名链接</h3><pre><code class="txt">[链接名称](链接地址)</code></pre><p>效果：<a href="https://hualog.dns.navy/">花落阁</a></p><h3 id="6-3-高级链接"><a href="#6-3-高级链接" class="headerlink" title="6.3 高级链接"></a>6.3 高级链接</h3><p>如果一个链接被多次使用，我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><pre><code class="txt">这个链接用 hualog 作为网址变量 [花落阁][hualog]然后在文档的结尾为变量赋值（网址）[hualog]: https://hualog.dns.navy</code></pre><p>效果：<br>这个链接用 hualog 作为网址变量 <a href="https://hualog.dns.navy/">花落阁</a></p><h2 id="七、图片"><a href="#七、图片" class="headerlink" title="七、图片"></a>七、图片</h2><p>Markdown 图片语法格式如下：</p><pre><code class="txt">![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)</code></pre><p>效果如下：<br><img src="/2022/08/22/Markdown%E8%AF%AD%E6%B3%95/cat.jpg" alt="元宝 图标"></p><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的<code>&lt;img&gt;</code>标签。</p><pre><code class="html">&lt;img src=&quot;/img/cat.jpg&quot; width=&quot;50%&quot;&gt;</code></pre><img src="/2022/08/22/Markdown%E8%AF%AD%E6%B3%95/cat.jpg" width="50%"><h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><h3 id="8-1-初始表格"><a href="#8-1-初始表格" class="headerlink" title="8.1 初始表格"></a>8.1 初始表格</h3><p>语法格式如下：</p><pre><code class="txt">|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><p>效果如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><h3 id="8-2-表格对齐方式"><a href="#8-2-表格对齐方式" class="headerlink" title="8.2 表格对齐方式"></a>8.2 表格对齐方式</h3><p>我们可以设置表格的对齐方式：</p><p><code>-:</code>设置内容和标题栏居右对齐。<br><code>:-</code>设置内容和标题栏居左对齐。<br><code>:-:</code>设置内容和标题栏居中对齐。<br>实例如下：</p><pre><code class="txt">| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: ||   x   |   x   |   x    ||   x   |   x   |   x    |</code></pre><p>效果：</p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">x</td><td align="right">x</td><td align="center">x</td></tr><tr><td align="left">x</td><td align="right">x</td><td align="center">x</td></tr></tbody></table><h2 id="九、高级技巧"><a href="#九、高级技巧" class="headerlink" title="九、高级技巧"></a>九、高级技巧</h2><h3 id="9-1-支持的-HTML-元素"><a href="#9-1-支持的-HTML-元素" class="headerlink" title="9.1 支持的 HTML 元素"></a>9.1 支持的 HTML 元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等 ，如：</p><pre><code class="txt">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre><p>效果：<br>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h3 id="9-2-转义"><a href="#9-2-转义" class="headerlink" title="9.2 转义"></a>9.2 转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><pre><code class="txt">**文本加粗** \*\* 正常显示星号 \*\*</code></pre><p>效果：<br><strong>文本加粗</strong><br>** 正常显示星号 **</p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code class="txt">\   反斜线`   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号</code></pre><h3 id="9-3-公式"><a href="#9-3-公式" class="headerlink" title="9.3 公式"></a>9.3 公式</h3><p>Markdown Preview Enhanced 使用 KaTeX 或者 MathJax 来渲染数学表达式。</p><p>KaTeX 拥有比 MathJax 更快的性能，但是它却少了很多 MathJax 拥有的特性。你可以查看 KaTeX supported functions&#x2F;symbols 来了解 KaTeX 支持那些符号和函数。</p><pre><code class="txt">$...$ 或者 \(...\) 中的数学表达式将会在行内显示。$$...$$ 或者 \[...\] 或者 ```math 中的数学表达式将会在块内显示。</code></pre><p>例如：</p><pre><code class="txt">$f(x) = sin(x) + cos(x)$$$f(x) = sin(x) + cos(x)$$</code></pre><p>行内：<br>$f(x) &#x3D; sin(x) + cos(x)$<br>块内：<br>$$f(x) &#x3D; sin(x) + cos(x)$$</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> md </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
