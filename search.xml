<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CMake语法</title>
      <link href="/2024/03/28/CMake%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/03/28/CMake%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="CMake-语法"><a href="#CMake-语法" class="headerlink" title="CMake 语法"></a>CMake 语法</h1><h2 id="CMake-简介"><a href="#CMake-简介" class="headerlink" title="CMake 简介"></a>CMake 简介</h2><h3 id="什么是-CMake"><a href="#什么是-CMake" class="headerlink" title="什么是 CMake"></a>什么是 CMake</h3><pre><code>CMake 是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装（编译过程）。他能够输出各种各样的makefile 或者 project 文件，CMake 的配置文件取名为 CMakeLists.txt。也就是在 CMakeLists.txt 这个文件中写 cmake 代码。 一句话：cmake 就是将多个 cpp、hpp 文件组合构建为一个大工程的语言。</code></pre><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><strong>优点：</strong><ul><li>开源，使用类BSD许可发布。</li><li>跨平台，并可以生成 native 编译配置文件，在 Linux&#x2F;Unix 平台，生成 makefile；在苹果平台可以生成 Xcode；在Windows 平台，可以生成 MSVC 的工程文件。</li><li>能够管理大型项目。</li><li>简化编译构建过程和编译过程。cmake 的工具链非常简单：cmake + make。</li><li>高效率，因为 cmake 在工具链中没有 libtool。</li><li>可扩展，可以为 cmake 编写特定功能的模块，扩展 cmake 功能。</li></ul></li><li><strong>缺点：</strong><ul><li>cmake 只是看起来比较简单，而使用并不简单。</li><li>cmake 编写的过程实际上是编程的过程，每个项目使用一个       </li><li>cmake 跟已有体系配合不是特别的理想，比如 pkgconfig。</li></ul></li></ul><h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><p>在 linux 下使用 CMake 生成 Makefile 并编译的流程如下：</p><ol><li>编写 CMake 配置文件 CMakeLists.txt 。</li><li>在 CMakeLists.txt 文件所在目录创建一个 build 文件夹，然后进入目录。（这一步可以省略，但是生成的中间文件不易清理）</li><li>执行命令<code>cmake PATH</code>或者<code>ccmake PATH</code>生成 Makefile（<code>ccmake</code>和<code>cmake</code>的区别在于前者提供了一个交互式的界面）。其中，<code>PATH</code>是 CMakeLists.txt 所在的目录。</li><li>使用<code>make</code>命令进行编译，使用<code>make install</code>进行安装。</li></ol><h2 id="CMake-实战"><a href="#CMake-实战" class="headerlink" title="CMake 实战"></a>CMake 实战</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>以Ubuntu为例：<br>首先，更新本地的软件包索引，以确保获取最新的可用软件包列表。打开终端，并执行以下命令：</p><pre><code class="bash">sudo apt update</code></pre><p>安装 CMake。执行以下命令：</p><pre><code class="bash">sudo apt install cmake</code></pre><p>安装完成后，你可以通过以下命令验证是否成功安装了 CMake：</p><pre><code class="bash">cmake --version</code></pre><p>该命令会显示安装的 CMake 版本信息。</p><p>通过以上步骤，你应该已经成功在 Ubuntu 上安装了 CMake。</p><h3 id="编译单个源文件"><a href="#编译单个源文件" class="headerlink" title="编译单个源文件"></a>编译单个源文件</h3><p>首先查看一下某个示例的目录结构：</p><pre><code>.├── CMakeLists.txt├── main.cpp└── README.adoc</code></pre><p>在本目录下有三个文件，分别是源文件 main.cpp，cmake 构建规则 CMakeLists.txt 以及说明文件 README.adoc，下面来看看他们的具体内容。</p><pre><code class="C++">#include &lt;iostream&gt;int main(int argc, char *argv[])&#123;   std::cout &lt;&lt; &quot;Hello CMake!&quot; &lt;&lt; std::endl;   return 0;&#125;</code></pre><p>源文件是一个简单的 Hello World。</p><pre><code class="cmake">cmake_minimum_required(VERSION 3.10)    # 设CMake最小版本号project(hello_cmake)    # 设置工程名add_executable($&#123;PROJECT_NAME&#125; main.cpp)# 生成可执行文件</code></pre><p>CMakeLists 中主要包含了三个命令：</p><ul><li><code>cmake_minimum_required(VERSION 3.10)</code>：指定运行此配置文件所需的 CMake 的最低版本。</li><li><code>project (hello_cmake)</code>：设置项目的名称，同时会自动生成 PROJECT_NAME 变量，使用 ${PROJECT_NAME} 即可访问到 hello_cmake。</li><li><code>add_executable(hello_cmake main.cpp)</code>：第一个参数是可执行文件名，第二个参数是要编译的源文件列表。z这里将名为 main.cpp 的源文件编译成一个名称为 hello_cmake 的可执行文件。</li></ul><p>接着我们可以开始构建项目，构建的方法有以下两种：</p><ul><li><strong>内部构建</strong>：直接在源文件目录构建项目，会导致临时文件和源代码放在一起，不好清理。</li><li><strong>外部构建</strong>：创建一个可以位于文件系统上任何位置的构建文件夹。 所有临时构建和目标文件都位于此目录中，以保持源代码树的整洁。</li></ul><p>这里以外部构建为例，此时我们需要新建一个构建文件夹 build，并在该目录下运行 cmake 命令进行构建：</p><pre><code class="bash">#创建并进入build目录mkdir build &amp;&amp; cd build#构建当前目录cmake ..#使用cmake生成的makefile编译得到可执行文件make</code></pre><p>此时在当前目录下，就会生成可执行文件 hello_cmake。将其运行查看是否成功编译：</p><pre><code class="bash">./hello_cmakeHello CMake!</code></pre><h3 id="编译多个源文件"><a href="#编译多个源文件" class="headerlink" title="编译多个源文件"></a>编译多个源文件</h3><h4 id="单个目录下的多个源文件"><a href="#单个目录下的多个源文件" class="headerlink" title="单个目录下的多个源文件"></a>单个目录下的多个源文件</h4><p>首先查看一下本示例的目录结构：</p><pre><code>.├── CMakeLists.txt├── main.cc├── MathFunctions.cc└── MathFunctions.h</code></pre><p>与上个示例不同，本示例在单个目录下有着多个源文件，此时 CMakeLists 如下：</p><pre><code class="cmake"># CMake 最低版本号要求cmake_minimum_required (VERSION 3.10)# 项目信息project (Demo2)# 查找目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 指定生成目标add_executable($&#123;PROJECT_NAME&#125; $&#123;DIR_SRCS&#125;)</code></pre><p>在本示例中，为了避免一个个将所有源文件输入，使用了 aux_source_directory 命令。</p><ul><li><code>aux_source_directory</code>：第一个参数是目录的路径，第二个参数是变量名。当我们使用这个命令时，就会将指定目录下的所有源文件保存到指定的变量名中。<br>如果不想使用这种方法，而是向一条条枚举每个变量，可以使用 set 来手动将源文件保存到变量名中：</li></ul><pre><code class="cmake"># CMake 最低版本号要求cmake_minimum_required (VERSION 3.10)# 项目信息project (Demo2)set(DIR_SRCS    MathFunctions.cc    main.cc)# 指定生成目标add_executable($&#123;PROJECT_NAME&#125; $&#123;DIR_SRCS&#125;)</code></pre><h4 id="多个目录下的多个源文件"><a href="#多个目录下的多个源文件" class="headerlink" title="多个目录下的多个源文件"></a>多个目录下的多个源文件</h4><p>首先查看一下本示例的目录结构：</p><pre><code>.├── CMakeLists.txt├── main.cc└── math    ├── CMakeLists.txt    ├── MathFunctions.cc    └── MathFunctions.h</code></pre><p>与上个示例不同，本示例在多个目录下有着多个源文件。在这种情况下，我们需要在每个目录中都编写一个 CMakeLists.txt。这里为了方便，我们可以将 math 里的文件编译为一个静态库再有 main 函数调用。</p><p>首先看看 math 目录下的 CMakeLists.txt，这里主要做的事是将当前目录下的文件编译为一个静态库：</p><pre><code class="cmake"># 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量aux_source_directory(. DIR_LIB_SRCS)# 指定生成 MathFunctions 链接库add_library (MathFunctions $&#123;DIR_LIB_SRCS&#125;)</code></pre><ul><li><code>add_library</code>：用于从某些源文件创建一个库，默认生成在构建文件夹。第一个参数为库名（不需要 lib 前缀，会自动添加），第二个参数用于指定 SHARED（动态库），STATIC（静态库）（如果不写，则通过全局的BUILD_SHARED_LIBS 的 FALSE 或 TRUE 来指定）。第三个参数即为源文件列表。</li></ul><p>接着看看根目录的 CMakeLists.txt：</p><pre><code class="cmake"># CMake 最低版本号要求cmake_minimum_required (VERSION 3.10)# 项目信息project (Demo3)# 查找目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 添加 math 子目录add_subdirectory(math)# 指定生成目标add_executable(Demo $&#123;DIR_SRCS&#125;)# 添加链接库target_link_libraries(Demo MathFunctions)</code></pre><ul><li><code>add_subdirectory</code>：用于表示该项目包含一个子目录，此时会去处理子目录下的 CMakeLists.txt 与源文件。</li><li><code>target_link_libraries</code>：该命令用于指明可执行文件 Demo 需要链接 MathFunctions 库。第一个参数为可执行文件名，第二个参数为访问权限（PUBLIC、PRIVATE、INTERFACE，默认为 PUBLIC），第三个参数为库名（这两个参数可以为多个）。</li></ul><h3 id="导入外部库"><a href="#导入外部库" class="headerlink" title="导入外部库"></a>导入外部库</h3><h4 id="本地导入（find-package）"><a href="#本地导入（find-package）" class="headerlink" title="本地导入（find_package）"></a>本地导入（find_package）</h4><p>首先查看一下本示例的目录结构：</p><pre><code>.├── CMakeLists.txt├── main.cpp└── README.adoc</code></pre><p>这里主要演示如何导入一个本地的第三方库（这里以 boost 为例），接着看看 MakeLists.txt：</p><pre><code class="cmake">cmake_minimum_required(VERSION 3.10)# Set the project nameproject (third_party_include)# find a boost install with the libraries filesystem and system#使用库文件系统和系统查找boost installfind_package(Boost 1.46.1 REQUIRED COMPONENTS filesystem system)#这是第三方库，而不是自己生成的静态动态库# check if boost was foundif(Boost_FOUND)    message (&quot;boost found&quot;)else()    message (FATAL_ERROR &quot;Cannot find Boost&quot;)endif()# Add an executableadd_executable(third_party_include main.cpp)# link against the boost librariestarget_link_libraries(third_party_include PRIVATE Boost::filesystem)</code></pre><p>这里使用<code>find_package</code>命令来在本地搜索对应的第三方库，Boost 代表需要查询的库名称；1.46.1 代表需要库的最低版本；REQUIRED 表示该库是必须的，如果找不到会报错；COMPONENTS 用于检测该库的对应组件是否存在，如果不存在则认为找到的库不满足条件。</p><h4 id="外部导入（FetchContent）"><a href="#外部导入（FetchContent）" class="headerlink" title="外部导入（FetchContent）"></a>外部导入（FetchContent）</h4><p><code>FetchContent</code>是<code>3.11.0</code>版本开始提供的功能，只需要一个<code>URL</code>或者<code>Git仓库</code>即可引入一个库，这里以 GoogleTest 库为例：</p><pre><code class="cmake">cmake_minimum_required(VERSION 3.14)project(my_project)# GoogleTest requires at least C++11set(CMAKE_CXX_STANDARD 11)include(FetchContent)FetchContent_Declare(  googletest  URL https://github.com/google/googletest/archive/609281088cfefc76f9d0ce82e1ff6c30cc3591e5.zip)# For Windows: Prevent overriding the parent project&#39;s compiler/linker settingsset(gtest_force_shared_crt ON CACHE BOOL &quot;&quot; FORCE)FetchContent_MakeAvailable(googletest)</code></pre><p>使用方法：</p><ol><li><code>include(FetchContent) </code>：表示引入 FetchContent。</li><li><code>FetchContent_Declare(第三方库)</code> ：获取第三方库，可以是一个 URL 或者一个 Git 仓库。</li><li><code>FetchContent_MakeAvailable(第三方库)</code> ：将这个第三方库引入项目。</li><li><code>target_link_libraries(主项目 PRIVATE 子模块::子模块) </code>：链接这个第三方库。</li></ol><h3 id="测试与安装"><a href="#测试与安装" class="headerlink" title="测试与安装"></a>测试与安装</h3><p>CMake 也可以指定安装规则，以及添加测试。这两个功能分别可以通过在产生 Makefile 后使用<code>make install</code>和<code>make test</code>来执行。<br>首先查看一下本示例的目录结构：</p><pre><code>.├── CMakeLists.txt├── config.h.in├── License.txt├── main.cc└── math    ├── CMakeLists.txt    ├── MathFunctions.cc    └── MathFunctions.h</code></pre><h4 id="自定义安装规则"><a href="#自定义安装规则" class="headerlink" title="自定义安装规则"></a>自定义安装规则</h4><p>首先查看 math 目录下的 CMakeLists.txt：</p><pre><code class="cmake"># 查找当前目录下的所有源文件# 并将名称保存到 DIR_LIB_SRCS 变量aux_source_directory(. DIR_LIB_SRCS)# 指定生成 MathFunctions 链接库add_library (MathFunctions $&#123;DIR_LIB_SRCS&#125;)# 指定 MathFunctions 库的安装路径install (TARGETS MathFunctions DESTINATION lib)install (FILES MathFunctions.h DESTINATION include)</code></pre><p>这里使用<code>install</code>命令表明了将静态库 MathFunctions 安装到 &#x2F;usr&#x2F;local&#x2F;lib 目录下，将头文件 MathFunctions.h 安装到 &#x2F;usr&#x2F;local&#x2F;include 目录下。</p><p>接着查看根目录的 install 内容：</p><pre><code class="cmake"># 指定安装路径install (TARGETS Demo DESTINATION bin)install (FILES &quot;$&#123;PROJECT_BINARY_DIR&#125;/config.h&quot; DESTINATION include)</code></pre><p>这里将可执行程序 Demo 安装到了 &#x2F;usr&#x2F;local&#x2F;lib 目录下，再将 config.h 安装到 &#x2F;usr&#x2F;local&#x2F;lib 目录下。</p><blockquote><p>&#x2F;usr&#x2F;local&#x2F; 是默认安装的根目录，可以通过修改 CMAKE_INSTALL_PREFIX 变量的值来指定这些文件应该拷贝到哪个根目录</p></blockquote><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>CMake 提供了一个称为<code>CTest</code>的测试工具。我们要做的只是在项目根目录的 CMakeLists 文件中调用一系列的<code>add_test</code>命令。</p><pre><code class="cmake"># 启用测试enable_testing()# 测试程序是否成功运行add_test (test_run Demo 5 2)# 测试帮助信息是否可以正常提示add_test (test_usage Demo)set_tests_properties (test_usage  PROPERTIES PASS_REGULAR_EXPRESSION &quot;Usage: .* base exponent&quot;)# 测试 5 的平方# add_test (test_5_2 Demo 5 2)# set_tests_properties (test_5_2#  PROPERTIES PASS_REGULAR_EXPRESSION &quot;is 25&quot;)# 测试 10 的 5 次方# add_test (test_10_5 Demo 10 5)# set_tests_properties (test_10_5#  PROPERTIES PASS_REGULAR_EXPRESSION &quot;is 100000&quot;)# 测试 2 的 10 次方# add_test (test_2_10 Demo 2 10)# set_tests_properties (test_2_10#  PROPERTIES PASS_REGULAR_EXPRESSION &quot;is 1024&quot;)# 定义一个宏，用来简化测试工作macro (do_test arg1 arg2 result)  add_test (test_$&#123;  arg1&#125;_$&#123;  arg2&#125; Demo $&#123;  arg1&#125; $&#123;  arg2&#125;)  set_tests_properties (test_$&#123;  arg1&#125;_$&#123;  arg2&#125;    PROPERTIES PASS_REGULAR_EXPRESSION $&#123;  result&#125;)endmacro (do_test)# 利用 do_test 宏，测试一系列数据do_test (5 2 &quot;is 25&quot;)do_test (10 5 &quot;is 100000&quot;)do_test (2 10 &quot;is 1024&quot;)</code></pre><ul><li><code>enable_testing</code>：用于启动测试。</li><li><code>add_test</code>：用于添加测试，第一个参数为测试名，第二个参数为可执行程序，剩下的为可执行程序的参数。</li><li><code>set_tests_properties</code>：测试的提示信息。</li><li><code>macro</code>：宏，用于编写一个重复性操作来简化测试用例的编写。</li><li><code>do_test</code>：编写的测试宏。</li></ul><h4 id="生成安装包"><a href="#生成安装包" class="headerlink" title="生成安装包"></a>生成安装包</h4><p>如果想要生成安装包，则需要使用<code>CPack</code>，它是由 CMake 提供的一个工具，专门用于打包。此时需要在 CMakeLists.txt 中添加以下内容：</p><pre><code class="cmake"># 构建一个 CPack 安装包include (InstallRequiredSystemLibraries)set (CPACK_RESOURCE_FILE_LICENSE  &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/License.txt&quot;)set (CPACK_PACKAGE_VERSION_MAJOR &quot;$&#123;Demo_VERSION_MAJOR&#125;&quot;)set (CPACK_PACKAGE_VERSION_MINOR &quot;$&#123;Demo_VERSION_MINOR&#125;&quot;)include (CPack)</code></pre><ul><li><code>include (InstallRequiredSystemLibraries)</code>：导入 InstallRequiredSystemLibraries 模块。</li><li>设置一些 CPack 相关变量。</li><li><code>include (CPack)</code>：导入 CPack 模块。</li></ul><p>接着执行 cmake 和 make 构建工程，此时再执行 cpack 命令即可生成安装包：</p><pre><code class="cmake">#生成二进制安装包cpack -C CPackConfig.cmake#生成源码安装包cpack -C CPackSourceConfig.cmake</code></pre><p>当命令执行成功后，就会在当前目录下生成 <em>.sh、</em>.tar.gz、*.tar.Z 这三个格式的安装包。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmake </tag>
            
            <tag> make </tag>
            
            <tag> 程序构建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024.03.25</title>
      <link href="/2024/03/25/2024-03-25/"/>
      <url>/2024/03/25/2024-03-25/</url>
      
        <content type="html"><![CDATA[<h1 id="今天在下班路上看见了樱花"><a href="#今天在下班路上看见了樱花" class="headerlink" title="今天在下班路上看见了樱花"></a><center>今天在下班路上看见了樱花</h1><pre><code>好像很久没有一个人出门走走了。今天下班回家看见马路两旁，樱花盛开。我发给朋友看，我和他说，来杭州三年了，为什么前两年我没看到过樱花呢？他回答说：“可能是因为你直到最近才有空停下脚步看一下周围的风景。”于是我回忆了我毕业后的日子。大家都说疫情是被偷走的三年，但是我好像被偷走了五年，我的2019-2024。回顾这五年，看起来我似乎度过了漫长岁月，但是我的工作，我的感情，好像都处在停滞不前的状态。我一直过着两点一线的生活，也从不与朋友聊天叙旧。工作，游戏似乎就是我的一切。直到今年2月底，突如其来的打击，我似乎早有预感，但仍然猝不及防。2024年2月24日元宵节之后，大概是我前半生最痛苦的一个月了吧。我开始反思，为什么我不能做得更好，是啊，我为什么不能做得更好呢。人的学习是需要驱动力的，还是之前过得太安逸了。总以为够了，总想着躺平，总说明天一定，下次一定。我知道错了虚度的时间是我欠的债有些东西 失去了就找不回了懂得的道理 是我等价交换来的努力变优秀吧 Aze</code></pre>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
          <category> 2024 </category>
          
          <category> 3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2024 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++八股文</title>
      <link href="/2024/03/23/C-%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/03/23/C-%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="C-八股文"><a href="#C-八股文" class="headerlink" title="C++八股文"></a>C++八股文</h1><h2 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h2><h3 id="1-1-在main执行之前和之后执行的代码可能是什么？"><a href="#1-1-在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="1.1 在main执行之前和之后执行的代码可能是什么？"></a>1.1 在main执行之前和之后执行的代码可能是什么？</h3><p><strong>main函数执行之前，主要就是初始化系统相关资源：</strong></p><ul><li>设置栈指针</li><li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li><li>将未初始化部分的全局变量赋初值：数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，<code>bool</code>为<code>FALSE</code>，<code>指针</code>为<code>NULL</code>等等，即<code>.bss</code>段的内容</li><li>将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li><li>执行<code>__attribute__((constructor))</code>，与golang的init()函数类似</li></ul><p><strong>main函数完成后：</strong></p><ul><li>全局对象的析构函数</li><li>可以用<code>atexit</code>注册一个函数，它会在<code>main</code>之后执行;</li><li><code>__attribute__((destructor))</code></li></ul><h3 id="1-2-结构体内存对齐问题？"><a href="#1-2-结构体内存对齐问题？" class="headerlink" title="1.2 结构体内存对齐问题？"></a>1.2 结构体内存对齐问题？</h3><ul><li>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</li><li>未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）</li></ul><p>c++11以后引入两个关键字<a href="https://zh.cppreference.com/w/cpp/language/alignas"><code>alignas</code></a>与<a href="https://zh.cppreference.com/w/cpp/language/alignof"><code>alignof</code></a>。其中<code>alignof</code>可以计算出类型的对齐方式，<code>alignas</code>可以指定结构体的对齐方式。但是仍有需要注意的点：</p><ul><li>若<code>alignas</code>小于自然对齐的最小单位，则被忽略。</li><li>如果想使用单字节对齐的方式，使用<code>alignas</code>是无效的。应该使用<code>#pragma pack(push,1)</code>或者使用<code>__attribute__((packed))</code>。</li></ul><p>用法如下：</p><pre><code class="C++">// 无效的指定 因为2小于自然对齐的大小uint32_t(4)struct alignas(2) Info2 &#123;  uint8_t a;  uint32_t b;  uint8_t c;&#125;;</code></pre><h3 id="1-3-指针和引用的区别"><a href="#1-3-指针和引用的区别" class="headerlink" title="1.3 指针和引用的区别"></a>1.3 指针和引用的区别</h3><ul><li>指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名</li><li>指针可以有多级，引用只有一级</li><li>指针可以为空，引用不能为NULL且在定义时必须初始化</li><li>指针在初始化后可以改变指向，而引用在初始化之后不可再改变</li><li>sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</li><li>引用本质是一个指针，同样会占4&#x2F;8字节内存，不过编译器对它进行了一些处理，使得程序认为它不单独占用内存空间；指针是具体变量，需要占用存储空间。</li><li>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</li><li>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</li></ul><h3 id="1-4-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"><a href="#1-4-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？" class="headerlink" title="1.4 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"></a>1.4 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</h3><ul><li>需要操作内存的时候传指针。</li><li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小。</li><li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式。</li></ul><h3 id="1-5-堆和栈的区别"><a href="#1-5-堆和栈的区别" class="headerlink" title="1.5 堆和栈的区别"></a>1.5 堆和栈的区别</h3><ul><li><p>申请方式不同。</p><p>栈由系统自动分配。<br>堆是自己申请和释放的。</p></li><li><p>申请大小限制不同。</p><p>栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。<br>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。<br>栈空间默认是4M, 堆区一般是 1G - 4G</p></li><li><p>申请效率不同。</p><p>栈由系统分配，速度快，不会有碎片。<br>堆由程序员分配，速度慢，且会有碎片。</p></li></ul><h3 id="1-6-栈为什么比堆执行快？"><a href="#1-6-栈为什么比堆执行快？" class="headerlink" title="1.6 栈为什么比堆执行快？"></a>1.6 栈为什么比堆执行快？</h3><ol><li><p>栈内存的快速访问主要是因为它通常位于主存中的相对较小的内存区域，这使得 CPU 缓存（包括一级缓存）中的数据能够快速加载到处理器中。此外，栈内存的顺序访问模式也有助于提高缓存的命中率。    </p></li><li><p>堆内存访问首先要从内存读指针地址，然后再用这个指针地址加偏移量去访问堆内存，这就导致了多一个读指令。另外，堆内存很可能不处于缓存里，尤其是第一次访问，如果再发生缺页中断会导致堆和栈出现巨大的速度差异。</p></li><li><p>堆内存需要做内存申请，这是极为耗时的操作，如果把内存申请的消耗计算在内，那栈内存的综合速度优势就又多了一项。</p></li></ol><h3 id="1-7-区别以下指针类型？"><a href="#1-7-区别以下指针类型？" class="headerlink" title="1.7 区别以下指针类型？"></a>1.7 区别以下指针类型？</h3><pre><code class="C++">int *p[10]int (*p)[10]int *p(int)int (*p)(int)</code></pre><ul><li><p>int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</p></li><li><p>int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</p></li><li><p>int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</p></li><li><p>int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</p></li></ul><h3 id="1-8-new-delete-与-malloc-free的异同"><a href="#1-8-new-delete-与-malloc-free的异同" class="headerlink" title="1.8 new &#x2F; delete 与 malloc &#x2F; free的异同"></a>1.8 new &#x2F; delete 与 malloc &#x2F; free的异同</h3><ul><li><p>相同点</p><ul><li>都可用于内存的动态申请和释放</li></ul></li><li><p>不同点</p><ul><li>前者是C++运算符，后者是C&#x2F;C++语言标准库函数</li><li>new自动计算要分配的空间大小，malloc需要手工计算</li><li>new是类型安全的，malloc不是。例如：</li></ul><pre><code>int *p = new float[2]; //编译错误*p = (int*)malloc(2 * sizeof(double));//编译无错误</code></pre><ul><li>new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者均没有相关调用</li><li>后者需要库文件支持，前者不用</li><li>new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象</li></ul></li></ul><h3 id="1-9-被free回收的内存是立即返还给操作系统吗？"><a href="#1-9-被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="1.9 被free回收的内存是立即返还给操作系统吗？"></a>1.9 被free回收的内存是立即返还给操作系统吗？</h3><ul><li>不是的，被free回收的内存会首先被内存管理系统的自由列表（free list）保存起来。常见的如ptmalloc使用双链表保存内存块，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</li></ul><h3 id="1-10-宏定义和typedef区别？"><a href="#1-10-宏定义和typedef区别？" class="headerlink" title="1.10 宏定义和typedef区别？"></a>1.10 宏定义和typedef区别？</h3><ul><li><p>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</p></li><li><p>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</p></li><li><p>宏不检查类型；typedef会检查数据类型。</p></li><li><p>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</p></li><li><p>注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。</p></li></ul><h3 id="1-11-strlen和sizeof区别？"><a href="#1-11-strlen和sizeof区别？" class="headerlink" title="1.11 strlen和sizeof区别？"></a>1.11 strlen和sizeof区别？</h3><ul><li><p>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</p></li><li><p>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</p></li><li><p>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</p></li></ul><h3 id="1-12-一个指针占多少字节？"><a href="#1-12-一个指针占多少字节？" class="headerlink" title="1.12 一个指针占多少字节？"></a>1.12 一个指针占多少字节？</h3><ul><li><p>在64位的编译环境下，指针的占用大小为8字节；</p></li><li><p>而在32位环境下，指针占用大小为4字节。</p></li><li><p>一个指针占内存的大小跟编译环境有关，而与机器的位数无关。</p></li><li><p>还有疑问的，可以自行打开Visual Studio编译器自己实验一番。</p></li></ul><h3 id="1-13-常量指针和指针常量区别？"><a href="#1-13-常量指针和指针常量区别？" class="headerlink" title="1.13 常量指针和指针常量区别？"></a>1.13 常量指针和指针常量区别？</h3><ul><li><p>常量指针是一个不能给改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值（也就是存放在指针中的地址）就不能在改变了，即不能中途改变指向，如int *const p。</p><blockquote><p>指针是常量</p></blockquote></li><li><p>指针常量是一个指针，读成常量的指针，指向一个只读变量，也就是后面所指明的int const 和 const int，都是一个常量，可以写作int const *p或const int *p。</p><blockquote><p>常量被指针指向</p></blockquote></li></ul><h3 id="1-13-2-顶层const与底层const"><a href="#1-13-2-顶层const与底层const" class="headerlink" title="1.13.2 顶层const与底层const"></a>1.13.2 顶层const与底层const</h3><ul><li>顶层const：指针本身是一个常量；</li><li>底层const：指针所指对象是一个常量；</li></ul><h3 id="1-14-C-和C语言的区别"><a href="#1-14-C-和C语言的区别" class="headerlink" title="1.14 C++和C语言的区别"></a>1.14 C++和C语言的区别</h3><ul><li><strong>面向对象编程（OOP）</strong>：<br>C++ 是一种支持面向对象编程的语言，它引入了类和对象的概念，以及封装、继承和多态等面向对象的特性。<br>C 语言虽然也可以编写面向对象的代码，但它没有内建的语言特性来支持面向对象编程，因此需要使用结构体和函数来模拟类和对象。</li><li><strong>标准库</strong>：<br>C++ 标准库（STL）提供了许多丰富的数据结构和算法，如向量、列表、映射、排序和搜索等。<br>C 语言的标准库相对较小，只提供了一些基本的数据类型和函数，如整数、字符、字符串和文件处理等。</li><li><strong>内存管理</strong>：<br>C++ 支持动态内存分配和释放，引入了 new 和 delete 运算符用于动态分配和释放内存。<br>C 语言也支持动态内存分配和释放，但是使用的是 malloc() 和 free() 函数。</li><li><strong>异常处理</strong>：<br>C++ 支持异常处理机制，可以使用 try、catch 和 throw 关键字来处理异常情况。<br>C 语言没有内建的异常处理机制，通常通过返回值或错误码来处理异常情况。</li><li><strong>其他特性</strong>：<br>C++ 还引入了许多其他特性，如模板、命名空间、运算符重载和函数重载等，以提高代码的灵活性和可复用性。<br>C 语言相对较简单，更加接近硬件和操作系统，因此更适用于系统级编程和嵌入式开发。</li></ul><p>总的来说，C++ 是在 C 语言基础上发展而来的，它继承了 C 语言的一些特性，并引入了更多的高级特性，如面向对象编程和异常处理等，使得它更加适用于大型项目和复杂的软件开发。</p><h3 id="1-15-C-中struct和class的区别"><a href="#1-15-C-中struct和class的区别" class="headerlink" title="1.15 C++中struct和class的区别"></a>1.15 C++中struct和class的区别</h3><ul><li><p>相同点  </p><p>两者都拥有成员函数、公有和私有部分<br>任何可以使用class完成的工作，同样可以使用struct完成</p></li><li><p>不同点</p><p>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</p><p>class默认是private继承， 而struct默认是public继承</p></li></ul><h3 id="1-16-define宏定义和const的区别"><a href="#1-16-define宏定义和const的区别" class="headerlink" title="1.16 define宏定义和const的区别"></a>1.16 define宏定义和const的区别</h3><p><strong>编译阶段</strong></p><ul><li>define是在编译的<code>预处理阶段</code>起作用，而const是在<code>编译、运行</code>的时候起作用</li></ul><p><strong>安全性</strong></p><ul><li>define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错  </li><li>const常量有数据类型，编译器可以对其进行类型安全检查</li></ul><p><strong>内存占用</strong></p><ul><li>define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表</li></ul><h3 id="1-17-数组名和指针（这里为指向数组首元素的指针）区别？"><a href="#1-17-数组名和指针（这里为指向数组首元素的指针）区别？" class="headerlink" title="1.17 数组名和指针（这里为指向数组首元素的指针）区别？"></a>1.17 数组名和指针（这里为指向数组首元素的指针）区别？</h3><ul><li><p>二者均可通过增减偏移量来访问数组中的元素。</p></li><li><p>数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</p></li><li><p><strong>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</strong></p></li></ul><h3 id="1-18-extern”C”的用法"><a href="#1-18-extern”C”的用法" class="headerlink" title="1.18 extern”C”的用法"></a>1.18 extern”C”的用法</h3><ul><li>为了能够正确的在C++代码中调用C语言的代码：在程序中加上extern “C”后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++。</li></ul><h3 id="1-19-野指针和悬空指针"><a href="#1-19-野指针和悬空指针" class="headerlink" title="1.19 野指针和悬空指针"></a>1.19 野指针和悬空指针</h3><pre><code>都是是指向无效内存区域(这里的无效指的是&quot;不安全不可控&quot;)的指针，访问行为将会导致未定义行为。</code></pre><ul><li><strong>野指针</strong><br>野指针，指的是没有被初始化过的指针</li><li><strong>悬空指针</strong><br>悬空指针，指针最初指向的内存已经被释放了的一种指针。</li></ul><p>使用智能指针可以有效解决问题。</p><h3 id="1-20-C-中的重载、重写（覆盖）和隐藏的区别"><a href="#1-20-C-中的重载、重写（覆盖）和隐藏的区别" class="headerlink" title="1.20 C++中的重载、重写（覆盖）和隐藏的区别"></a>1.20 C++中的重载、重写（覆盖）和隐藏的区别</h3><ol><li><p><strong>重载（overload）</strong><br>  重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是<code>返回类型</code>和<code>函数名</code>相同，<code>参数类型和数目</code>有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个例子：</p></li><li><p><strong>重写（覆盖）（override）</strong><br>  重写指的是在派生类中覆盖基类中的同名函数，重写就是重写函数体，要求基类函数必须是虚函数且：</p><ul><li>与基类的虚函数有相同的参数个数</li><li>与基类的虚函数有相同的参数类型</li><li>与基类的虚函数有相同的返回值类型</li></ul></li><li><p><strong>隐藏（hide）</strong><br>  隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：</p><ul><li>两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。</li></ul><pre><code class="C++">  //父类  class A&#123;  public:      void fun(int a)&#123;      cout &lt;&lt; &quot;A中的fun函数&quot; &lt;&lt; endl;    &#125;  &#125;;  //子类  class B : public A&#123;  public:      //隐藏父类的fun函数      void fun(int a)&#123;      cout &lt;&lt; &quot;B中的fun函数&quot; &lt;&lt; endl;    &#125;  &#125;;  int main()&#123;      B b;      b.fun(2); //调用的是B中的fun函数      b.A::fun(2); //调用A中fun函数      return 0;  &#125;</code></pre><ul><li>两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。</li></ul><pre><code class="C++">  //父类  class A&#123;  public:      virtual void fun(int a)&#123;      cout &lt;&lt; &quot;A中的fun函数&quot; &lt;&lt; endl;    &#125;  &#125;;  //子类  class B : public A&#123;  public:      //隐藏父类的fun函数    virtual void fun(char* a)&#123;      cout &lt;&lt; &quot;A中的fun函数&quot; &lt;&lt; endl;    &#125;  &#125;;  int main()&#123;      B b;      b.fun(2); //报错，调用的是B中的fun函数，参数类型不对      b.A::fun(2); //调用A中fun函数      return 0;  &#125;</code></pre></li></ol><h3 id="1-21-浅拷贝和深拷贝的区别"><a href="#1-21-浅拷贝和深拷贝的区别" class="headerlink" title="1.21 浅拷贝和深拷贝的区别"></a>1.21 浅拷贝和深拷贝的区别</h3><ul><li><p><strong>浅拷贝</strong>  </p><p>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p></li><li><p><strong>深拷贝</strong></p><p>深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。</p></li></ul><h3 id="1-22-内联函数和宏定义的区别"><a href="#1-22-内联函数和宏定义的区别" class="headerlink" title="1.22 内联函数和宏定义的区别"></a>1.22 内联函数和宏定义的区别</h3><ul><li>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。</li><li>内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。</li><li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义<br>内联函数有类型检测、语法判断等功能，而宏没有<blockquote><p>注意：使用<code>inline</code>关键字只是建议编译器内联函数，内联函数是否真的内联还需要编译器判断。</p></blockquote></li></ul><h3 id="1-23-public，protected和private访问和继承权限-public-protected-private的区别？"><a href="#1-23-public，protected和private访问和继承权限-public-protected-private的区别？" class="headerlink" title="1.23 public，protected和private访问和继承权限&#x2F;public&#x2F;protected&#x2F;private的区别？"></a>1.23 public，protected和private访问和继承权限&#x2F;public&#x2F;protected&#x2F;private的区别？</h3><ul><li><p><strong>访问权限</strong></p><ul><li><p>public的变量和函数在类的内部外部都可以访问。</p></li><li><p>protected的变量和函数只能在类的内部和其派生类中访问。</p></li><li><p>private修饰的元素只能在类内访问。</p></li></ul></li><li><p><strong>继承权限</strong></p><ul><li><p>public继承（公有继承）的特点是基类的公有成员和保护成员作为派生类的成员时，都保持原有的状态，而基类的私有成员任然是私有的，不能被这个派生类的子类所访问</p></li><li><p>protected继承（保护继承）的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元函数访问，基类的私有成员仍然是私有的</p></li><li><p>private继承（私有继承）的特点是基类的所有公有成员和保护成员都成为派生类的私有成员，并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承</p></li></ul></li></ul><h3 id="1-24-如何用代码判断大小端存储？"><a href="#1-24-如何用代码判断大小端存储？" class="headerlink" title="1.24 如何用代码判断大小端存储？"></a>1.24 如何用代码判断大小端存储？</h3><ul><li><p>大端存储：字数据的高字节存储在低地址中  –&gt; 高位在前</p></li><li><p>小端存储：字数据的低字节存储在低地址中  –&gt; 高位在后</p><p>使用强制类型转换判断大小端存储</p><pre><code class="C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int a = 0x1234;    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分    char c = (char)(a);    if (c == 0x12)        cout &lt;&lt; &quot;big endian&quot; &lt;&lt; endl;    else if(c == 0x34)        cout &lt;&lt; &quot;little endian&quot; &lt;&lt; endl;&#125;</code></pre></li></ul><h3 id="1-25-volatile、mutable和explicit关键字的用法"><a href="#1-25-volatile、mutable和explicit关键字的用法" class="headerlink" title="1.25 volatile、mutable和explicit关键字的用法"></a>1.25 volatile、mutable和explicit关键字的用法</h3><ol><li><p><strong>volatile</strong><br>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</p></li><li><p><strong>mutable</strong><br>mutable的中文意思是“可变的，易变的”，跟constant（即C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要<code>在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置</code>。</p></li></ol><pre><code class="C++">class person&#123;    int m_A;    mutable int m_B;//特殊变量 在常函数里值也可以被修改public:    void add() const//在函数里不可修改this指针指向的值 常量指针    &#123;        m_A = 10;//错误  不可修改值，this已经被修饰为常量指针        m_B = 20;//正确    &#125;&#125;;</code></pre><pre><code class="C++">class person&#123;public:    int m_A;    mutable int m_B;//特殊变量 在常函数里值也可以被修改&#125;;int main()&#123;    const person p = person();//修饰常对象 不可修改类成员的值    p.m_A = 10;//错误，被修饰了指针常量    p.m_B = 200;//正确，特殊变量，修饰了mutable&#125;</code></pre><ol start="3"><li><p><strong>explicit</strong><br>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显式的方式进行类型转换，注意以下几点：</p><ul><li>explicit 关键字只能用于类内部的构造函数声明上</li><li>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</li></ul></li></ol><h3 id="1-26-C-的异常处理的方法"><a href="#1-26-C-的异常处理的方法" class="headerlink" title="1.26 C++的异常处理的方法"></a>1.26 C++的异常处理的方法</h3><p>在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：</p><ul><li>数组下标越界</li><li>除法计算时除数为0</li><li>动态分配空间时空间不足</li></ul><p>如果不及时对这些异常进行处理，程序多数情况下都会崩溃。</p><p>C++中的异常处理机制主要使用try、throw和catch三个关键字，其在程序中的用法如下：</p><pre><code class="C++">#include &lt;iostream&gt;using namespace std;int main()&#123;    double m = 1, n = 0;    try &#123;        cout &lt;&lt; &quot;before dividing.&quot; &lt;&lt; endl;        if (n == 0)            throw - 1;  //抛出int型异常        else if (m == 0)            throw - 1.0;  //拋出 double 型异常        else            cout &lt;&lt; m / n &lt;&lt; endl;        cout &lt;&lt; &quot;after dividing.&quot; &lt;&lt; endl;    &#125;    catch (double d) &#123;        cout &lt;&lt; &quot;catch (double)&quot; &lt;&lt; d &lt;&lt; endl;    &#125;    catch (...) &#123;        cout &lt;&lt; &quot;catch (...)&quot; &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;finished&quot; &lt;&lt; endl;    return 0;&#125;</code></pre><p>代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。<br><strong>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）。</strong><br>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以<code>在catch里面再throw异常</code>。</p><h3 id="1-27-static的用法和作用？"><a href="#1-27-static的用法和作用？" class="headerlink" title="1.27 static的用法和作用？"></a>1.27 static的用法和作用？</h3><ol><li><p>先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）<br>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</p></li><li><p>static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。</p></li><li><p>static的第三个作用是默认初始化为0（static变量）<br>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。</p></li><li><p>static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；</p></li><li><p>由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问static修饰的类成员；</p></li><li><p>static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this-&gt;vptr-&gt;ctable-&gt;virtual function</p></li></ol><h3 id="1-28-成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？"><a href="#1-28-成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？" class="headerlink" title="1.28 成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"></a>1.28 成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</h3><p>赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化。<br>这两种方式的主要区别在于：</p><ul><li><p>对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。</p></li><li><p>列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。</p></li></ul><h3 id="1-29-有哪些情况必须用到成员列表初始化？作用是什么？"><a href="#1-29-有哪些情况必须用到成员列表初始化？作用是什么？" class="headerlink" title="1.29 有哪些情况必须用到成员列表初始化？作用是什么？"></a>1.29 有哪些情况必须用到成员列表初始化？作用是什么？</h3><ul><li><p><strong>常量成员变量：</strong></p><p>如果类中包含<code>const</code>或者<code>引用类型</code>的成员变量，则必须使用成员列表初始化对它们进行初始化。<br>因为常量成员变量和引用类型成员变量无法在构造函数内部进行赋值，只能通过成员列表初始化来初始化它们。  </p></li><li><p><strong>继承的成员变量：</strong></p><p>如果<code>派生类继承了基类的成员变量，且基类没有默认构造函数</code>，则必须使用成员列表初始化来调用基类的构造函数对基类成员变量进行初始化。  </p></li><li><p><strong>成员对象：</strong></p><p>如果<code>类中包含其他类对象作为成员变量</code>，则最好使用成员列表初始化对这些成员对象进行初始化。<br>这样可以避免在构造函数体内部对成员对象进行默认初始化后再赋值，而直接在构造函数的初始化列表中完成初始化。</p></li></ul><h3 id="1-30-什么是内存泄露，如何检测与避免"><a href="#1-30-什么是内存泄露，如何检测与避免" class="headerlink" title="1.30 什么是内存泄露，如何检测与避免"></a>1.30 什么是内存泄露，如何检测与避免</h3><ul><li><p>内存泄露</p><p>一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了</p></li><li><p>避免内存泄露的几种方式</p><ul><li>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</li><li>一定要将基类的析构函数声明为虚函数</li><li>对象数组的释放一定要用delete []</li><li>有new就有delete，有malloc就有free，保证它们一定成对出现</li></ul></li><li><p>检测工具</p><ul><li>Linux下可以使用Valgrind工具  </li><li>Windows下可以使用CRT库</li></ul></li></ul><h3 id="1-31-对象复用的了解，零拷贝的了解"><a href="#1-31-对象复用的了解，零拷贝的了解" class="headerlink" title="1.31 对象复用的了解，零拷贝的了解"></a>1.31 对象复用的了解，零拷贝的了解</h3><ul><li><p>对象复用：</p><ul><li>对象复用是指在程序执行过程中，重复使用已经创建的对象，而不是频繁地创建新的对象。通过对象复用，可以减少资源的消耗和提高性能。</li><li>对象复用通常适用于那些需要频繁创建和销毁的对象，比如线程池中的线程对象、连接池中的数据库连接等。通过将这些对象创建一次，然后在需要时重复利用，可以避免反复创建对象的开销，提高系统的效率。</li></ul></li><li><p>零拷贝：</p><ul><li>零拷贝是一种优化技术，用于在数据传输过程中减少或消除不必要的数据拷贝操作。通过零拷贝技术，可以提高数据传输的效率和降低系统的负载。</li><li>零拷贝通常应用于文件传输、网络通信等场景中。例如，在网络通信中，零拷贝技术可以避免将数据从用户空间拷贝到内核空间，再从内核空间拷贝到网络缓冲区的过程，而是直接在用户空间和网络缓冲区之间进行数据传输，从而提高了数据传输的效率。</li><li>零拷贝的主要实现有mmap() （内存映射）</li></ul></li></ul><blockquote><p>DMA(Direct Memory Access-直接内存访问)和零拷贝详细介绍 -&gt; <a href="https://zhuanlan.zhihu.com/p/360343446">【linux】图文并茂|彻底搞懂零拷贝（Zero-Copy）技术</a></p></blockquote><h3 id="1-32-C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast"><a href="#1-32-C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast" class="headerlink" title="1.32 C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast &#x2F;dynamic_cast"></a>1.32 C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast &#x2F;dynamic_cast</h3><ul><li><p>reinterpret_cast：</p><ul><li>reinterpret_cast 可以用于将一个指针或引用转换为另一种不同类型的指针或引用。它可以执行任意类型之间的转换，甚至是不兼容的类型。</li><li>reinterpret_cast 对转换的类型没有限制，它不进行类型检查，因此需要谨慎使用。</li><li>reinterpret_cast 主要用于进行底层的类型转换，如指针之间的转换或者将整数类型转换为指针类型等。</li></ul></li><li><p>const_cast：</p><ul><li>const_cast 主要用于去除表达式中的 const 或 volatile 修饰符，以便修改被修饰对象的值。</li><li>const_cast 只能用于去除 const 或 volatile 限定符，不能进行其他类型的转换。</li><li>const_cast 的使用场景通常是在需要对 const 对象进行修改时，或者在调用函数时需要去除函数参数的 const 修饰符。</li></ul></li><li><p>static_cast：</p><ul><li>static_cast 用于执行静态类型转换，可以在编译时进行类型检查，因此比较安全。</li><li>static_cast 可以执行基本类型之间的转换，如整数之间的转换、指针类型之间的转换，以及类之间的上行转换（派生类指针向基类指针的转换）和下行转换（基类指针向派生类指针的转换）。</li><li>static_cast 也可以用于显式调用构造函数和转换构造函数进行类型转换。</li></ul></li><li><p>dynamic_cast：</p><ul><li>dynamic_cast 用于执行动态类型转换，主要用于在运行时进行类型检查和转换，通常用于处理继承关系的类。</li><li>dynamic_cast 只能用于类类型之间的转换，并且其中至少一个类必须具有虚函数。它用于在类层次结构中安全地进行上行转换和下行转换，并且在转换失败时返回 nullptr（对于指针类型）或抛出 std::bad_cast 异常（对于引用类型）。</li></ul></li></ul><h3 id="1-33-写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？"><a href="#1-33-写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？" class="headerlink" title="1.33 写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？"></a>1.33 写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？</h3><p>  coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p><p>  如何使用gdb调试coredump：</p><ul><li>分析core dump：使用调试工具（如gdb）来分析core dump文件。可以通过以下命令来启动gdb并加载core dump文件：  <pre><code class="bash">gdb [可执行文件名] [core文件名]</code></pre></li><li>查看崩溃位置：在gdb中可以使用backtrace命令（简写为bt）来查看程序崩溃时的调用栈，这可以帮助你找到崩溃位置。命令如下：<pre><code class="bash">(gdb) bt</code></pre></li><li>查看变量状态：通过在崩溃位置设置断点，并使用print命令来查看变量的值，可以帮助你理解程序崩溃的原因。例如：<pre><code class="bash">(gdb) break &lt;line_number&gt;(gdb) run(gdb) print &lt;variable_name&gt;</code></pre></li></ul><h3 id="1-34-说说移动构造函数"><a href="#1-34-说说移动构造函数" class="headerlink" title="1.34 说说移动构造函数"></a>1.34 说说移动构造函数</h3><p>移动构造函数是C++11引入的一个特性，它允许在对象的所有权转移时执行高效的资源移动，而不是传统的拷贝。移动构造函数通常用于实现在不再需要源对象的情况下，将其内容“移动”到新创建的对象中，从而避免不必要的内存分配和数据复制。</p><p>移动构造函数的语法如下：</p><pre><code class="c++">class MyClass &#123;public:    // 移动构造函数    MyClass(MyClass&amp;&amp; other) noexcept &#123;        // 在此处执行资源的移动操作        // 将other对象的资源转移到当前对象中    &#125;&#125;;</code></pre><p>在移动构造函数中，参数通常是一个右值引用（通过使用双引号&amp;&amp;），表示将要被移动的对象。关键字<code>noexcept</code>是一个可选的说明符，表示该函数不会抛出异常。这对于某些情况下的优化是有帮助的。</p><p>移动构造函数通常用于以下几种情况：</p><ol><li>当返回临时对象时，避免不必要的拷贝。例如：<pre><code class="c++">MyClass createObject() &#123;    MyClass temp;    // 初始化temp对象    return temp; // 调用移动构造函数而不是拷贝构造函数&#125;</code></pre></li><li>当将一个对象插入容器时，可以使用移动构造函数将对象移入容器中，而不是复制：<pre><code class="c++">std::vector&lt;MyClass&gt; myVector;MyClass obj;myVector.push_back(std::move(obj)); // 使用 std::move 将对象移入容器中</code></pre></li><li>当需要动态分配内存时，可以使用移动语义来避免额外的内存拷贝。</li></ol><h3 id="1-35-C-中将临时变量作为返回值时的处理过程"><a href="#1-35-C-中将临时变量作为返回值时的处理过程" class="headerlink" title="1.35 C++中将临时变量作为返回值时的处理过程"></a>1.35 C++中将临时变量作为返回值时的处理过程</h3><p>首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</p><p>C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit</p><p>由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系</p><p>如果我们需要返回值，一般使用赋值语句就可以了。</p><h3 id="1-36-如何获得结构成员相对于结构开头的字节偏移量"><a href="#1-36-如何获得结构成员相对于结构开头的字节偏移量" class="headerlink" title="1.36 如何获得结构成员相对于结构开头的字节偏移量"></a>1.36 如何获得结构成员相对于结构开头的字节偏移量</h3><p>使用&lt;stddef.h&gt;头文件中的，offsetof宏。</p><pre><code class="C++">#include &lt;cstddef&gt;#include &lt;iostream&gt;struct MyStruct &#123;    int a;    char b;    double c;&#125;;int main() &#123;    std::cout &lt;&lt; &quot;Offset of &#39;a&#39; in MyStruct: &quot; &lt;&lt; offsetof(MyStruct, a) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Offset of &#39;b&#39; in MyStruct: &quot; &lt;&lt; offsetof(MyStruct, b) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;Offset of &#39;c&#39; in MyStruct: &quot; &lt;&lt; offsetof(MyStruct, c) &lt;&lt; std::endl;    return 0;&#125;</code></pre><p>输出：</p><pre><code class="sql">Offset of &#39;a&#39; in MyStruct: 0Offset of &#39;b&#39; in MyStruct: 4Offset of &#39;c&#39; in MyStruct: 8</code></pre><h3 id="1-37-怎样判断两个浮点数是否相等？"><a href="#1-37-怎样判断两个浮点数是否相等？" class="headerlink" title="1.37 怎样判断两个浮点数是否相等？"></a>1.37 怎样判断两个浮点数是否相等？</h3><p>对两个浮点数判断大小和是否相等不能直接用&#x3D;&#x3D;来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过<code>相减并与预先设定的精度比较</code>，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。</p><h3 id="1-38-C-的标准库，STL及std的区别"><a href="#1-38-C-的标准库，STL及std的区别" class="headerlink" title="1.38 C++的标准库，STL及std的区别"></a>1.38 C++的标准库，STL及std的区别</h3><ul><li>std（Standard）</li><li>STL（Standard Template Library）  </li><li>STL是标准模板库，是标准库的子集。主要是容器、算法、迭代器。标准库还包括stream，string等，STL大约占了标准库内容得80%</li><li>std是命名空间的名字，目的是为了避免命名空间污染。模板库（包括stl）的设计者，特意在库文件里面加上了命名空间。这样，我们使用者就可以在定义自己的函数时，定义自己的命名空间。然后在自己定义的命名空间作用域范围内，使用我们自己定义的、但可能和标准库里的函数重名的函数。这样就不会有函数冲突了，使用时注意命名空间的作用域就好了！</li><li>模板库（包括stl，stream,string）中的所有名字的使用都得通过std::。</li></ul><h3 id="1-39-C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"><a href="#1-39-C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？" class="headerlink" title="1.39 C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"></a>1.39 C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</h3><p>在 C++ 中，指针参数传递和引用参数传递都可以用于实现函数之间的参数传递，它们之间有一些区别：</p><ol><li>指针参数传递：  <ul><li>指针参数传递是通过将参数声明为指针类型来实现的。在函数内部，可以通过解引用指针来访问参数所指向的对象。</li><li>指针参数传递需要在函数调用时传递指针的地址，因此需要额外的内存空间存储指针地址。（本质上是值传递，它所传递的是一个地址值。）</li><li>指针参数可以为空（即指向空指针），因此需要在函数内部进行空指针检查，以防止出现空指针异常。</li></ul></li><li>引用参数传递：  <ul><li>引用参数传递是通过将参数声明为引用类型来实现的。在函数内部，引用参数直接绑定到传递给函数的对象上，不需要解引用操作。</li><li>引用参数传递不需要额外的内存空间存储地址，因为引用本身就是目标对象的别名。</li><li>引用参数不能为空，因为引用必须引用一个有效的对象。</li></ul></li></ol><p>底层原理：  </p><ul><li>指针参数传递的底层原理是将指针的值（即地址）传递给函数，函数内部通过解引用指针来访问所指向的对象。</li><li>引用参数传递的底层原理是将引用绑定到传递给函数的对象上，因此在函数内部直接操作引用就相当于操作原始对象。</li></ul><p>总的来说，引用参数传递更加简洁和安全，因为它不需要对空指针进行检查，并且在函数调用时不会产生额外的开销。但是在某些情况下，指针参数传递可能更加灵活，例如需要允许空指针传递的情况。</p><h3 id="1-40-类如何实现只能静态分配和只能动态分配"><a href="#1-40-类如何实现只能静态分配和只能动态分配" class="headerlink" title="1.40 类如何实现只能静态分配和只能动态分配"></a>1.40 类如何实现只能静态分配和只能动态分配</h3><ul><li><strong>只能静态分配的类：</strong><br>如果希望类的对象只能在栈上分配，可以通过禁用类的动态内存分配来实现：<ul><li>删除<code>new</code>和<code>delete</code>运算符的重载</li><li>将它们声明为私有成员，以阻止类的用户使用动态内存分配<pre><code class="cpp">class StaticAllocatedClass &#123;public:    // 禁用 new 和 delete 运算符    void* operator new(std::size_t) = delete;    void operator delete(void*) = delete;&#125;;</code></pre></li></ul></li><li><strong>只能动态分配的类：</strong>  <ul><li>如果希望类的对象只能在堆上分配，可以在类中重载<code>new</code>和<code>delete</code>运算符，并将它们设置为私有或者保护成员，以防止用户直接调用。<pre><code class="cpp">class DynamicAllocatedClass &#123;public:    // 重载 new 和 delete 运算符    void* operator new(std::size_t size) &#123;        return ::operator new(size);    &#125;    void operator delete(void* ptr) &#123;        ::operator delete(ptr);    &#125;private:    // 防止直接创建对象    DynamicAllocatedClass() &#123;&#125;&#125;;</code></pre></li></ul></li></ul><h3 id="1-41-知道C-中的组合吗？它与继承相比有什么优缺点吗？"><a href="#1-41-知道C-中的组合吗？它与继承相比有什么优缺点吗？" class="headerlink" title="1.41 知道C++中的组合吗？它与继承相比有什么优缺点吗？"></a>1.41 知道C++中的组合吗？它与继承相比有什么优缺点吗？</h3><p>在面向对象编程中，组合（Composition）是一种将多个类组合在一起创建新的类的方式。在组合关系中，一个类包含另一个类的实例作为其成员变量，这种关系表达了“具有”的关系，而不是“是一个”的关系。</p><p>与继承相比，组合的优缺点如下：</p><ul><li><p>优点：</p><ul><li>灵活性： 组合关系更灵活，因为它不会限制子类必须继承特定的行为或属性，而是通过组合已有的类来实现新的功能。</li><li>松耦合： 组合关系降低了类之间的耦合度，因为类之间的关系更加简单明确，不会引入不必要的依赖。</li><li>封装性： 组合可以带来更好的封装性，因为组合的类可以选择性地暴露其内部成员，对外部隐藏实现细节。</li><li>易于维护： 组合关系使得代码结构更清晰，易于理解和维护。</li></ul></li><li><p>缺点：</p><ul><li>代码重复： 在组合关系中，如果多个类都需要相同的功能或属性，可能会导致代码重复，增加了代码量和维护成本。</li><li>初始化复杂： 当一个类包含多个其他类的实例作为成员变量时，初始化对象可能变得更加复杂。</li><li>性能开销： 在运行时，由于需要额外的内存分配和对象构造，组合关系可能会引入一定的性能开销。</li></ul></li></ul><p>总的来说，组合关系提供了一种更加灵活和松耦合的方式来构建对象，可以避免继承带来的一些问题，但也需要注意代码重复和初始化复杂性等缺点。选择组合还是继承取决于具体的设计需求和问题领域，需要综合考虑各方面的因素来做出合适的选择。</p><h3 id="1-42-函数指针？"><a href="#1-42-函数指针？" class="headerlink" title="1.42 函数指针？"></a>1.42 函数指针？</h3><p>函数指针是指向函数的指针变量，它存储了函数的地址，可以用来间接地调用函数。在 C 和 C++ 中，函数指针的语法如下：</p><pre><code class="cpp">return_type (*pointer_name)(parameter_types);</code></pre><p>函数指针在 C 和 C++ 中具有多种用途，包括但不限于以下几个方面：</p><ul><li><p>回调函数： 函数指针可以作为参数传递给其他函数，从而实现回调函数的机制。通过回调函数，可以在运行时指定需要调用的函数，从而实现灵活的控制流程。这在事件处理、信号处理等场景中非常常见。</p></li><li><p>动态选择函数： 函数指针可以根据不同的条件动态地选择调用不同的函数，从而实现更灵活的程序逻辑。这种技术常用于状态机、策略模式等场景。</p></li><li><p>实现多态性： 在 C++ 中，函数指针可以用于实现简单的多态性，虽然它不如虚函数表那样灵活，但可以实现类似的功能。通过函数指针，可以在运行时选择不同的函数实现，从而实现对象的多态行为。</p></li><li><p>动态加载库函数： 在动态链接库（DLL）和共享对象（SO）中，函数指针可以用于动态加载库函数，从而实现在运行时加载和调用特定库函数的功能。这在插件系统、动态扩展功能等场景中非常有用。</p></li></ul><h3 id="1-43-为什么要进行内存对齐"><a href="#1-43-为什么要进行内存对齐" class="headerlink" title="1.43 为什么要进行内存对齐"></a>1.43 为什么要进行内存对齐</h3><p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.</p><p>现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。</p><p>假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的连续四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.</p><h3 id="1-44-内存对齐规则"><a href="#1-44-内存对齐规则" class="headerlink" title="1.44 内存对齐规则"></a>1.44 内存对齐规则</h3><ul><li>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认<code>#pragma pack(4)</code>，可以通过预编译命令#pragma pack(n)，n &#x3D; 1,2,4,8,16来改变这一系数。</li></ul><p>有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。</p><p>了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：</p><ul><li><p><strong>基本类型的对齐规则：</strong> 基本数据类型在内存中的存储位置通常要求是其自身大小的整数倍。例如，一个字节大小的字符通常需要对齐到地址为1的位置，一个四字节大小的整数通常需要对齐到地址为4的位置。</p></li><li><p><strong>结构体和类的对齐规则：</strong> 结构体和类的对齐规则是其成员中大小最大的成员大小的整数倍。这样做的目的是为了保证结构体或类的成员都能够按照其自身的对齐要求存储，从而保证结构体或类的实例的起始地址是合法的。</p></li><li><p><strong>指针类型的对齐规则：</strong> 指针类型的大小通常与机器的地址长度相等，因此指针类型的对齐规则通常与基本类型的对齐规则相同。</p></li></ul><h3 id="1-45-static变量"><a href="#1-45-static变量" class="headerlink" title="1.45 static变量"></a>1.45 static变量</h3><p>静态变量是在程序执行期间存在且只初始化一次的变量，它的生存周期与程序的运行周期相同。在C和C++中，静态变量可以分为两种类型：</p><ul><li><p>局部静态变量（Static Local Variable）： 在函数内部声明的静态变量称为局部静态变量。这些变量在函数被调用时被创建，在程序的整个生命周期内保持存在，并且只被初始化一次。局部静态变量的作用域仅限于声明它们的函数内部。</p><pre><code class="cpp">void func() &#123;    static int count = 0; // 局部静态变量    count++;    printf(&quot;Count: %d\n&quot;, count);&#125;</code></pre></li><li><p>全局静态变量（Static Global Variable）： 在函数外部声明的静态变量称为全局静态变量。这些变量在程序启动时被创建，在程序的整个生命周期内保持存在，并且只被初始化一次。全局静态变量的作用域为<code>整个文件</code>，对其他文件不可见（除非使用<code>extern</code>关键字进行声明）。</p><pre><code class="cpp">static int globalVar = 5; // 全局静态变量</code></pre></li><li><p>静态变量的特点包括：</p><ul><li>在内存中分配固定的存储空间，存储在静态存储区域。</li><li>生命周期与程序运行周期相同，程序结束时才被销毁。</li><li>未初始化时，默认值为0。</li><li>局部静态变量在函数内部可见，全局静态变量在整个文件内可见。</li><li>静态变量的值在函数调用之间保持不变。</li><li>静态变量在程序中的应用包括：存储全局状态、实现单例模式、记录函数调用次数等。由于静态变量的生存周期和作用域特性，它们通常用于需要持久存储数据的情况。</li></ul></li></ul><h3 id="1-46-extern和static"><a href="#1-46-extern和static" class="headerlink" title="1.46 extern和static"></a>1.46 extern和static</h3><p><code>extern</code>和<code>static</code>都是用来限定变量或函数的作用域和链接属性的关键字，但它们的作用方式有所不同。</p><ul><li><p>extern：</p><ul><li><p>extern 用于声明变量或函数，表示该变量或函数是在其他源文件中定义的，当前源文件中只是进行了声明，实际定义在其他地方。</p></li><li><p>当使用 extern 声明变量时，编译器不会为该变量分配存储空间，只是告诉编译器该变量是在其他地方定义的。</p></li><li><p>extern 声明通常用于在多个源文件中共享全局变量或函数的声明。</p></li></ul><p>例如：</p><pre><code class="cpp">// File1.cppint globalVar = 5; // 定义全局变量// File2.cppextern int globalVar; // 声明全局变量</code></pre></li><li><p>static：</p><ul><li><p>static 用于声明静态变量或函数，限定其作用域为当前文件，在其他文件中无法访问。</p></li><li><p>当使用 static 声明变量或函数时，它们的作用域仅限于当前源文件，对其他源文件不可见。</p></li><li><p>对于全局变量，static 关键字也可以用于限定其链接属性，使其只能在当前文件中访问，称为文件作用域全局变量。</p></li></ul><p>例如：</p><pre><code class="cpp">// File1.cppstatic int localVar = 10; // 声明文件作用域的静态变量// File2.cpp// 在 File2.cpp 中无法访问 localVar</code></pre></li></ul><p>总结：</p><ul><li><p>extern 用于声明外部变量或函数，使得在当前文件中可以引用其他文件中定义的全局变量或函数。</p></li><li><p>static 用于限定变量或函数的作用域为当前文件，使得它们只能在当前文件中可见，对其他文件不可见。</p></li></ul><h3 id="1-47-如何在不使用额外空间的情况下，交换两个数？你有几种方法"><a href="#1-47-如何在不使用额外空间的情况下，交换两个数？你有几种方法" class="headerlink" title="1.47 如何在不使用额外空间的情况下，交换两个数？你有几种方法"></a>1.47 如何在不使用额外空间的情况下，交换两个数？你有几种方法</h3><ol><li>使用加法和减法：<pre><code class="cpp">a = a + b;b = a - b;a = a - b;</code></pre></li><li>使用异或操作：<pre><code class="cpp">a = a ^ b;b = a ^ b;a = a ^ b;</code></pre></li><li>使用加法和位移：<pre><code class="cpp">a = a + b;b = a - b;a = (a - b) &gt;&gt; 1;</code></pre></li><li>使用乘法和除法：<pre><code class="cpp">a = a * b;b = a / b;a = a / b;</code></pre></li></ol><p>这些方法都是在不使用额外空间的情况下，通过数学运算来交换两个数的值。其中，使用异或操作是最常见的方法，因为它既简单又高效。</p><h3 id="1-48-strcpy-和-memcpy-的区别"><a href="#1-48-strcpy-和-memcpy-的区别" class="headerlink" title="1.48 strcpy 和 memcpy 的区别"></a>1.48 strcpy 和 memcpy 的区别</h3><ol><li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 </li><li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 </li><li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li></ol><h3 id="1-49-程序在执行int-main-int-argc-char-argv-时的内存结构"><a href="#1-49-程序在执行int-main-int-argc-char-argv-时的内存结构" class="headerlink" title="1.49 程序在执行int main(int argc, char *argv[])时的内存结构"></a>1.49 程序在执行int main(int argc, char *argv[])时的内存结构</h3><p>参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针</p><p><code>char *</code>指向的内存中，数组的中元素的个数为<code>argc</code>个，第一个参数为<code>程序的名称</code>。</p><h3 id="1-50-volatile关键字的作用？"><a href="#1-50-volatile关键字的作用？" class="headerlink" title="1.50 volatile关键字的作用？"></a>1.50 volatile关键字的作用？</h3><p><code>volatile</code>关键字用于告诉编译器，被 volatile 修饰的变量可能会在程序执行过程中被意外修改，因此编译器不应该对这些变量进行优化。</p><p>具体来说，volatile 关键字的作用包括：</p><ul><li><p><code>防止编译器优化</code>： 声明变量为 volatile 后，编译器会将对该变量的访问、赋值等操作视为有可能受到外部因素影响，因此不会对这些操作进行优化，确保编译后的代码与源代码中的操作顺序一致。</p></li><li><p><code>指示变量可能被多线程或中断处理程序修改</code>： 在多线程或中断处理程序的环境中，某些变量的值可能会被其他线程或中断处理程序修改，而这些修改对于程序的正确执行具有重要影响。通过使用 volatile 关键字，可以告诉编译器这些变量的值可能会在程序执行过程中被修改，因此需要每次访问都重新从内存中读取值，而不是使用缓存中的值。</p></li></ul><p><code>volatile</code>关键字通常在以下情况下使用：</p><ol><li><p><code>硬件操作或内存映射</code>： 当变量代表硬件寄存器或内存映射的状态时，可能会被外部设备或中断处理程序修改。在这种情况下，将变量声明为 volatile 可以确保编译器不会对其进行优化，以防止意外的行为。</p></li><li><p><code>多线程环境下共享变量</code>： 在多线程程序中，共享变量可能会被多个线程同时访问和修改。如果这些变量没有使用同步机制进行保护，那么在读取和写入这些变量时可能会发生竞态条件。在这种情况下，将共享变量声明为 volatile 可以告诉编译器不要对其进行优化，以确保每次访问都是从内存中读取最新值。</p></li><li><p><code>信号处理程序中使用的全局变量</code>： 在信号处理程序中，全局变量的值可能会在程序的正常执行流程之外被修改。为了确保信号处理程序能够正确地读取和修改这些变量，通常会将它们声明为 volatile。</p></li></ol><h3 id="1-51-如果有一个空类，它会默认添加哪些函数？"><a href="#1-51-如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="1.51 如果有一个空类，它会默认添加哪些函数？"></a>1.51 如果有一个空类，它会默认添加哪些函数？</h3><pre><code class="C++">MyClass(); // 缺省构造函数MyClass( const MyClass&amp; ); // 拷贝构造函数~MyClass(); // 析构函数MyClass&amp; operator=( const MyClass&amp; ); // 赋值运算符</code></pre><h3 id="1-52-说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#1-52-说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="1.52 说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>1.52 说一说strcpy、sprintf与memcpy这三个函数的不同之处</h3><ol><li><strong>操作对象不同</strong></li></ol><ul><li><p>strcpy的两个操作对象均为字符串</p></li><li><p>sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串</p></li><li><p>memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</p></li></ul><ol start="2"><li><p><strong>执行效率不同</strong><br>memcpy最高，strcpy次之，sprintf的效率最低。</p></li><li><p><strong>实现功能不同</strong></p></li></ol><ul><li><p>strcpy主要实现字符串变量间的拷贝</p></li><li><p>sprintf主要实现其他数据类型格式到字符串的转化</p></li><li><p>memcpy主要是内存块间的拷贝</p></li></ul><h3 id="1-53-如何阻止一个类被实例化？有哪些方法"><a href="#1-53-如何阻止一个类被实例化？有哪些方法" class="headerlink" title="1.53 如何阻止一个类被实例化？有哪些方法"></a>1.53 如何阻止一个类被实例化？有哪些方法</h3><ol><li><code>将构造函数声明为私有（private）</code>： 将类的构造函数声明为私有，这样外部代码就无法直接调用该构造函数实例化对象。但是需要注意的是，类的静态成员函数仍然可以访问私有构造函数，因此可以在类的静态成员函数中实现对象的创建，从而控制对象的实例化。</li><li><code>删除构造函数的定义</code>： C++11 引入了删除函数的特性，可以通过将构造函数的定义删除来阻止对象的实例化。删除构造函数的定义后，任何尝试调用该构造函数的操作都会导致编译错误。</li><li><code>将构造函数声明为纯虚函数</code>： 将构造函数声明为纯虚函数，这样派生类必须实现自己的构造函数，而基类则无法被实例化。</li></ol><h3 id="1-54-strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#1-54-strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="1.54 strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>1.54 strcpy函数和strncpy函数的区别？哪个函数更安全？</h3><ul><li><code>strcpy</code>：<ul><li>函数原型：char *strcpy(char *dest, const char *src);  </li><li>功能：将源字符串（以空字符结尾）拷贝到目标字符串中，包括空字符。</li><li>安全性：strcpy 不检查目标字符串的长度，如果源字符串比目标字符串长，可能会发生缓冲区溢出，导致未定义的行为。</li></ul></li><li><code>strncpy</code>：<ul><li>函数原型：char *strncpy(char *dest, const char *src, size_t n);</li><li>功能：将源字符串的前 n 个字符拷贝到目标字符串中，如果源字符串长度小于 n，则在目标字符串中用空字符填充剩余部分。</li><li>安全性：相比于 strcpy，strncpy 更安全，因为它可以指定拷贝的最大长度，避免了缓冲区溢出的风险。但需要注意，如果源字符串的长度大于 n，则目标字符串不会以空字符结尾，因此可能需要<code>手动添加空字符</code>。</li></ul></li></ul><p>因此，从安全性的角度来看，strncpy 更安全一些，但需要确保目标字符串足够大以容纳指定长度的内容。另外，使用 strncpy 时应格外小心，确保目标字符串始终以空字符结尾，以避免字符串操作中出现意外行为。</p><h3 id="1-55-写一个比较大小的模板函数"><a href="#1-55-写一个比较大小的模板函数" class="headerlink" title="1.55 写一个比较大小的模板函数"></a>1.55 写一个比较大小的模板函数</h3><pre><code class="C++">template &lt;typename T&gt;T max(T a, T b)&#123;  return a &gt; b ? a : b;&#125;</code></pre><h3 id="1-56-成员函数里memset-this-0-sizeof-this-会发生什么"><a href="#1-56-成员函数里memset-this-0-sizeof-this-会发生什么" class="headerlink" title="1.56 成员函数里memset(this,0,sizeof(*this))会发生什么"></a>1.56 成员函数里memset(this,0,sizeof(*this))会发生什么</h3><p>在成员函数中调用<code>memset(this, 0, sizeof(*this))</code>将会把当前对象所占内存的前<code>sizeof(*this)</code>字节全部设置为零。这样做会将对象的所有成员变量都设置为零值，但这种做法可能会导致一些问题，特别是对于<code>含有虚函数或虚继承的类</code>。</p><p>具体来说，<code>memset</code>函数是用来将一段内存块设置为指定的值的，但它只是简单地按字节设置，对于非 POD（Plain Old Data）类型的对象，这种简单的内存设置可能会导致对象中的某些数据结构被破坏，从而导致程序出错。</p><p>对于含有虚函数的类，调用<code>memset</code>可能会破坏虚<code>函数表（vtable）指针</code>，导致虚函数调用出错。对于含有虚继承的类，调用<code>memset</code>会破坏<code>虚基类指针（vptr）</code>，同样会导致程序出错。</p><p>因此，一般情况下不建议在成员函数中直接使用 memset 来清零对象的内存，而是应该使用更安全的方式来初始化对象的成员变量。</p><h3 id="1-57-C-从代码到可执行程序经历了什么"><a href="#1-57-C-从代码到可执行程序经历了什么" class="headerlink" title="1.57 C++从代码到可执行程序经历了什么"></a>1.57 C++从代码到可执行程序经历了什么</h3><ol><li><p><strong>编写代码</strong>：首先，程序员编写C++源代码，这些代码通常包含在一个或多个源文件中。</p></li><li><p><strong>预处理</strong>：在编译之前，源代码经过预处理器处理。预处理器执行诸如<code>宏替换</code>、<code>条件编译</code>等操作，生成经过预处理的源代码文件。</p></li><li><p><strong>编译</strong>：编译器将预处理后的源代码转换为汇编代码。这个阶段的任务是将高级语言代码转换为机器语言代码，生成相应的目标文件。</p></li><li><p><strong>汇编</strong>：汇编器将汇编代码转换为机器可执行的二进制代码。它将每条汇编指令翻译成机器指令，并生成目标文件。</p></li><li><p><strong>链接</strong>：链接器将生成的目标文件与所需的库文件链接在一起，创建一个完整的可执行程序。它解析程序中使用的符号引用，将它们与符号定义关联起来，并解决外部符号的引用。最终，链接器产生一个可执行文件，其中包含程序的所有指令和数据。</p></li><li><p><strong>优化</strong>：在编译和链接过程中，还可以应用各种优化技术来提高程序的性能和效率。这些优化包括但不限于代码优化、内联函数、循环优化等。</p></li><li><p><strong>生成可执行文件</strong>：经过链接和优化后，最终生成可执行文件，即可以在特定平台上运行的二进制文件。这个可执行文件包含了程序的所有代码和数据，可以直接在计算机上执行。</p></li><li><p><strong>运行程序</strong>：最终，用户可以运行生成的可执行程序，执行程序中定义的操作和功能。</p></li></ol><p>这些步骤通常由编译器和链接器自动完成，用户只需要编写和调试源代码即可。</p><h3 id="1-58-友元函数和友元类"><a href="#1-58-友元函数和友元类" class="headerlink" title="1.58 友元函数和友元类"></a>1.58 友元函数和友元类</h3><p>在C++中，友元函数和友元类是用来提供对类的私有成员的访问权限的机制，它们可以访问类的私有成员，即使这些成员在类的定义中被声明为私有的也可以。它们的区别在于：</p><ul><li>友元函数：友元函数是在类的外部声明的普通函数，可以访问类的所有成员。要声明一个函数为类的友元函数，需要在类的定义中使用 friend 关键字来声明。友元函数并不属于类的成员函数，它们可以通过对象或类名来调用。<pre><code class="cpp">class MyClass &#123;    friend void friendFunction();private:    int privateMember;&#125;;void friendFunction() &#123;    MyClass obj;    obj.privateMember = 10; // 可以访问私有成员&#125;</code></pre></li><li>友元类：友元类是指一个类可以访问另一个类的私有成员。同样地，在类的定义中使用 friend 关键字来声明一个类为友元类。友元类可以访问被声明为友元类的类的所有成员，包括私有成员和保护成员。<pre><code class="cpp">class MyClass &#123;    friend class FriendClass;private:    int privateMember;&#125;;class FriendClass &#123;public:    void accessPrivateMember(MyClass&amp; obj) &#123;        obj.privateMember = 10; // 可以访问私有成员    &#125;&#125;;</code></pre></li></ul><p>友元函数和友元类的使用可以提供更灵活的访问控制，但同时也会破坏了类的封装性，因此应该谨慎使用。</p><h3 id="1-59-自旋锁"><a href="#1-59-自旋锁" class="headerlink" title="1.59 自旋锁"></a>1.59 自旋锁</h3><p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p><h3 id="1-60-为什么C-没有垃圾回收机制？这点跟Java不太一样。"><a href="#1-60-为什么C-没有垃圾回收机制？这点跟Java不太一样。" class="headerlink" title="1.60 为什么C++没有垃圾回收机制？这点跟Java不太一样。"></a>1.60 为什么C++没有垃圾回收机制？这点跟Java不太一样。</h3><ul><li>实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。</li><li>垃圾回收会使得C++不适合进行很多底层的操作。</li></ul><h2 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h2><h3 id="2-1-简要说明C-的内存分区"><a href="#2-1-简要说明C-的内存分区" class="headerlink" title="2.1 简要说明C++的内存分区"></a>2.1 简要说明C++的内存分区</h3><p>C++中的内存分区，分别是堆、栈、自由存储区、全局&#x2F;静态存储区、常量存储区和代码区。  </p><ul><li><p><strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p></li><li><p><strong>堆</strong>：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete。<code>如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</code></p></li><li><p><strong>自由存储区</strong>：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，<code>自由存储区和堆比较像，但不等价</code></p></li><li><p><strong>全局&#x2F;静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，<code>在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</code></p></li><li><p><strong>常量存储区</strong>：这是一块比较特殊的存储区，这里面存放的是常量，<code>不允许修改</code></p></li><li><p><strong>代码区</strong>：存放函数体的二进制代码</p></li></ul><h3 id="2-2-什么是内存池，如何实现"><a href="#2-2-什么是内存池，如何实现" class="headerlink" title="2.2 什么是内存池，如何实现"></a>2.2 什么是内存池，如何实现</h3><p>内存池（Memory Pool） 是一种内存分配方式。通常我们习惯直接使用new、malloc 等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。</p><pre><code class="cpp">// 内存池#include &quot;list&quot;class MemoryPool&#123;private:    std::list&lt;char*&gt; m_blocks;    unsigned int m_bloackNum;public:    MemoryPool(size_t size, unsigned int num)&#123;        m_bloackNum = num;        for(unsigned int i = 0; i &lt; num; ++i)&#123;            m_blocks.push_back(new char[size]);        &#125;    &#125;    ~MemoryPool()&#123;        for(auto b : m_blocks)&#123;            delete[] b;            b = nullptr;        &#125;    &#125;    char* allocate()&#123;        if(m_blocks.empty())&#123;            throw std::bad_alloc();        &#125;        char* b = m_blocks.front();        m_blocks.pop_front();        return b;    &#125;    void deallocate(void* block)&#123;        m_blocks.push_back(static_cast&lt;char*&gt;(block));    &#125;&#125;;</code></pre><h3 id="2-3-几个this指针的易混问题"><a href="#2-3-几个this指针的易混问题" class="headerlink" title="2.3 几个this指针的易混问题"></a>2.3 几个this指针的易混问题</h3><ul><li><p><strong>this指针是什么时候创建的？</strong><br>this在成员函数的开始执行前构造，在成员的执行结束后清除。</p></li><li><p><strong>this指针存放在何处？堆、栈、全局变量，还是其他？</strong><br>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。</p></li><li><p><strong>每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</strong><br>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。</p></li></ul><h3 id="2-4-内存泄漏的后果？如何监测？解决方法？"><a href="#2-4-内存泄漏的后果？如何监测？解决方法？" class="headerlink" title="2.4 内存泄漏的后果？如何监测？解决方法？"></a>2.4 内存泄漏的后果？如何监测？解决方法？</h3><ul><li>后果<br>只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种症状：性能下降到内存逐渐用完，导致另一个程序失败；  </li><li>如何监测<br>使用专门的内存泄漏检测工具，例如Valgrind、AddressSanitizer、LeakSanitizer等，这些工具能够帮助检测程序中的内存泄漏问题，并给出详细的报告和堆栈信息。</li><li>解决方法<br>智能指针。代码审查。</li></ul><h3 id="2-5-在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#2-5-在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="2.5 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>2.5 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h3><p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</p><blockquote><p><strong>为什么是不可预期的问题？</strong><br>delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p></blockquote><h3 id="2-6-如果在类的析构函数中调用delete-this，会发生什么？"><a href="#2-6-如果在类的析构函数中调用delete-this，会发生什么？" class="headerlink" title="2.6 如果在类的析构函数中调用delete this，会发生什么？"></a>2.6 如果在类的析构函数中调用delete this，会发生什么？</h3><p>可能会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p><h3 id="2-7-请说一下以下几种情况下，下面几个类的大小各是多少？"><a href="#2-7-请说一下以下几种情况下，下面几个类的大小各是多少？" class="headerlink" title="2.7 请说一下以下几种情况下，下面几个类的大小各是多少？"></a>2.7 请说一下以下几种情况下，下面几个类的大小各是多少？</h3><pre><code class="cpp">class A &#123;&#125;;int main()&#123;  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1;  A a;   cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1;  return 0;&#125;/*空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。*/</code></pre><pre><code class="cpp">class A &#123; virtual void Fun()&#123;&#125; &#125;;int main()&#123;  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器);  A a;   cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器);  return 0;&#125;// 因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节</code></pre><pre><code class="cpp">class A &#123; static int a; &#125;;int main()&#123;  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1;  A a;   cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1;  return 0;&#125;// 静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</code></pre><pre><code class="cpp">class A &#123; int a; &#125;;int main()&#123;  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4;  A a;   cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4;  return 0;&#125;</code></pre><h3 id="2-8-类对象的大小受哪些因素影响？"><a href="#2-8-类对象的大小受哪些因素影响？" class="headerlink" title="2.8 类对象的大小受哪些因素影响？"></a>2.8 类对象的大小受哪些因素影响？</h3><ul><li><p>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</p></li><li><p>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</p></li><li><p>虚函数的话，会在类对象插入vptr指针，加上指针大小；</p></li><li><p>当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。</p></li></ul><h2 id="三、C-11新标准"><a href="#三、C-11新标准" class="headerlink" title="三、C++11新标准"></a>三、C++11新标准</h2><h3 id="3-1-C-11有哪些新特性？"><a href="#3-1-C-11有哪些新特性？" class="headerlink" title="3.1 C++ 11有哪些新特性？"></a>3.1 C++ 11有哪些新特性？</h3><ul><li>nullptr替代 NULL</li><li>引入了 auto 和 decltype 这两个关键字实现了类型推导</li><li>基于范围的 for 循环for(auto&amp; i : res){}</li><li>类和结构体的中初始化列表</li><li>Lambda 表达式（匿名函数）</li><li>std::forward_list（单向链表）</li><li>右值引用和move语义</li><li>…</li></ul><h3 id="3-2-智能指针的原理、常用的智能指针及实现"><a href="#3-2-智能指针的原理、常用的智能指针及实现" class="headerlink" title="3.2 智能指针的原理、常用的智能指针及实现"></a>3.2 智能指针的原理、常用的智能指针及实现</h3><ul><li><p><strong>原理</strong><br>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源</p></li><li><p><strong>常用的智能指针</strong>  </p><ul><li><p><strong>unique_ptr</strong><br>它是一种独占所有权的智能指针，即它不能被复制或拷贝。当unique_ptr被销毁时，它所指向的对象会被自动释放。这使得unique_ptr非常适合管理动态分配的单个对象。</p></li><li><p><strong>shared_ptr</strong><br>它是一种共享所有权的智能指针，可以被多个shared_ptr共享同一个对象。它使用引用计数来跟踪指向对象的指针数量，并在没有指针指向对象时自动释放对象。当最后一个shared_ptr销毁时，对象会被释放。</p></li><li><p><strong>weak_ptr</strong><br>它是一种弱引用的智能指针，用于解决shared_ptr的循环引用问题。weak_ptr可以从shared_ptr创建，但不会增加引用计数。因此，它不会阻止对象的销毁。通常在需要访问shared_ptr所管理的对象，但又不需要拥有所有权时使用。</p></li><li><p><strong>auto_ptr（C++11之前）</strong><br>它是早期版本的C++标准中提供的智能指针，类似于unique_ptr，但具有一些缺陷，并在C++11中被std::unique_ptr取代。auto_ptr没有明确定义的行为来处理拷贝和赋值操作，因此容易导致问题。</p></li></ul></li><li><p><strong>智能指针shared_ptr代码实现</strong></p></li></ul><pre><code class="cpp">template&lt;typename T&gt;class SharedPtr&#123;public:    SharedPtr(T* ptr = NULL):_ptr(ptr), _pcount(new int(1))    &#123;&#125;    SharedPtr(const SharedPtr&amp; s):_ptr(s._ptr), _pcount(s._pcount)&#123;        (*_pcount)++;    &#125;    SharedPtr&lt;T&gt;&amp; operator=(const SharedPtr&amp; s)&#123;        if (this != &amp;s)        &#123;            if (--(*(this-&gt;_pcount)) == 0)            &#123;                delete this-&gt;_ptr;                delete this-&gt;_pcount;            &#125;            _ptr = s._ptr;            _pcount = s._pcount;            (*_pcount)++;        &#125;        return *this;    &#125;    T&amp; operator*()    &#123;        return *(this-&gt;_ptr);    &#125;    T* operator-&gt;()    &#123;        return this-&gt;_ptr;    &#125;    ~SharedPtr()    &#123;        --(*(this-&gt;_pcount));        if (*(this-&gt;_pcount) == 0)        &#123;            delete _ptr;            _ptr = NULL;            delete _pcount;            _pcount = NULL;        &#125;    &#125;private:    T* _ptr;    int* _pcount;//指向引用计数的指针&#125;;</code></pre><h3 id="3-3-lambda函数"><a href="#3-3-lambda函数" class="headerlink" title="3.3 lambda函数"></a>3.3 lambda函数</h3><pre><code class="cpp">[capture-list] (parameter-list) -&gt; return-type &#123;    // 函数体&#125;</code></pre><ul><li>capture-list：捕获列表，用于捕获外部变量。可以是值传递方式（[var]）或引用传递方式（[&amp;var]）。还可以使用[&#x3D;]表示以值传递方式捕获所有外部变量，或使用[&amp;]表示以引用传递方式捕获所有外部变量。</li><li>parameter-list：参数列表，与普通函数的参数列表类似。</li><li>return-type：返回类型，可以省略，编译器会根据返回语句自动推断返回类型。</li><li>{}：函数体，与普通函数的函数体类似。</li></ul><pre><code class="cpp">#include &lt;iostream&gt;int main() &#123;    // Lambda表达式求两个数的和    auto sum = [](int a, int b) -&gt; int &#123;        return a + b;    &#125;;    // 调用lambda表达式    int result = sum(3, 4);    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; result &lt;&lt; std::endl;    return 0;&#125;</code></pre><h3 id="3-4-shared-ptr的循环引用问题"><a href="#3-4-shared-ptr的循环引用问题" class="headerlink" title="3.4 shared_ptr的循环引用问题"></a>3.4 shared_ptr的循环引用问题</h3><p>当两个对象相互引用并使用<code>shared_ptr</code>时，就会形成循环引用。例如，考虑一个简单的场景：</p><pre><code class="cpp">#include &lt;memory&gt;#include &lt;iostream&gt;class B; // 前置声明class A &#123;public:    std::shared_ptr&lt;B&gt; b_ptr;    A() &#123; std::cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; std::endl; &#125;    ~A() &#123; std::cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; std::endl; &#125;&#125;;class B &#123;public:    std::shared_ptr&lt;A&gt; a_ptr;    B() &#123; std::cout &lt;&lt; &quot;B constructor&quot; &lt;&lt; std::endl; &#125;    ~B() &#123; std::cout &lt;&lt; &quot;B destructor&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123;    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;();    std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;();        a-&gt;b_ptr = b;    b-&gt;a_ptr = a;    return 0;&#125;</code></pre><p>在这个例子中，类 <code>A</code> 拥有一个指向类 <code>B</code> 的 <code>shared_ptr</code>，而类 <code>B</code> 拥有一个指向类 <code>A</code> 的 <code>shared_ptr</code>。这样就形成了循环引用。</p><p>为了避免循环引用，我们可以改用 <code>weak_ptr</code> 来解决这个问题：</p><pre><code class="cpp">#include &lt;memory&gt;#include &lt;iostream&gt;class B; // 前置声明class A &#123;public:    std::shared_ptr&lt;B&gt; b_ptr;    A() &#123; std::cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; std::endl; &#125;    ~A() &#123; std::cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; std::endl; &#125;&#125;;class B &#123;public:    std::weak_ptr&lt;A&gt; a_weak_ptr;  // 使用 weak_ptr    B() &#123; std::cout &lt;&lt; &quot;B constructor&quot; &lt;&lt; std::endl; &#125;    ~B() &#123; std::cout &lt;&lt; &quot;B destructor&quot; &lt;&lt; std::endl; &#125;&#125;;int main() &#123;    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;();    std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;();        a-&gt;b_ptr = b;    b-&gt;a_weak_ptr = a;  // 使用 weak_ptr    return 0;&#125;</code></pre><p>通过将类 <code>B</code> 中指向类 <code>A</code> 的指针改为 <code>weak_ptr</code>，我们成功地避免了循环引用问题。</p><h2 id="四、STL"><a href="#四、STL" class="headerlink" title="四、STL"></a>四、STL</h2><h3 id="4-1-什么是STL"><a href="#4-1-什么是STL" class="headerlink" title="4.1 什么是STL"></a>4.1 什么是STL</h3><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p><ul><li>算法包括排序，复制等常用算法，以及不同容器特定的算法。</li><li>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</li><li>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。</li></ul><h3 id="4-2-使用智能指针管理内存资源，RAII是怎么回事？"><a href="#4-2-使用智能指针管理内存资源，RAII是怎么回事？" class="headerlink" title="4.2 使用智能指针管理内存资源，RAII是怎么回事？"></a>4.2 使用智能指针管理内存资源，RAII是怎么回事？</h3><p>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。<br>因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</p><p>智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。<br>毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</p><h3 id="4-3-迭代器：-it、it-哪个好，为什么"><a href="#4-3-迭代器：-it、it-哪个好，为什么" class="headerlink" title="4.3 迭代器：++it、it++哪个好，为什么"></a>4.3 迭代器：++it、it++哪个好，为什么</h3><p>前置返回一个引用，后置返回一个对象</p><ul><li>++i实现代码为：</li></ul><pre><code class="cpp">int&amp; operator++()&#123;  *this += 1;  return *this;&#125; </code></pre><p>前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低</p><ul><li>i++实现代码为：</li></ul><pre><code class="cpp">int operator++(int)                 &#123;  int temp = *this;                     ++*this;                         return temp;                  &#125; </code></pre><p>对于大多数现代编译器来说，在合适的情况下，它们可能会对代码进行优化，包括将后置自增 it++ 转换为前置自增 ++it。但是，这种优化是否发生取决于编译器的实现以及优化级别。</p><h3 id="4-4-右值"><a href="#4-4-右值" class="headerlink" title="4.4 右值"></a>4.4 右值</h3><p>C++11引入了右值引用，用来支持移动语义和完美转发。</p><ol><li>移动语义：传统的复制操作需要额外的时间和空间，而有了移动语义后，可以直接将资源（如内存）从一个对象转移到另一个对象，而不必创建并删除临时对象。这对于大对象或者拥有独占所有权资源的对象特别有用。例如，unique_ptr和std::vector等STL容器就利用了移动语义实现了高效的操作。</li><li>完美转发：在函数模板中，我们想把参数原封不动地传递给其他函数。由于传参可能存在值传递、左值引用、常量左值引用、右值引用等情况，为了保证参数的属性和类型不发生变化，我们需要使用std::forward实现完美转发。</li></ol><p>右值引用主要用于两种场景：一是对象的移动（Move），二是万能引用（Forwarding Reference）。对于第一种情况，它是为了解决对象的复制效率问题；对于第二种情况，则是为了实现参数的完美传递，避免不必要的拷贝。</p><h3 id="4-5-简单说一下traits技法"><a href="#4-5-简单说一下traits技法" class="headerlink" title="4.5 简单说一下traits技法"></a>4.5 简单说一下traits技法</h3><p>Traits 技法是一种在编程中使用的模式，用于实现泛型编程和类型参数化。它的基本思想是将类型的某些特性（或特征）提取出来，并将其定义为独立的类或结构体，然后通过模板或泛型编程技术将这些特性与具体的类型进行关联。</p><p>Traits 技法的主要目的是将类型的行为和属性与类型本身解耦，使得代码更具灵活性和可重用性。通过定义一组通用的接口或函数，可以将这些接口或函数应用于不同的类型，而无需对每种类型都进行单独的实现。</p><p>在 C++ 中，Traits 技法通常通过模板编程来实现。可以定义一组模板类或结构体，用于描述类型的特性，然后在模板函数或模板类中使用这些特性。通过特化或偏特化，可以针对不同类型提供不同的实现，从而实现更高级的泛型编程。</p><p>例如，在 C++ 中，STL 中的迭代器就是一种典型的 Traits 技法的应用。迭代器通过一组接口描述了迭代器的特性，然后通过模板函数和模板类来处理不同类型的迭代器，而无需知道具体的迭代器类型。这种设计使得算法可以与任何支持相应接口的迭代器一起使用，从而提高了代码的灵活性和可重用性。</p><h3 id="4-6-STL的两级空间配置器"><a href="#4-6-STL的两级空间配置器" class="headerlink" title="4.6 STL的两级空间配置器"></a>4.6 STL的两级空间配置器</h3><p>STL（Standard Template Library）的空间配置器是用于在堆上分配内存的组件，它们被用来支持STL容器（如vector、list、map等）的内存管理。STL中的空间配置器通常包括单级空间配置器和双级空间配置器。</p><p>双级空间配置器由两部分组成：</p><ol><li><p>第一级空间配置器（第一级分配器）：使用malloc和free等全局内存分配函数来分配内存。这一级的分配器适用于大块内存的分配，它通过调用全局的malloc和free函数来分配和释放内存，通常是通过模板参数指定的分配策略来实现。</p></li><li><p>第二级空间配置器（第二级分配器）：由于第一级空间配置器在处理小块内存时效率较低，因此第二级空间配置器通常会对小块内存进行优化，它通常使用内存池等技术来管理和分配小块内存，以提高内存分配和释放的效率。</p></li></ol><p>双级空间配置器的设计可以在大块内存和小块内存之间取得平衡，从而在不同大小的内存分配场景中提供更好的性能和效率。这种设计使得STL容器在不同的内存分配场景下都能够有效地工作，并且具有较好的性能表现。</p><h3 id="4-7-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"><a href="#4-7-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素" class="headerlink" title="4.7 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"></a>4.7 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素</h3><ul><li><p><strong>vector数据结构</strong>  </p><ul><li>vector和<code>数组</code>类似，拥有一段连续的内存空间，并且起始地址不变。因此能高效的进行随机存取，时间复杂度为o(1);但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。</li><li>当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。连续存储结构：vector是可以实现动态增长的对象数组，支持对数组高效率的访问和在数组尾端的删除和插入操作，在中间和头部删除和插入相对不易，需要挪动大量的数据。</li><li>它与数组最大的区别就是vector不需程序员自己去考虑容量问题，库里面本身已经实现了容量的动态增长，而数组需要程序员手动写入扩容函数进形扩容。</li></ul></li><li><p><strong>list数据结构</strong>  </p><ul><li>list是由<code>双向链表</code>实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);但由于链表的特点，能高效地进行插入和删除。非连续存储结构：list是一个双链表结构，支持对链表的双向遍历。每个节点包括三个信息：元素本身，指向前一个元素的节点（prev）和指向下一个元素的节点（next）。因此list可以高效率的对数据元素任意位置进行访问和插入删除等操作。由于涉及对额外指针的维护，所以开销比较大。<br>区别：</li></ul></li></ul><p>vector的随机访问效率高，但在插入和删除时（不包括尾部）需要挪动数据，不易操作。<br>list的访问要遍历整个链表，它的随机访问效率低。但对数据的插入和删除操作等都比较方便，改变指针的指向即可。</p><p>从遍历上来说，list是单向的，vector是双向的。<br>vector中的迭代器在使用后就失效了，而list的迭代器在使用之后还可以继续使用。<br>int mySize &#x3D; vec.size();vec.at(mySize -2);</p><p>list不提供随机访问，所以不能用下标直接访问到某个位置的元素，要访问list里的元素只能遍历，不过你要是只需要访问list的最后N个元素的话，可以用<code>反向迭代器</code>来遍历</p><h3 id="4-8-reserve与resize"><a href="#4-8-reserve与resize" class="headerlink" title="4.8 reserve与resize"></a>4.8 reserve与resize</h3><p>在 C++ 中，reserve() 和 resize() 是与标准库中的容器（例如 vector、list、deque 等）相关的两个重要函数，它们的作用如下：</p><ul><li><p><strong>reserve():</strong><br>这个函数用于预留容器的存储空间，但不改变容器的大小。预留的存储空间可以用来避免容器在添加新元素时频繁地重新分配内存，从而提高性能。reserve() 函数的参数是要预留的元素个数。如果当前容器的容量小于指定的元素个数，reserve() 函数会分配额外的内存空间以容纳指定数量的元素。</p></li><li><p><strong>resize():</strong><br>这个函数用于更改容器中元素的数量。当调用 resize() 时，如果指定的大小比当前大小小，则容器中的元素数量会减少到指定大小；如果指定的大小比当前大小大，则容器会扩展以容纳额外的元素。如果容器扩展，新添加的元素将以容器元素的默认值进行初始化。</p></li></ul><blockquote><p>在调用 reserve() 函数之后，如果你直接访问预留的空间，将会导致未定义行为，因为这些空间并没有被初始化为有效的元素。</p></blockquote><h3 id="4-9-STL迭代器如何实现"><a href="#4-9-STL迭代器如何实现" class="headerlink" title="4.9 STL迭代器如何实现"></a>4.9 STL迭代器如何实现</h3><ol><li><p>迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。</p></li><li><p>迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与-&gt;运算符，以及++、–等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。</p></li><li><p>最常用的迭代器的相应型别有五种：value type、difference type、pointer、reference、iterator catagoly;</p></li></ol><h3 id="4-10-map插入方式有哪几种？"><a href="#4-10-map插入方式有哪几种？" class="headerlink" title="4.10 map插入方式有哪几种？"></a>4.10 map插入方式有哪几种？</h3><ol><li>用insert函数插入pair数据：</li></ol><pre><code class="cpp">mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;)); </code></pre><ol start="2"><li>用insert函数插入value_type数据：</li></ol><pre><code class="cpp">mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));</code></pre><ol start="3"><li>在insert函数中使用make_pair()函数：</li></ol><pre><code class="cpp">mapStudent.insert(make_pair(1, &quot;student_one&quot;)); </code></pre><ol start="4"><li>用数组方式插入数据：</li></ol><pre><code class="cpp">mapStudent[1] = &quot;student_one&quot;; </code></pre><h3 id="4-20-map中-与find的区别？"><a href="#4-20-map中-与find的区别？" class="headerlink" title="4.20 map中[]与find的区别？"></a>4.20 map中[]与find的区别？</h3><ul><li><p>map的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。</p></li><li><p>map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。</p></li></ul><h3 id="4-21-STL中list与deque之间的区别"><a href="#4-21-STL中list与deque之间的区别" class="headerlink" title="4.21 STL中list与deque之间的区别"></a>4.21 STL中list与deque之间的区别</h3><p>STL（标准模板库）中的list（双向链表）和deque（双端队列）是两种不同的容器，它们有以下区别：</p><ul><li><p>底层数据结构：</p><ul><li>list：<br>采用双向链表作为底层数据结构。每个节点包含数据以及指向前驱节点和后继节点的指针。</li><li>deque：<br>采用分段数组（双端队列）作为底层数据结构。它由多个较小的数组块组成，每个数组块都包含一定数量的元素，并通过指针连接起来，形成一个逻辑上的双端队列。</li></ul></li><li><p>访问元素的效率：</p><ul><li>list：<br>由于采用链表结构，list在任意位置插入或删除元素的效率都很高，为O(1)。但是，随机访问元素的效率较低，为O(n)，因为需要遍历链表找到指定位置的元素。</li><li>deque：<br>由于采用分段数组结构，deque支持高效的随机访问，其时间复杂度为O(1)。同时，deque还支持在两端进行快速插入和删除操作，时间复杂度也为O(1)。</li></ul></li><li><p>内存分配方式：</p><ul><li>list：<br>由于采用链表结构，每次插入或删除元素时都需要动态分配内存，因此在频繁插入或删除大量元素时，可能会产生较多的内存分配和释放操作，导致性能下降。</li><li>deque：<br>由于采用分段数组结构，内存是分块预先分配的，因此在插入或删除元素时不需要频繁进行内存分配和释放操作，性能相对较好。</li></ul></li><li><p>空间占用：</p><ul><li>list：<br>由于每个节点都需要额外的指针来指向前驱节点和后继节点，因此相比于deque，list的空间占用通常更大。</li><li>deque：<br>由于采用分段数组结构，每个数组块的大小是固定的，因此deque的空间占用更为灵活，不会产生额外的指针开销。</li></ul></li></ul><p>根据以上区别，选择使用list还是deque取决于你的具体需求。如果需要频繁进行插入和删除操作，且不关心随机访问的效率，可以选择list；如果需要支持高效的随机访问，并且在两端进行快速插入和删除操作，可以选择deque。</p><h3 id="4-22-STL中的allocator、deallocator"><a href="#4-22-STL中的allocator、deallocator" class="headerlink" title="4.22 STL中的allocator、deallocator"></a>4.22 STL中的allocator、deallocator</h3><p>第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器；</p><p>第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块；</p><p>空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间；</p><p>空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存。</p><h3 id="4-23-常见容器性质总结？"><a href="#4-23-常见容器性质总结？" class="headerlink" title="4.23 常见容器性质总结？"></a>4.23 常见容器性质总结？</h3><p>1.vector 底层数据结构为数组 ，支持快速随机访问</p><p>2.list 底层数据结构为双向链表，支持快速增删</p><p>3.deque 底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问</p><p>deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:</p><p>[堆1] –&gt; [堆2] –&gt;[堆3] –&gt; …</p><p>每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.</p><p>4.stack 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</p><p>5.queue 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）</p><p>6.priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</p><p>7.set 底层数据结构为红黑树，有序，不重复</p><p>8.multiset 底层数据结构为红黑树，有序，可重复</p><p>9.map 底层数据结构为红黑树，有序，不重复</p><p>10.multimap 底层数据结构为红黑树，有序，可重复</p><p>11.unordered_set 底层数据结构为hash表，无序，不重复</p><p>12.unordered_multiset 底层数据结构为hash表，无序，可重复</p><p>13.unordered_map 底层数据结构为hash表，无序，不重复</p><p>14.unordered_multimap 底层数据结构为hash表，无序，可重复</p><h3 id="4-24-说一下STL每种容器对应的迭代器"><a href="#4-24-说一下STL每种容器对应的迭代器" class="headerlink" title="4.24 说一下STL每种容器对应的迭代器"></a>4.24 说一下STL每种容器对应的迭代器</h3><p>| 容器    |迭代器 |<br>| —     |—   |<br>| vector、deque  | 随机访问迭代器 |<br>| stack、queue、priority_queue  | 无 |<br>| list、(multi)set&#x2F;map  | 双向迭代器 |<br>| unordered_(multi)set&#x2F;map、forward_list  | 前向迭代器 |</p><h3 id="4-25-STL中迭代器失效的情况有哪些？"><a href="#4-25-STL中迭代器失效的情况有哪些？" class="headerlink" title="4.25 STL中迭代器失效的情况有哪些？"></a>4.25 STL中迭代器失效的情况有哪些？</h3><p>以vector为例：</p><p>插入元素：</p><ol><li><p>尾后插入：size &lt; capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size &#x3D;&#x3D; capacity时，所有迭代器均失效（需要重新分配空间）。</p></li><li><p>中间插入：中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size &#x3D;&#x3D; capacity时，所有迭代器均失效。</p></li></ol><p>删除元素：</p><ol><li><p>尾后删除：只有尾迭代失效。</p></li><li><p>中间删除：删除位置之后所有迭代失效。</p></li></ol><p>deque 和 vector 的情况类似,</p><p>而list双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器;</p><p>map&#x2F;set等关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器 mmp.erase(iter++);</p><p>unordered_(hash) 迭代器意义不大, rehash之后, 迭代器应该也是全部失效.</p><h3 id="4-26-hashtable中解决冲突有哪些方法？"><a href="#4-26-hashtable中解决冲突有哪些方法？" class="headerlink" title="4.26 hashtable中解决冲突有哪些方法？"></a>4.26 hashtable中解决冲突有哪些方法？</h3><p><strong>记住前三个：</strong></p><ul><li><p>线性探测<br>使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位</p></li><li><p>开链<br>每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中</p></li><li><p>再散列<br>发生冲突时使用另一种hash函数再计算一个地址，直到不冲突</p></li><li><p>二次探测<br>使用hash函数计算出的位置如果已经有元素占用了，按照$1^2$、$2^2$、$3^2$…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测</p></li><li><p>公共溢出区<br>一旦hash函数计算的结果相同，就放入公共溢出区</p></li></ul><h2 id="五、其余问题"><a href="#五、其余问题" class="headerlink" title="五、其余问题"></a>五、其余问题</h2><h3 id="5-1-C-多态"><a href="#5-1-C-多态" class="headerlink" title="5.1 C++多态"></a>5.1 C++多态</h3><p>C++中，多态性主要通过两种方式实现：编译时多态（静态多态）和运行时多态（动态多态）。这两种多态的机制、特点和用途有所不同。</p><ul><li>编译时多态（静态多态）:<br>编译时多态是在程序编译阶段实现的多态性。主要通过函数重载、运算符重载和模板来实现。</li></ul><p>函数重载: 同一个作用域内存在多个同名函数，但它们的参数类型或数量不同。根据调用时实际传递的参数类型和数量，编译器决定调用哪个函数。<br>运算符重载: 允许定义或重新定义大部分C++内置的运算符，使得它们可以根据操作数的类型执行不同的操作。<br>编译时多态的决策是在编译时做出的，因此它不支持在运行时根据对象的实际类型来选择相应的成员函数。</p><ul><li>运行时多态（动态多态）: 运行时多态是在程序运行阶段实现的多态性。它主要通过虚函数和继承来实现。</li></ul><p>虚函数: 通过在基类中声明虚函数，允许派生类中重写该函数。当通过基类的指针或引用调用虚函数时，实际执行的是与指针或引用所指对象的实际类型相对应的函数版本。<br>抽象类和纯虚函数: 抽象类至少包含一个纯虚函数。纯虚函数在基类中没有实现，派生类必须重写这个函数。抽象类不能被实例化。</p><h3 id="5-2-什么时候的析构函数必须写成虚函数"><a href="#5-2-什么时候的析构函数必须写成虚函数" class="headerlink" title="5.2 什么时候的析构函数必须写成虚函数"></a>5.2 什么时候的析构函数必须写成虚函数</h3><p>一般情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。这样做是为了当<code>用一个基类的指针删除一个派生类的对象时</code>，派生类的析构函数会被调用。 </p><p>当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有<code>当一个类被用来作为基类的时候</code>，才把析构函数写成虚函数。</p><h3 id="5-3-构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"><a href="#5-3-构造函数能否声明为虚函数或者纯虚函数，析构函数呢？" class="headerlink" title="5.3 构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"></a>5.3 构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</h3><ul><li>析构函数：  <ul><li>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。<br>只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</li><li>析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。</li></ul></li><li>构造函数：  <ul><li>根据《effective C++》的条款09：绝不在构造和析构过程中调用虚函数可知，在构造函数中虽然可以调用虚函数，但是强烈建议不要这样做。因为基类的构造的过程中，虚函数不能算作是虚函数。若构造函数中调用虚函数，可能会导致不确定行为的发生.</li><li>虚函数对应一个vtable(虚函数表)，类中存储一个vptr指向这个vtable。如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数。</li></ul></li></ul><h3 id="5-4-目标文件存储结构"><a href="#5-4-目标文件存储结构" class="headerlink" title="5.4 目标文件存储结构"></a>5.4 目标文件存储结构</h3><table><thead><tr><th>段</th><th>功能</th></tr></thead><tbody><tr><td>File Header</td><td>文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）</td></tr><tr><td>.text section</td><td>代码段，执行语句编译成的机器代码</td></tr><tr><td>.data section</td><td>数据段，已初始化的全局变量和局部静态变量</td></tr><tr><td>.bss section</td><td>BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）</td></tr><tr><td>.rodata section</td><td>只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量</td></tr><tr><td>.comment section</td><td>注释信息段，存放编译器版本信息</td></tr><tr><td>.note.GNU-stack section</td><td>堆栈提示段</td></tr></tbody></table><blockquote><p>其他段略</p></blockquote><h3 id="5-5-基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#5-5-基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="5.5 基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>5.5 基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h3><ul><li>C++中<code>虚函数表</code>位于<code>只读数据段（.rodata）</code>，也就是C++内存模型中的<code>常量区</code></li><li>而<code>虚函数</code>则位于<code>代码段（.text）</code>，也就是C++内存模型中的<code>代码区</code>。</li><li>在构造函数执行时会对虚表指针进行初始化，并且存在对象<code>内存布局的最前面</code>。</li></ul><h3 id="5-6-模板函数和模板类的特例化"><a href="#5-6-模板函数和模板类的特例化" class="headerlink" title="5.6 模板函数和模板类的特例化"></a>5.6 模板函数和模板类的特例化</h3><ul><li><p>引入原因：<br>编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</p></li><li><p>定义：<br>对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上</p></li></ul><p>（1）模板函数特例化</p><p>必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对&lt;&gt;，表明将原模板的所有模板参数提供实参，举例如下：</p><pre><code class="cpp">template&lt;typename T&gt; //模板函数int compare(const T &amp;v1,const T &amp;v2)&#123;    if(v1 &gt; v2) return -1;    if(v2 &gt; v1) return 1;    return 0;&#125;//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个Ttemplate&lt;&gt; int compare(const char* const &amp;v1,const char* const &amp;v2)&#123;    return strcmp(p1,p2);&#125;</code></pre><ul><li><p>本质<br>特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用特例化版本（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。</p></li><li><p>注意<br>模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</p></li></ul><p>（2）类模板特例化</p><p>原理类似函数模板，<strong>不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。</strong>对类进行特例化时，仍然用template&lt;&gt;表示是一个特例化版本，例如：</p><pre><code class="cpp">template&lt;&gt;class hash&lt;sales_data&gt;&#123;    size_t operator()(sales_data&amp; s);    //里面所有T都换成特例化类型版本sales_data    //按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。&#125;;</code></pre><p>类模板的部分特例化</p><p>不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)</p><p>特例化类中的部分成员</p><p>可以特例化类中的部分成员函数而不是整个类，举个例子：</p><pre><code class="cpp">template&lt;typename T&gt;class Foo&#123;    void Bar();    void Barst(T a)();&#125;;template&lt;&gt;void Foo&lt;int&gt;::Bar()&#123;    //进行int类型的特例化处理    cout &lt;&lt; &quot;我是int型特例化&quot; &lt;&lt; endl;&#125;Foo&lt;string&gt; fs;Foo&lt;int&gt; fi;//使用特例化fs.Bar();//使用的是普通模板，即Foo&lt;string&gt;::Bar()fi.Bar();//特例化版本，执行Foo&lt;int&gt;::Bar()//Foo&lt;string&gt;::Bar()和Foo&lt;int&gt;::Bar()功能不同</code></pre><h3 id="5-7-构造函数、析构函数、虚函数可否声明为内联函数"><a href="#5-7-构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="5.7 构造函数、析构函数、虚函数可否声明为内联函数"></a>5.7 构造函数、析构函数、虚函数可否声明为内联函数</h3><p>首先，将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。</p><blockquote><p>register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率</p></blockquote><p>构造函数和析构函数声明为内联函数是没有意义的</p><p>《Effective C++》中所阐述的是：将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请&#x2F;释放内存，构造&#x2F;析构对象等），致使构造函数&#x2F;析构函数并不像看上去的那么精简。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。</p><p>将虚函数声明为inline，要分情况讨论</p><p>有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联呢？</p><p>上述观点看似正确，其实不然，如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当用对象调用虚函数（此时不具有多态性）时，就内联展开</p><p>综上，当是<code>指向派生类的指针（多态性）</code>调用声明为inline的虚函数时，不会内联展开；当是<code>对象本身调用虚函数</code>时，会内联展开，当然前提依然是函数并不复杂的情况下。</p><h3 id="5-8-C-模板是什么，你知道底层怎么实现的？"><a href="#5-8-C-模板是什么，你知道底层怎么实现的？" class="headerlink" title="5.8 C++模板是什么，你知道底层怎么实现的？"></a>5.8 C++模板是什么，你知道底层怎么实现的？</h3><ul><li><p>编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</p></li><li><p>这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</p></li></ul><h3 id="5-9-构造函数和析构函数可以调用虚函数吗，为什么"><a href="#5-9-构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="5.9 构造函数和析构函数可以调用虚函数吗，为什么"></a>5.9 构造函数和析构函数可以调用虚函数吗，为什么</h3><p>在C++中，提倡不在构造函数和析构函数中调用虚函数；</p><p>构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；</p><p>因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；</p><p>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</p><h3 id="5-10-如何解决菱形继承"><a href="#5-10-如何解决菱形继承" class="headerlink" title="5.10 如何解决菱形继承"></a>5.10 如何解决菱形继承</h3><p>使用虚继承：</p><p>虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。 如:类D继承自类B1、B2，而类B1、B2都继 承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为虚拟继承，而A就成了虚拟基类,虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。</p><p>虚继承的特点是，在任何派生类中的virtual基类总用同一个（共享）对象表示，</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2024/03/22/Markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/03/22/Markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><p>由于md文件同一个效果可能有不同写法，我只记录下我喜欢的用法，方便后续查询使用。</p><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><pre><code class="txt"># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h2 id="二、段落样式"><a href="#二、段落样式" class="headerlink" title="二、段落样式"></a>二、段落样式</h2><h3 id="2-1-换行"><a href="#2-1-换行" class="headerlink" title="2.1 换行"></a>2.1 换行</h3><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用<code>两个以上空格加上回车</code>。<br>而在<code>换行基础上加一个回车</code>或者直接<code>两次回车</code>会导致空出一行。</p><h3 id="2-2-字体"><a href="#2-2-字体" class="headerlink" title="2.2 字体"></a>2.2 字体</h3><p>Markdown 可以使用<code>*</code>或者<code>_</code>切换字体<br>示例如下：</p><pre><code class="txt">*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___</code></pre><h3 id="2-3-分隔线"><a href="#2-3-分隔线" class="headerlink" title="2.3 分隔线"></a>2.3 分隔线</h3><p>你可以在一行中用<code>三个以上的星号、减号、底线</code>来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><pre><code class="txt">**** * ******- - -----------</code></pre><h3 id="2-4-删除线"><a href="#2-4-删除线" class="headerlink" title="2.4 删除线"></a>2.4 删除线</h3><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线<code>~~</code>即可，实例如下：</p><pre><code class="txt">~~BAIDU.COM~~</code></pre><p>效果：<del>BAIDU.COM</del></p><h3 id="2-5-下划线"><a href="#2-5-下划线" class="headerlink" title="2.5 下划线"></a>2.5 下划线</h3><p>下划线可以通过HTML的<code>&lt;u&gt;</code>标签来实现：</p><pre><code class="txt">&lt;u&gt;带下划线文本&lt;/u&gt;</code></pre><p>效果：<u>带下划线文本</u></p><h2 id="三、列表"><a href="#三、列表" class="headerlink" title="三、列表"></a>三、列表</h2><p>Markdown 支持有序列表和无序列表。</p><h3 id="3-1-无序列表"><a href="#3-1-无序列表" class="headerlink" title="3.1 无序列表"></a>3.1 无序列表</h3><p>无序列表使用<code>星号(*)</code>、<code>加号(+)</code>或是<code>减号(-)</code>作为列表标记，这些标记后面要添加一个空格，然后再填写内容：</p><pre><code class="txt">* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项</code></pre><p>效果如下：</p><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><h3 id="3-2-有序列表"><a href="#3-2-有序列表" class="headerlink" title="3.2 有序列表"></a>3.2 有序列表</h3><p>有序列表使用数字并加上 . 号来表示，如：</p><pre><code class="txt">1. 第一项2. 第二项3. 第三项</code></pre><p>效果如下：</p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><h3 id="3-3-列表嵌套"><a href="#3-3-列表嵌套" class="headerlink" title="3.3 列表嵌套"></a>3.3 列表嵌套</h3><p>列表嵌套只需在子列表中的选项前面添加两个或四个空格即可：</p><pre><code class="txt">1. 第一项：    - 第一项嵌套的第一个元素    - 第一项嵌套的第二个元素2. 第二项：    - 第二项嵌套的第一个元素    - 第二项嵌套的第二个元素</code></pre><p>效果如下：</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h2 id="四、区块"><a href="#四、区块" class="headerlink" title="四、区块"></a>四、区块</h2><h3 id="4-1-区块使用"><a href="#4-1-区块使用" class="headerlink" title="4.1 区块使用"></a>4.1 区块使用</h3><p>Markdown 区块引用是在段落开头使用<code>&gt;</code>符号 ，然后后面紧跟<code>一个空格</code>符号：</p><pre><code class="txt">&gt; 区块引用</code></pre><p>效果如下：</p><blockquote><p>Tips：在vscode里面使用markdown的时候，可以拆分编辑器，一边预览，一边写作。</p></blockquote><h3 id="4-2-区块嵌套"><a href="#4-2-区块嵌套" class="headerlink" title="4.2 区块嵌套"></a>4.2 区块嵌套</h3><p>另外区块是可以嵌套的，一个<code>&gt;</code>符号是最外层，两个<code>&gt;</code>符号是第一层嵌套，以此类推：</p><pre><code class="txt">&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><p>效果如下：</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h3 id="4-3-区块与列表"><a href="#4-3-区块与列表" class="headerlink" title="4.3 区块与列表"></a>4.3 区块与列表</h3><p>区块中使用列表<br>区块中使用列表实例如下：</p><pre><code class="txt">&gt; 区块中使用列表&gt; 1. 第一项&gt; + 第一项</code></pre><p>效果如下：</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li></ol><ul><li>第一项</li></ul></blockquote><h2 id="五、代码"><a href="#五、代码" class="headerlink" title="五、代码"></a>五、代码</h2><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（&#96;），例如：</p><pre><code class="txt">`printf()` 函数</code></pre><p>效果如下：<br><code>printf()</code> 函数</p><p>你也可以用<code>```</code>包裹一段代码，并指定一种语言（也可以不指定）<br>例如指定为javascript：<br><code> ```javascript</code><br><code>代码块</code><br><code>```</code><br>效果如下：</p><pre><code class="javascript">$(document).ready(function () &#123;    alert(&#39;RUNOOB&#39;);&#125;);</code></pre><h2 id="六、链接"><a href="#六、链接" class="headerlink" title="六、链接"></a>六、链接</h2><h3 id="6-1-直接链接"><a href="#6-1-直接链接" class="headerlink" title="6.1 直接链接"></a>6.1 直接链接</h3><pre><code class="txt">&lt;链接地址&gt;</code></pre><p>效果：<br><a href="https://hualog.dns.navy/">https://hualog.dns.navy</a></p><h3 id="6-2-别名链接"><a href="#6-2-别名链接" class="headerlink" title="6.2 别名链接"></a>6.2 别名链接</h3><pre><code class="txt">[链接名称](链接地址)</code></pre><p>效果：<a href="https://hualog.dns.navy/">花落阁</a></p><h3 id="6-3-高级链接"><a href="#6-3-高级链接" class="headerlink" title="6.3 高级链接"></a>6.3 高级链接</h3><p>如果一个链接被多次使用，我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><pre><code class="txt">这个链接用 hualog 作为网址变量 [花落阁][hualog]然后在文档的结尾为变量赋值（网址）[hualog]: https://hualog.dns.navy</code></pre><p>效果：<br>这个链接用 hualog 作为网址变量 <a href="https://hualog.dns.navy/">花落阁</a></p><h2 id="七、图片"><a href="#七、图片" class="headerlink" title="七、图片"></a>七、图片</h2><p>Markdown 图片语法格式如下：</p><pre><code class="txt">![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)</code></pre><p>效果如下：<br><img src="/img/cat.jpg" alt="元宝 图标"></p><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的<code>&lt;img&gt;</code>标签。</p><pre><code class="html">&lt;img src=&quot;/img/cat.jpg&quot; width=&quot;50%&quot;&gt;</code></pre><img src="/img/cat.jpg" width="50%"><h2 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h2><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><h3 id="8-1-初始表格"><a href="#8-1-初始表格" class="headerlink" title="8.1 初始表格"></a>8.1 初始表格</h3><p>语法格式如下：</p><pre><code class="txt">|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><p>效果如下：</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><h3 id="8-2-表格对齐方式"><a href="#8-2-表格对齐方式" class="headerlink" title="8.2 表格对齐方式"></a>8.2 表格对齐方式</h3><p>我们可以设置表格的对齐方式：</p><p><code>-:</code>设置内容和标题栏居右对齐。<br><code>:-</code>设置内容和标题栏居左对齐。<br><code>:-:</code>设置内容和标题栏居中对齐。<br>实例如下：</p><pre><code class="txt">| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: ||   x   |   x   |   x    ||   x   |   x   |   x    |</code></pre><p>效果：</p><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">x</td><td align="right">x</td><td align="center">x</td></tr><tr><td align="left">x</td><td align="right">x</td><td align="center">x</td></tr></tbody></table><h2 id="九、高级技巧"><a href="#九、高级技巧" class="headerlink" title="九、高级技巧"></a>九、高级技巧</h2><h3 id="9-1-支持的-HTML-元素"><a href="#9-1-支持的-HTML-元素" class="headerlink" title="9.1 支持的 HTML 元素"></a>9.1 支持的 HTML 元素</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等 ，如：</p><pre><code class="txt">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre><p>效果：<br>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h3 id="9-2-转义"><a href="#9-2-转义" class="headerlink" title="9.2 转义"></a>9.2 转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><pre><code class="txt">**文本加粗** \*\* 正常显示星号 \*\*</code></pre><p>效果：<br><strong>文本加粗</strong><br>** 正常显示星号 **</p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><pre><code class="txt">\   反斜线`   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号</code></pre><h3 id="9-3-公式"><a href="#9-3-公式" class="headerlink" title="9.3 公式"></a>9.3 公式</h3><p>Markdown Preview Enhanced 使用 KaTeX 或者 MathJax 来渲染数学表达式。</p><p>KaTeX 拥有比 MathJax 更快的性能，但是它却少了很多 MathJax 拥有的特性。你可以查看 KaTeX supported functions&#x2F;symbols 来了解 KaTeX 支持那些符号和函数。</p><pre><code class="txt">$...$ 或者 \(...\) 中的数学表达式将会在行内显示。$$...$$ 或者 \[...\] 或者 ```math 中的数学表达式将会在块内显示。</code></pre><p>例如：</p><pre><code class="txt">$f(x) = sin(x) + cos(x)$$$f(x) = sin(x) + cos(x)$$</code></pre><p>行内：<br>$f(x) &#x3D; sin(x) + cos(x)$<br>块内：<br>$$f(x) &#x3D; sin(x) + cos(x)$$</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
            <tag> md </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
