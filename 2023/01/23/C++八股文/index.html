<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>C++八股文 | 花落阁</title>
  <meta name="keywords" content=" 编程语言 , C++ ">
  <meta name="description" content="C++八股文 | 花落阁">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="SRS使用说明方法一： Docker 使用SRS 启动命令： docker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 registry.cn-hangzhou.aliyuncs.com&#x2F;ossrs&#x2F;srs:5   使用ffmpeg推流： ffmpeg -re -i .&#x2F;doc&#x2F;source.flv -c copy -f flv rtmp">
<meta property="og:type" content="article">
<meta property="og:title" content="SRS使用说明">
<meta property="og:url" content="https://hualog.dns.navy/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/index.html">
<meta property="og:site_name" content="花落阁">
<meta property="og:description" content="SRS使用说明方法一： Docker 使用SRS 启动命令： docker run --rm -it -p 1935:1935 -p 1985:1985 -p 8080:8080 registry.cn-hangzhou.aliyuncs.com&#x2F;ossrs&#x2F;srs:5   使用ffmpeg推流： ffmpeg -re -i .&#x2F;doc&#x2F;source.flv -c copy -f flv rtmp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hualog.dns.navy/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/Oryx.png">
<meta property="og:image" content="https://hualog.dns.navy/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/gb28181_3.png">
<meta property="og:image" content="https://hualog.dns.navy/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/gb28181_4.png">
<meta property="og:image" content="https://hualog.dns.navy/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/gb28181_1.png">
<meta property="og:image" content="https://hualog.dns.navy/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/gb28181_2.png">
<meta property="og:image" content="https://hualog.dns.navy/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/rtc.png">
<meta property="article:published_time" content="2024-04-28T07:25:10.000Z">
<meta property="article:modified_time" content="2024-04-30T09:52:12.938Z">
<meta property="article:author" content="花落阁">
<meta property="article:tag" content="SRS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hualog.dns.navy/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/Oryx.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>花落阁</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/xuanxuan000"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:aze0917@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=1430797759&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(15)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="工具">
            <i class="fold iconfont icon-right"></i>
            工具
            <small>(6)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="工具&lt;---&gt;tools">
            
            tools
            <small>(5)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="编程语言">
            <i class="fold iconfont icon-right"></i>
            编程语言
            <small>(4)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="编程语言&lt;---&gt;八股">
            
            八股
            <small>(4)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="音视频">
            
            音视频
            <small>(5)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="15">
<input type="hidden" id="yelog_site_word_count" value="82.6k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>编程语言</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>程序构建</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>传输协议</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>C++</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>cmake</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ffmpeg</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>make</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>markdown</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>md</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SRS</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 音视频 "
           href="/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"
           data-tag="SRS"
           data-author="" >
            <span class="post-title" title="SRS使用说明">SRS使用说明</span>
            <span class="post-date" title="2024-04-28 15:25:10">2024/04/28</span>
        </a>
        
        
        <a  class="全部文章 工具 "
           href="/2024/04/17/%E6%88%91%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="我遇到过的疑难杂症">我遇到过的疑难杂症</span>
            <span class="post-date" title="2024-04-17 18:00:55">2024/04/17</span>
        </a>
        
        
        <a  class="全部文章 音视频 "
           href="/2023/12/25/WebRTC/"
           data-tag="传输协议"
           data-author="" >
            <span class="post-title" title="WebRTC">WebRTC</span>
            <span class="post-date" title="2023-12-25 11:28:29">2023/12/25</span>
        </a>
        
        
        <a  class="全部文章 音视频 "
           href="/2023/11/26/GB28181/"
           data-tag="传输协议"
           data-author="" >
            <span class="post-title" title="GB28181">GB28181</span>
            <span class="post-date" title="2023-11-26 11:19:05">2023/11/26</span>
        </a>
        
        
        <a  class="全部文章 工具 tools "
           href="/2023/11/26/%E6%8A%93%E5%8C%85/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="抓包">抓包</span>
            <span class="post-date" title="2023-11-26 10:20:36">2023/11/26</span>
        </a>
        
        
        <a  class="全部文章 音视频 "
           href="/2023/11/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/"
           data-tag="传输协议"
           data-author="" >
            <span class="post-title" title="音视频传输协议">音视频传输协议</span>
            <span class="post-date" title="2023-11-20 10:53:43">2023/11/20</span>
        </a>
        
        
        <a  class="全部文章 音视频 "
           href="/2023/10/14/FFmpeg%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"
           data-tag="ffmpeg"
           data-author="" >
            <span class="post-title" title="FFmpeg使用说明">FFmpeg使用说明</span>
            <span class="post-date" title="2023-10-14 15:28:34">2023/10/14</span>
        </a>
        
        
        <a  class="全部文章 工具 tools "
           href="/2023/04/29/Docker%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"
           data-tag="docker"
           data-author="" >
            <span class="post-title" title="Docker使用说明">Docker使用说明</span>
            <span class="post-date" title="2023-04-29 10:16:08">2023/04/29</span>
        </a>
        
        
        <a  class="全部文章 工具 tools "
           href="/2023/04/14/Git%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="Git使用说明">Git使用说明</span>
            <span class="post-date" title="2023-04-14 14:57:56">2023/04/14</span>
        </a>
        
        
        <a  class="全部文章 编程语言 八股 "
           href="/2023/04/13/MySQL/"
           data-tag="编程语言"
           data-author="" >
            <span class="post-title" title="MySQL">MySQL</span>
            <span class="post-date" title="2023-04-13 23:58:34">2023/04/13</span>
        </a>
        
        
        <a  class="全部文章 工具 tools "
           href="/2023/02/28/CMake%E8%AF%AD%E6%B3%95/"
           data-tag="cmake,make,程序构建"
           data-author="" >
            <span class="post-title" title="CMake语法">CMake语法</span>
            <span class="post-date" title="2023-02-28 17:01:34">2023/02/28</span>
        </a>
        
        
        <a  class="全部文章 编程语言 八股 "
           href="/2023/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"
           data-tag="编程语言"
           data-author="" >
            <span class="post-title" title="计算机网络">计算机网络</span>
            <span class="post-date" title="2023-02-13 17:27:49">2023/02/13</span>
        </a>
        
        
        <a  class="全部文章 编程语言 八股 "
           href="/2023/02/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
           data-tag="编程语言"
           data-author="" >
            <span class="post-title" title="操作系统">操作系统</span>
            <span class="post-date" title="2023-02-12 10:54:34">2023/02/12</span>
        </a>
        
        
        <a  class="全部文章 编程语言 八股 "
           href="/2023/01/23/C++%E5%85%AB%E8%82%A1%E6%96%87/"
           data-tag="编程语言,C++"
           data-author="" >
            <span class="post-title" title="C++八股文">C++八股文</span>
            <span class="post-date" title="2023-01-23 17:48:51">2023/01/23</span>
        </a>
        
        
        <a  class="全部文章 工具 tools "
           href="/2022/08/22/Markdown%E8%AF%AD%E6%B3%95/"
           data-tag="markdown,md"
           data-author="" >
            <span class="post-title" title="Markdown语法">Markdown语法</span>
            <span class="post-date" title="2022-08-22 11:24:12">2022/08/22</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-C++八股文" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">C++八股文</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="编程语言">编程语言</a> > 
            
            <a  data-rel="编程语言&lt;---&gt;八股">八股</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">编程语言</a>
            
            <a class="color4">C++</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-04-26 14:52:23'>2023-01-23 17:48</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:30.8k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%85%AB%E8%82%A1%E6%96%87"><span class="toc-text">C++八股文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">一、基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%9C%A8main%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%89%8D%E5%92%8C%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.1 在main执行之前和之后执行的代码可能是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">1.2 结构体内存对齐问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.3 指针和引用的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%9C%A8%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%97%B6%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%BC%95%E7%94%A8%E5%91%A2%EF%BC%9F"><span class="toc-text">1.4 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.5 堆和栈的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E6%A0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%94%E5%A0%86%E6%89%A7%E8%A1%8C%E5%BF%AB%EF%BC%9F"><span class="toc-text">1.6 栈为什么比堆执行快？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E5%8C%BA%E5%88%AB%E4%BB%A5%E4%B8%8B%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-text">1.7 区别以下指针类型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-new-delete-%E4%B8%8E-malloc-free%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">1.8 new &#x2F; delete 与 malloc &#x2F; free的异同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-%E8%A2%ABfree%E5%9B%9E%E6%94%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%BF%94%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%97%EF%BC%9F"><span class="toc-text">1.9 被free回收的内存是立即返还给操作系统吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8Ctypedef%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.10 宏定义和typedef区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-strlen%E5%92%8Csizeof%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.11 strlen和sizeof区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="toc-text">1.12 一个指针占多少字节？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.13 常量指针和指针常量区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-2-%E9%A1%B6%E5%B1%82const%E4%B8%8E%E5%BA%95%E5%B1%82const"><span class="toc-text">1.13.2 顶层const与底层const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-14-C-%E5%92%8CC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.14 C++和C语言的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-15-C-%E4%B8%ADstruct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.15 C++中struct和class的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-16-define%E5%AE%8F%E5%AE%9A%E4%B9%89%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.16 define宏定义和const的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-17-%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E6%8C%87%E9%92%88%EF%BC%88%E8%BF%99%E9%87%8C%E4%B8%BA%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E9%A6%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%89%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.17 数组名和指针（这里为指向数组首元素的指针）区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-18-extern%E2%80%9DC%E2%80%9D%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">1.18 extern”C”的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-19-%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-text">1.19 野指针和悬空指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-20-C-%E4%B8%AD%E7%9A%84%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%EF%BC%88%E8%A6%86%E7%9B%96%EF%BC%89%E5%92%8C%E9%9A%90%E8%97%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.20 C++中的重载、重写（覆盖）和隐藏的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-21-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.21 浅拷贝和深拷贝的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-22-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.22 内联函数和宏定义的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-23-public%EF%BC%8Cprotected%E5%92%8Cprivate%E8%AE%BF%E9%97%AE%E5%92%8C%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90-public-protected-private%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">1.23 public，protected和private访问和继承权限&#x2F;public&#x2F;protected&#x2F;private的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-24-%E5%A6%82%E4%BD%95%E7%94%A8%E4%BB%A3%E7%A0%81%E5%88%A4%E6%96%AD%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-text">1.24 如何用代码判断大小端存储？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-25-volatile%E3%80%81mutable%E5%92%8Cexplicit%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">1.25 volatile、mutable和explicit关键字的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-26-C-%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">1.26 C++的异常处理的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-27-static%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">1.27 static的用法和作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-28-%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%EF%BC%9F%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F-%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%BC%9A%E5%BF%AB%E4%B8%80%E4%BA%9B%EF%BC%9F"><span class="toc-text">1.28 成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-29-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E5%BF%85%E9%A1%BB%E7%94%A8%E5%88%B0%E6%88%90%E5%91%98%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.29 有哪些情况必须用到成员列表初始化？作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-30-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%81%BF%E5%85%8D"><span class="toc-text">1.30 什么是内存泄露，如何检测与避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-31-%E5%AF%B9%E8%B1%A1%E5%A4%8D%E7%94%A8%E7%9A%84%E4%BA%86%E8%A7%A3%EF%BC%8C%E9%9B%B6%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-text">1.31 对象复用的了解，零拷贝的了解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-32-C-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2reinterpret-cast-const-cast-static-cast-dynamic-cast"><span class="toc-text">1.32 C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast &#x2F;dynamic_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-33-%E5%86%99C-%E4%BB%A3%E7%A0%81%E6%97%B6%E6%9C%89%E4%B8%80%E7%B1%BB%E9%94%99%E8%AF%AF%E6%98%AF-coredump-%EF%BC%8C%E5%BE%88%E5%B8%B8%E8%A7%81%EF%BC%8C%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E8%B0%83%E8%AF%95%E8%BF%99%E4%B8%AA%E9%94%99%E8%AF%AF%EF%BC%9F"><span class="toc-text">1.33 写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-34-%E8%AF%B4%E8%AF%B4%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">1.34 说说移动构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-35-C-%E4%B8%AD%E5%B0%86%E4%B8%B4%E6%97%B6%E5%8F%98%E9%87%8F%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC%E6%97%B6%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-text">1.35 C++中将临时变量作为返回值时的处理过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-36-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98%E7%9B%B8%E5%AF%B9%E4%BA%8E%E7%BB%93%E6%9E%84%E5%BC%80%E5%A4%B4%E7%9A%84%E5%AD%97%E8%8A%82%E5%81%8F%E7%A7%BB%E9%87%8F"><span class="toc-text">1.36 如何获得结构成员相对于结构开头的字节偏移量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-37-%E6%80%8E%E6%A0%B7%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%B5%AE%E7%82%B9%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="toc-text">1.37 怎样判断两个浮点数是否相等？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-38-C-%E7%9A%84%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%8CSTL%E5%8F%8Astd%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.38 C++的标准库，STL及std的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-39-C-%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E4%BD%A0%E7%9F%A5%E9%81%93%E5%90%97%EF%BC%9F"><span class="toc-text">1.39 C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-40-%E7%B1%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AA%E8%83%BD%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E5%92%8C%E5%8F%AA%E8%83%BD%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-text">1.40 类如何实现只能静态分配和只能动态分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-41-%E7%9F%A5%E9%81%93C-%E4%B8%AD%E7%9A%84%E7%BB%84%E5%90%88%E5%90%97%EF%BC%9F%E5%AE%83%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9B%B8%E6%AF%94%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%BC%BA%E7%82%B9%E5%90%97%EF%BC%9F"><span class="toc-text">1.41 知道C++中的组合吗？它与继承相比有什么优缺点吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-42-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-text">1.42 函数指针？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-43-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-text">1.43 为什么要进行内存对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-44-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99"><span class="toc-text">1.44 内存对齐规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-45-static%E5%8F%98%E9%87%8F"><span class="toc-text">1.45 static变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-46-extern%E5%92%8Cstatic"><span class="toc-text">1.46 extern和static</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-47-%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%EF%BC%9F%E4%BD%A0%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">1.47 如何在不使用额外空间的情况下，交换两个数？你有几种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-48-strcpy-%E5%92%8C-memcpy-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">1.48 strcpy 和 memcpy 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-49-%E7%A8%8B%E5%BA%8F%E5%9C%A8%E6%89%A7%E8%A1%8Cint-main-int-argc-char-argv-%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-text">1.49 程序在执行int main(int argc, char *argv[])时的内存结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-50-volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">1.50 volatile关键字的作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-51-%E5%A6%82%E6%9E%9C%E6%9C%89%E4%B8%80%E4%B8%AA%E7%A9%BA%E7%B1%BB%EF%BC%8C%E5%AE%83%E4%BC%9A%E9%BB%98%E8%AE%A4%E6%B7%BB%E5%8A%A0%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">1.51 如果有一个空类，它会默认添加哪些函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-52-%E8%AF%B4%E4%B8%80%E8%AF%B4strcpy%E3%80%81sprintf%E4%B8%8Ememcpy%E8%BF%99%E4%B8%89%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-text">1.52 说一说strcpy、sprintf与memcpy这三个函数的不同之处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-53-%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-text">1.53 如何阻止一个类被实例化？有哪些方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-54-strcpy%E5%87%BD%E6%95%B0%E5%92%8Cstrncpy%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%93%AA%E4%B8%AA%E5%87%BD%E6%95%B0%E6%9B%B4%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">1.54 strcpy函数和strncpy函数的区别？哪个函数更安全？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-55-%E5%86%99%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-text">1.55 写一个比较大小的模板函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-56-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8Cmemset-this-0-sizeof-this-%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88"><span class="toc-text">1.56 成员函数里memset(this,0,sizeof(*this))会发生什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-57-C-%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">1.57 C++从代码到可执行程序经历了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-58-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB"><span class="toc-text">1.58 友元函数和友元类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-59-%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-text">1.59 自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-60-%E4%B8%BA%E4%BB%80%E4%B9%88C-%E6%B2%A1%E6%9C%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%9F%E8%BF%99%E7%82%B9%E8%B7%9FJava%E4%B8%8D%E5%A4%AA%E4%B8%80%E6%A0%B7%E3%80%82"><span class="toc-text">1.60 为什么C++没有垃圾回收机制？这点跟Java不太一样。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">二、内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8EC-%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA"><span class="toc-text">2.1 简要说明C++的内存分区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B1%A0%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.2 什么是内存池，如何实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%87%A0%E4%B8%AAthis%E6%8C%87%E9%92%88%E7%9A%84%E6%98%93%E6%B7%B7%E9%97%AE%E9%A2%98"><span class="toc-text">2.3 几个this指针的易混问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%90%8E%E6%9E%9C%EF%BC%9F%E5%A6%82%E4%BD%95%E7%9B%91%E6%B5%8B%EF%BC%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">2.4 内存泄漏的后果？如何监测？解决方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-%E4%BD%BF%E7%94%A8-g-%E9%80%89%E9%A1%B9%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-text">2.4.1.使用 -g 选项编译程序有什么作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%9C%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8delete-this%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%AF%B9%E8%B1%A1%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F"><span class="toc-text">2.5 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%A6%82%E6%9E%9C%E5%9C%A8%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8delete-this%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">2.6 如果在类的析构函数中调用delete this，会发生什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E8%AF%B7%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%B8%8B%E9%9D%A2%E5%87%A0%E4%B8%AA%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%90%84%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">2.7 请说一下以下几种情况下，下面几个类的大小各是多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%8F%97%E5%93%AA%E4%BA%9B%E5%9B%A0%E7%B4%A0%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-text">2.8 类对象的大小受哪些因素影响？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81C-11%E6%96%B0%E6%A0%87%E5%87%86"><span class="toc-text">三、C++11新标准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-C-11%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-text">3.1 C++ 11有哪些新特性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%81%E5%B8%B8%E7%94%A8%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.2 智能指针的原理、常用的智能指针及实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-lambda%E5%87%BD%E6%95%B0"><span class="toc-text">3.3 lambda函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-shared-ptr%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-text">3.4 shared_ptr的循环引用问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81STL"><span class="toc-text">四、STL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BB%80%E4%B9%88%E6%98%AFSTL"><span class="toc-text">4.1 什么是STL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%E8%B5%84%E6%BA%90%EF%BC%8CRAII%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%9F"><span class="toc-text">4.2 使用智能指针管理内存资源，RAII是怎么回事？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9A-it%E3%80%81it-%E5%93%AA%E4%B8%AA%E5%A5%BD%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-text">4.3 迭代器：++it、it++哪个好，为什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%8F%B3%E5%80%BC"><span class="toc-text">4.4 右值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8Btraits%E6%8A%80%E6%B3%95"><span class="toc-text">4.5 简单说一下traits技法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-STL%E7%9A%84%E4%B8%A4%E7%BA%A7%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8"><span class="toc-text">4.6 STL的两级空间配置器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-vector%E4%B8%8Elist%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E5%BA%94%E7%94%A8%EF%BC%9F%E6%80%8E%E4%B9%88%E6%89%BE%E6%9F%90vector%E6%88%96%E8%80%85list%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">4.7 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-reserve%E4%B8%8Eresize"><span class="toc-text">4.8 reserve与resize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-STL%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.9 STL迭代器如何实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-map%E6%8F%92%E5%85%A5%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-text">4.10 map插入方式有哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-20-map%E4%B8%AD-%E4%B8%8Efind%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">4.20 map中[]与find的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-21-STL%E4%B8%ADlist%E4%B8%8Edeque%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">4.21 STL中list与deque之间的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-22-STL%E4%B8%AD%E7%9A%84allocator%E3%80%81deallocator"><span class="toc-text">4.22 STL中的allocator、deallocator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-23-%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E6%80%A7%E8%B4%A8%E6%80%BB%E7%BB%93%EF%BC%9F"><span class="toc-text">4.23 常见容器性质总结？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-24-%E8%AF%B4%E4%B8%80%E4%B8%8BSTL%E6%AF%8F%E7%A7%8D%E5%AE%B9%E5%99%A8%E5%AF%B9%E5%BA%94%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">4.24 说一下STL每种容器对应的迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-25-STL%E4%B8%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-text">4.25 STL中迭代器失效的情况有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-26-hashtable%E4%B8%AD%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-text">4.26 hashtable中解决冲突有哪些方法？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%85%B6%E4%BD%99%E9%97%AE%E9%A2%98"><span class="toc-text">五、其余问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-C-%E5%A4%9A%E6%80%81"><span class="toc-text">5.1 C++多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">5.2 什么时候的析构函数必须写成虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%83%BD%E5%90%A6%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E6%88%96%E8%80%85%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%91%A2%EF%BC%9F"><span class="toc-text">5.3 构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">5.4 目标文件存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%AD%98%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E4%BB%80%E4%B9%88%E5%8C%BA%EF%BC%8C%E8%99%9A%E8%A1%A8%E6%8C%87%E9%92%88vptr%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E9%97%B4"><span class="toc-text">5.5 基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E7%89%B9%E4%BE%8B%E5%8C%96"><span class="toc-text">5.6 模板函数和模板类的特例化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89%E5%92%8C%E5%AE%9E%E7%8E%B0%E5%8F%AF%E4%B8%8D%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%86%99%E5%9C%A8%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E9%87%8C%E9%9D%A2%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">5.7 模板定义和实现可不可以不写在一个文件里面？为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%AF%E5%90%A6%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-text">5.8 构造函数、析构函数、虚函数可否声明为内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-C-%E6%A8%A1%E6%9D%BF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93%E5%BA%95%E5%B1%82%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-text">5.9 C++模板是什么，你知道底层怎么实现的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-10-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-text">5.10 构造函数和析构函数可以调用虚函数吗，为什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-11-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="toc-text">5.11 如何解决菱形继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-12-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%9Chello-world%E2%80%9D%E4%BB%8E%E5%BC%80%E5%A7%8B%E5%88%B0%E6%89%93%E5%8D%B0%E5%88%B0%E5%B1%8F%E5%B9%95%E4%B8%8A%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">5.12 将字符串“hello world”从开始到打印到屏幕上的全过程?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-13-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E4%BC%A0%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BC%A0%E5%80%BC%EF%BC%9F"><span class="toc-text">5.13 为什么拷贝构造函数必须传引用不能传值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-14-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-text">5.14 虚函数的调用关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-15-%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%88%B0%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-text">5.15 说一说你了解到的移动构造函数？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-16-%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F%E6%8A%8A%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E8%AF%B4%E4%B8%80%E8%AF%B4"><span class="toc-text">5.16 哪些函数不能是虚函数？把你知道的都说一说</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-17-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">5.17 什么是纯虚函数，与虚函数的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-18-DLL%E5%8A%AB%E6%8C%81"><span class="toc-text">5.18 DLL劫持</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="C-八股文"><a href="#C-八股文" class="headerlink" title="C++八股文"></a>C++八股文</h1><h2 id="一、基础语法"><a href="#一、基础语法" class="headerlink" title="一、基础语法"></a>一、基础语法</h2><h3 id="1-1-在main执行之前和之后执行的代码可能是什么？"><a href="#1-1-在main执行之前和之后执行的代码可能是什么？" class="headerlink" title="1.1 在main执行之前和之后执行的代码可能是什么？"></a>1.1 在main执行之前和之后执行的代码可能是什么？</h3><p><strong>main函数执行之前，主要就是初始化系统相关资源：</strong></p>
<ul>
<li>设置栈指针</li>
<li>初始化静态<code>static</code>变量和<code>global</code>全局变量，即<code>.data</code>段的内容</li>
<li>将未初始化部分的全局变量赋初值：数值型<code>short</code>，<code>int</code>，<code>long</code>等为<code>0</code>，<code>bool</code>为<code>FALSE</code>，<code>指针</code>为<code>NULL</code>等等，即<code>.bss</code>段的内容</li>
<li>将main函数的参数<code>argc</code>，<code>argv</code>等传递给<code>main</code>函数，然后才真正运行<code>main</code>函数</li>
<li>执行<code>__attribute__((constructor))</code>，与golang的init()函数类似</li>
</ul>
<p><strong>main函数完成后：</strong></p>
<ul>
<li>全局对象的析构函数</li>
<li>可以用<code>atexit</code>注册一个函数，它会在<code>main</code>之后执行;</li>
<li><code>__attribute__((destructor))</code></li>
</ul>
<h3 id="1-2-结构体内存对齐问题？"><a href="#1-2-结构体内存对齐问题？" class="headerlink" title="1.2 结构体内存对齐问题？"></a>1.2 结构体内存对齐问题？</h3><ul>
<li>结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。</li>
<li>未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）</li>
</ul>
<p>c++11以后引入两个关键字<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/alignas"><code>alignas</code></a>与<a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/alignof"><code>alignof</code></a>。其中<code>alignof</code>可以计算出类型的对齐方式，<code>alignas</code>可以指定结构体的对齐方式。但是仍有需要注意的点：</p>
<ul>
<li>若<code>alignas</code>小于自然对齐的最小单位，则被忽略。</li>
<li>如果想使用单字节对齐的方式，使用<code>alignas</code>是无效的。应该使用<code>#pragma pack(push,1)</code>或者使用<code>__attribute__((packed))</code>。</li>
</ul>
<p>用法如下：</p>
<pre><code class="C++">// 无效的指定 因为2小于自然对齐的大小uint32_t(4)
struct alignas(2) Info2 &#123;
  uint8_t a;
  uint32_t b;
  uint8_t c;
&#125;;
</code></pre>
<h3 id="1-3-指针和引用的区别"><a href="#1-3-指针和引用的区别" class="headerlink" title="1.3 指针和引用的区别"></a>1.3 指针和引用的区别</h3><ul>
<li>指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名</li>
<li>指针可以有多级，引用只有一级</li>
<li>指针可以为空，引用不能为NULL且在定义时必须初始化</li>
<li>指针在初始化后可以改变指向，而引用在初始化之后不可再改变</li>
<li>sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小</li>
<li>引用本质是一个指针，同样会占4&#x2F;8字节内存，不过编译器对它进行了一些处理，使得程序认为它不单独占用内存空间；指针是具体变量，需要占用存储空间。</li>
<li>引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。</li>
<li>不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。</li>
</ul>
<h3 id="1-4-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"><a href="#1-4-在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？" class="headerlink" title="1.4 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？"></a>1.4 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？</h3><ul>
<li>需要操作内存的时候传指针。</li>
<li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小。</li>
<li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式。</li>
</ul>
<h3 id="1-5-堆和栈的区别"><a href="#1-5-堆和栈的区别" class="headerlink" title="1.5 堆和栈的区别"></a>1.5 堆和栈的区别</h3><ul>
<li><p>申请方式不同。</p>
<p>栈由系统自动分配。<br>堆是自己申请和释放的。</p>
</li>
<li><p>申请大小限制不同。</p>
<p>栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。<br>堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。<br>栈空间默认是4M, 堆区一般是 1G - 4G</p>
</li>
<li><p>申请效率不同。</p>
<p>栈由系统分配，速度快，不会有碎片。<br>堆由程序员分配，速度慢，且会有碎片。</p>
</li>
</ul>
<h3 id="1-6-栈为什么比堆执行快？"><a href="#1-6-栈为什么比堆执行快？" class="headerlink" title="1.6 栈为什么比堆执行快？"></a>1.6 栈为什么比堆执行快？</h3><ol>
<li><p>栈内存的快速访问主要是因为它通常位于主存中的相对较小的内存区域，这使得 CPU 缓存（包括一级缓存）中的数据能够快速加载到处理器中。此外，栈内存的顺序访问模式也有助于提高缓存的命中率。    </p>
</li>
<li><p>堆内存访问首先要从内存读指针地址，然后再用这个指针地址加偏移量去访问堆内存，这就导致了多一个读指令。另外，堆内存很可能不处于缓存里，尤其是第一次访问，如果再发生缺页中断会导致堆和栈出现巨大的速度差异。</p>
</li>
<li><p>堆内存需要做内存申请，这是极为耗时的操作，如果把内存申请的消耗计算在内，那栈内存的综合速度优势就又多了一项。</p>
</li>
</ol>
<h3 id="1-7-区别以下指针类型？"><a href="#1-7-区别以下指针类型？" class="headerlink" title="1.7 区别以下指针类型？"></a>1.7 区别以下指针类型？</h3><pre><code class="C++">int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
</code></pre>
<ul>
<li><p>int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。</p>
</li>
<li><p>int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。</p>
</li>
<li><p>int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。</p>
</li>
<li><p>int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。</p>
</li>
</ul>
<h3 id="1-8-new-delete-与-malloc-free的异同"><a href="#1-8-new-delete-与-malloc-free的异同" class="headerlink" title="1.8 new &#x2F; delete 与 malloc &#x2F; free的异同"></a>1.8 new &#x2F; delete 与 malloc &#x2F; free的异同</h3><ul>
<li><p>相同点</p>
<ul>
<li>都可用于内存的动态申请和释放</li>
</ul>
</li>
<li><p>不同点</p>
<ul>
<li>前者是C++运算符，后者是C&#x2F;C++语言标准库函数</li>
<li>new自动计算要分配的空间大小，malloc需要手工计算</li>
<li>new是类型安全的，malloc不是。例如：</li>
</ul>
<pre><code>int *p = new float[2]; //编译错误
*p = (int*)malloc(2 * sizeof(double));//编译无错误
</code></pre>
<ul>
<li>new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者均没有相关调用</li>
<li>后者需要库文件支持，前者不用</li>
<li>new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象</li>
</ul>
</li>
</ul>
<h3 id="1-9-被free回收的内存是立即返还给操作系统吗？"><a href="#1-9-被free回收的内存是立即返还给操作系统吗？" class="headerlink" title="1.9 被free回收的内存是立即返还给操作系统吗？"></a>1.9 被free回收的内存是立即返还给操作系统吗？</h3><ul>
<li>不是的，被free回收的内存会首先被内存管理系统的自由列表（free list）保存起来。常见的如ptmalloc使用双链表保存内存块，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</li>
</ul>
<h3 id="1-10-宏定义和typedef区别？"><a href="#1-10-宏定义和typedef区别？" class="headerlink" title="1.10 宏定义和typedef区别？"></a>1.10 宏定义和typedef区别？</h3><ul>
<li><p>宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。</p>
</li>
<li><p>宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。</p>
</li>
<li><p>宏不检查类型；typedef会检查数据类型。</p>
</li>
<li><p>宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。</p>
</li>
<li><p>注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。</p>
</li>
</ul>
<h3 id="1-11-strlen和sizeof区别？"><a href="#1-11-strlen和sizeof区别？" class="headerlink" title="1.11 strlen和sizeof区别？"></a>1.11 strlen和sizeof区别？</h3><ul>
<li><p>sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。</p>
</li>
<li><p>sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是’\0’的字符串。</p>
</li>
<li><p>因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。</p>
</li>
</ul>
<h3 id="1-12-一个指针占多少字节？"><a href="#1-12-一个指针占多少字节？" class="headerlink" title="1.12 一个指针占多少字节？"></a>1.12 一个指针占多少字节？</h3><ul>
<li><p>在64位的编译环境下，指针的占用大小为8字节；</p>
</li>
<li><p>而在32位环境下，指针占用大小为4字节。</p>
</li>
<li><p>一个指针占内存的大小跟编译环境有关，而与机器的位数无关。</p>
</li>
<li><p>还有疑问的，可以自行打开Visual Studio编译器自己实验一番。</p>
</li>
</ul>
<h3 id="1-13-常量指针和指针常量区别？"><a href="#1-13-常量指针和指针常量区别？" class="headerlink" title="1.13 常量指针和指针常量区别？"></a>1.13 常量指针和指针常量区别？</h3><ul>
<li><strong>常量指针</strong>是一个指针，读成常量的指针，指向一个只读变量，也就是后面所指明的int const 和 const int，都是一个常量，可以写作：<ul>
<li>int const *<strong>p</strong></li>
<li>const int *<strong>p</strong>。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>常量指针</strong>-&gt;指向常量的指针<br><strong>常量指针</strong>-&gt;不可改变内容，但可以改变指向的地址。 </p>
</blockquote>
<ul>
<li><strong>指针常量</strong>是一个常量，必须初始化，一旦初始化完成，它的值（也就是存放在指针中的地址）就不能在改变了，即不能中途改变指向，如：<ul>
<li>int *const <strong>p</strong>。<blockquote>
<p><strong>指针常量</strong>-&gt;常量<br><strong>指针常量</strong>-&gt;不可改变指向的地址，但可以改变地址存放的数据。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="1-13-2-顶层const与底层const"><a href="#1-13-2-顶层const与底层const" class="headerlink" title="1.13.2 顶层const与底层const"></a>1.13.2 顶层const与底层const</h3><ul>
<li>顶层const：指针本身是一个常量；</li>
<li>底层const：指针所指对象是一个常量；</li>
</ul>
<h3 id="1-14-C-和C语言的区别"><a href="#1-14-C-和C语言的区别" class="headerlink" title="1.14 C++和C语言的区别"></a>1.14 C++和C语言的区别</h3><ul>
<li><strong>面向对象编程（OOP）</strong>：<br>C++ 是一种支持面向对象编程的语言，它引入了类和对象的概念，以及封装、继承和多态等面向对象的特性。<br>C 语言虽然也可以编写面向对象的代码，但它没有内建的语言特性来支持面向对象编程，因此需要使用结构体和函数来模拟类和对象。</li>
<li><strong>标准库</strong>：<br>C++ 标准库（STL）提供了许多丰富的数据结构和算法，如向量、列表、映射、排序和搜索等。<br>C 语言的标准库相对较小，只提供了一些基本的数据类型和函数，如整数、字符、字符串和文件处理等。</li>
<li><strong>内存管理</strong>：<br>C++ 支持动态内存分配和释放，引入了 new 和 delete 运算符用于动态分配和释放内存。<br>C 语言也支持动态内存分配和释放，但是使用的是 malloc() 和 free() 函数。</li>
<li><strong>异常处理</strong>：<br>C++ 支持异常处理机制，可以使用 try、catch 和 throw 关键字来处理异常情况。<br>C 语言没有内建的异常处理机制，通常通过返回值或错误码来处理异常情况。</li>
<li><strong>其他特性</strong>：<br>C++ 还引入了许多其他特性，如模板、命名空间、运算符重载和函数重载等，以提高代码的灵活性和可复用性。<br>C 语言相对较简单，更加接近硬件和操作系统，因此更适用于系统级编程和嵌入式开发。</li>
</ul>
<p>总的来说，C++ 是在 C 语言基础上发展而来的，它继承了 C 语言的一些特性，并引入了更多的高级特性，如面向对象编程和异常处理等，使得它更加适用于大型项目和复杂的软件开发。</p>
<h3 id="1-15-C-中struct和class的区别"><a href="#1-15-C-中struct和class的区别" class="headerlink" title="1.15 C++中struct和class的区别"></a>1.15 C++中struct和class的区别</h3><ul>
<li><p>相同点  </p>
<p>两者都拥有成员函数、公有和私有部分<br>任何可以使用class完成的工作，同样可以使用struct完成</p>
</li>
<li><p>不同点</p>
<p>两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的</p>
<p>class默认是private继承， 而struct默认是public继承</p>
</li>
</ul>
<h3 id="1-16-define宏定义和const的区别"><a href="#1-16-define宏定义和const的区别" class="headerlink" title="1.16 define宏定义和const的区别"></a>1.16 define宏定义和const的区别</h3><p><strong>编译阶段</strong></p>
<ul>
<li>define是在编译的<code>预处理阶段</code>起作用，而const是在<code>编译、运行</code>的时候起作用</li>
</ul>
<p><strong>安全性</strong></p>
<ul>
<li>define只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错  </li>
<li>const常量有数据类型，编译器可以对其进行类型安全检查</li>
</ul>
<p><strong>内存占用</strong></p>
<ul>
<li>define只是将宏名称进行替换，在内存中会产生多分相同的备份。const在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表</li>
</ul>
<h3 id="1-17-数组名和指针（这里为指向数组首元素的指针）区别？"><a href="#1-17-数组名和指针（这里为指向数组首元素的指针）区别？" class="headerlink" title="1.17 数组名和指针（这里为指向数组首元素的指针）区别？"></a>1.17 数组名和指针（这里为指向数组首元素的指针）区别？</h3><ul>
<li><p>二者均可通过增减偏移量来访问数组中的元素。</p>
</li>
<li><p>数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。</p>
</li>
<li><p><strong>当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。</strong></p>
</li>
</ul>
<h3 id="1-18-extern”C”的用法"><a href="#1-18-extern”C”的用法" class="headerlink" title="1.18 extern”C”的用法"></a>1.18 extern”C”的用法</h3><ul>
<li>为了能够正确的在C++代码中调用C语言的代码：在程序中加上extern “C”后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++。</li>
</ul>
<h3 id="1-19-野指针和悬空指针"><a href="#1-19-野指针和悬空指针" class="headerlink" title="1.19 野指针和悬空指针"></a>1.19 野指针和悬空指针</h3><pre><code>都是是指向无效内存区域(这里的无效指的是&quot;不安全不可控&quot;)的指针，访问行为将会导致未定义行为。
</code></pre>
<ul>
<li><strong>野指针</strong><br>野指针，指的是没有被初始化过的指针</li>
<li><strong>悬空指针</strong><br>悬空指针，指针最初指向的内存已经被释放了的一种指针。</li>
</ul>
<p>使用智能指针可以有效解决问题。</p>
<h3 id="1-20-C-中的重载、重写（覆盖）和隐藏的区别"><a href="#1-20-C-中的重载、重写（覆盖）和隐藏的区别" class="headerlink" title="1.20 C++中的重载、重写（覆盖）和隐藏的区别"></a>1.20 C++中的重载、重写（覆盖）和隐藏的区别</h3><ol>
<li><p><strong>重载（overload）</strong><br>  重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是<code>返回类型</code>和<code>函数名</code>相同，<code>参数类型和数目</code>有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个例子：</p>
</li>
<li><p><strong>重写（覆盖）（override）</strong><br>  重写指的是在派生类中覆盖基类中的同名函数，重写就是重写函数体，要求基类函数必须是虚函数且：</p>
<ul>
<li>与基类的虚函数有相同的参数个数</li>
<li>与基类的虚函数有相同的参数类型</li>
<li>与基类的虚函数有相同的返回值类型</li>
</ul>
</li>
<li><p><strong>隐藏（hide）</strong><br>  隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：</p>
<ul>
<li>两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。</li>
</ul>
<pre><code class="C++">  //父类
  class A&#123;
  public:
      void fun(int a)&#123;
      cout &lt;&lt; &quot;A中的fun函数&quot; &lt;&lt; endl;
    &#125;
  &#125;;
  //子类
  class B : public A&#123;
  public:
      //隐藏父类的fun函数
      void fun(int a)&#123;
      cout &lt;&lt; &quot;B中的fun函数&quot; &lt;&lt; endl;
    &#125;
  &#125;;
  int main()&#123;
      B b;
      b.fun(2); //调用的是B中的fun函数
      b.A::fun(2); //调用A中fun函数
      return 0;
  &#125;
</code></pre>
<ul>
<li>两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。</li>
</ul>
<pre><code class="C++">  //父类
  class A&#123;
  public:
      virtual void fun(int a)&#123;
      cout &lt;&lt; &quot;A中的fun函数&quot; &lt;&lt; endl;
    &#125;
  &#125;;
  //子类
  class B : public A&#123;
  public:
      //隐藏父类的fun函数
    virtual void fun(char* a)&#123;
      cout &lt;&lt; &quot;A中的fun函数&quot; &lt;&lt; endl;
    &#125;
  &#125;;
  int main()&#123;
      B b;
      b.fun(2); //报错，调用的是B中的fun函数，参数类型不对
      b.A::fun(2); //调用A中fun函数
      return 0;
  &#125;
</code></pre>
</li>
</ol>
<h3 id="1-21-浅拷贝和深拷贝的区别"><a href="#1-21-浅拷贝和深拷贝的区别" class="headerlink" title="1.21 浅拷贝和深拷贝的区别"></a>1.21 浅拷贝和深拷贝的区别</h3><ul>
<li><p><strong>浅拷贝</strong>  </p>
<p>浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。</p>
</li>
<li><p><strong>深拷贝</strong></p>
<p>深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。</p>
</li>
</ul>
<h3 id="1-22-内联函数和宏定义的区别"><a href="#1-22-内联函数和宏定义的区别" class="headerlink" title="1.22 内联函数和宏定义的区别"></a>1.22 内联函数和宏定义的区别</h3><ul>
<li>在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。</li>
<li>内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载。</li>
<li>宏定义时要注意书写（参数要括起来）否则容易出现歧义，内联函数不会产生歧义<br>内联函数有类型检测、语法判断等功能，而宏没有<blockquote>
<p>注意：使用<code>inline</code>关键字只是建议编译器内联函数，内联函数是否真的内联还需要编译器判断。</p>
</blockquote>
</li>
</ul>
<h3 id="1-23-public，protected和private访问和继承权限-public-protected-private的区别？"><a href="#1-23-public，protected和private访问和继承权限-public-protected-private的区别？" class="headerlink" title="1.23 public，protected和private访问和继承权限&#x2F;public&#x2F;protected&#x2F;private的区别？"></a>1.23 public，protected和private访问和继承权限&#x2F;public&#x2F;protected&#x2F;private的区别？</h3><ul>
<li><p><strong>访问权限</strong></p>
<ul>
<li><p>public的变量和函数在类的内部外部都可以访问。</p>
</li>
<li><p>protected的变量和函数只能在类的内部和其派生类中访问。</p>
</li>
<li><p>private修饰的元素只能在类内访问。</p>
</li>
</ul>
</li>
<li><p><strong>继承权限</strong></p>
<ul>
<li><p>public继承（公有继承）的特点是基类的公有成员和保护成员作为派生类的成员时，都保持原有的状态，而基类的私有成员任然是私有的，不能被这个派生类的子类所访问</p>
</li>
<li><p>protected继承（保护继承）的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元函数访问，基类的私有成员仍然是私有的</p>
</li>
<li><p>private继承（私有继承）的特点是基类的所有公有成员和保护成员都成为派生类的私有成员，并不被它的派生类的子类所访问，基类的成员只能由自己派生类访问，无法再往下继承</p>
</li>
</ul>
</li>
</ul>
<h3 id="1-24-如何用代码判断大小端存储？"><a href="#1-24-如何用代码判断大小端存储？" class="headerlink" title="1.24 如何用代码判断大小端存储？"></a>1.24 如何用代码判断大小端存储？</h3><ul>
<li><p>大端存储：字数据的高字节存储在低地址中  –&gt; 高位在前</p>
</li>
<li><p>小端存储：字数据的低字节存储在低地址中  –&gt; 高位在后</p>
<p>使用强制类型转换判断大小端存储</p>
<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;
int main()
&#123;
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout &lt;&lt; &quot;big endian&quot; &lt;&lt; endl;
    else if(c == 0x34)
        cout &lt;&lt; &quot;little endian&quot; &lt;&lt; endl;
&#125;
</code></pre>
</li>
</ul>
<h3 id="1-25-volatile、mutable和explicit关键字的用法"><a href="#1-25-volatile、mutable和explicit关键字的用法" class="headerlink" title="1.25 volatile、mutable和explicit关键字的用法"></a>1.25 volatile、mutable和explicit关键字的用法</h3><ol>
<li><p><strong>volatile</strong><br>volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。</p>
</li>
<li><p><strong>mutable</strong><br>mutable的中文意思是“可变的，易变的”，跟constant（即C++中的const）是反义词。在C++中，mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成const的。但是，有些时候，我们需要<code>在const函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被mutable来修饰，并且放在函数后后面关键字位置</code>。</p>
</li>
</ol>
<pre><code class="C++">class person
&#123;
    int m_A;
    mutable int m_B;//特殊变量 在常函数里值也可以被修改
public:
    void add() const//在函数里不可修改this指针指向的值 常量指针
    &#123;
        m_A = 10;//错误  不可修改值，this已经被修饰为常量指针
        m_B = 20;//正确
    &#125;
&#125;;
</code></pre>
<pre><code class="C++">class person
&#123;
public:
    int m_A;
    mutable int m_B;//特殊变量 在常函数里值也可以被修改
&#125;;
int main()
&#123;
    const person p = person();//修饰常对象 不可修改类成员的值
    p.m_A = 10;//错误，被修饰了指针常量
    p.m_B = 200;//正确，特殊变量，修饰了mutable
&#125;
</code></pre>
<ol start="3">
<li><p><strong>explicit</strong><br>explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显式的方式进行类型转换，注意以下几点：</p>
<ul>
<li>explicit 关键字只能用于类内部的构造函数声明上</li>
<li>被explicit修饰的构造函数的类，不能发生相应的隐式类型转换</li>
</ul>
</li>
</ol>
<h3 id="1-26-C-的异常处理的方法"><a href="#1-26-C-的异常处理的方法" class="headerlink" title="1.26 C++的异常处理的方法"></a>1.26 C++的异常处理的方法</h3><p>在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：</p>
<ul>
<li>数组下标越界</li>
<li>除法计算时除数为0</li>
<li>动态分配空间时空间不足</li>
</ul>
<p>如果不及时对这些异常进行处理，程序多数情况下都会崩溃。</p>
<p>C++中的异常处理机制主要使用try、throw和catch三个关键字，其在程序中的用法如下：</p>
<pre><code class="C++">#include &lt;iostream&gt;
using namespace std;
int main()
&#123;
    double m = 1, n = 0;
    try &#123;
        cout &lt;&lt; &quot;before dividing.&quot; &lt;&lt; endl;
        if (n == 0)
            throw - 1;  //抛出int型异常
        else if (m == 0)
            throw - 1.0;  //拋出 double 型异常
        else
            cout &lt;&lt; m / n &lt;&lt; endl;
        cout &lt;&lt; &quot;after dividing.&quot; &lt;&lt; endl;
    &#125;
    catch (double d) &#123;
        cout &lt;&lt; &quot;catch (double)&quot; &lt;&lt; d &lt;&lt; endl;
    &#125;
    catch (...) &#123;
        cout &lt;&lt; &quot;catch (...)&quot; &lt;&lt; endl;
    &#125;
    cout &lt;&lt; &quot;finished&quot; &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。<br><strong>catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(…)的方式捕获任何异常（不推荐）。</strong><br>当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以<code>在catch里面再throw异常</code>。</p>
<h3 id="1-27-static的用法和作用？"><a href="#1-27-static的用法和作用？" class="headerlink" title="1.27 static的用法和作用？"></a>1.27 static的用法和作用？</h3><ol>
<li><p>先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）<br>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。</p>
</li>
<li><p>static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。</p>
</li>
<li><p>static的第三个作用是默认初始化为0（static变量）<br>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。</p>
</li>
<li><p>static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；</p>
</li>
<li><p>由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问static修饰的类成员；</p>
</li>
<li><p>static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this-&gt;vptr-&gt;ctable-&gt;virtual function</p>
</li>
</ol>
<h3 id="1-28-成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？"><a href="#1-28-成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？" class="headerlink" title="1.28 成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"></a>1.28 成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</h3><p>赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化。<br>这两种方式的主要区别在于：</p>
<ul>
<li><p>对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。</p>
</li>
<li><p>列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。</p>
</li>
</ul>
<h3 id="1-29-有哪些情况必须用到成员列表初始化？作用是什么？"><a href="#1-29-有哪些情况必须用到成员列表初始化？作用是什么？" class="headerlink" title="1.29 有哪些情况必须用到成员列表初始化？作用是什么？"></a>1.29 有哪些情况必须用到成员列表初始化？作用是什么？</h3><ul>
<li><p><strong>常量成员变量：</strong></p>
<p>如果类中包含<code>const</code>或者<code>引用类型</code>的成员变量，则必须使用成员列表初始化对它们进行初始化。<br>因为常量成员变量和引用类型成员变量无法在构造函数内部进行赋值，只能通过成员列表初始化来初始化它们。  </p>
</li>
<li><p><strong>继承的成员变量：</strong></p>
<p>如果<code>派生类继承了基类的成员变量，且基类没有默认构造函数</code>，则必须使用成员列表初始化来调用基类的构造函数对基类成员变量进行初始化。  </p>
</li>
<li><p><strong>成员对象：</strong></p>
<p>如果<code>类中包含其他类对象作为成员变量</code>，则最好使用成员列表初始化对这些成员对象进行初始化。<br>这样可以避免在构造函数体内部对成员对象进行默认初始化后再赋值，而直接在构造函数的初始化列表中完成初始化。</p>
</li>
</ul>
<h3 id="1-30-什么是内存泄露，如何检测与避免"><a href="#1-30-什么是内存泄露，如何检测与避免" class="headerlink" title="1.30 什么是内存泄露，如何检测与避免"></a>1.30 什么是内存泄露，如何检测与避免</h3><ul>
<li><p>内存泄露</p>
<p>一般我们常说的内存泄漏是指堆内存的泄漏。堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。应用程序般使用malloc,、realloc、 new等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块，否则，这块内存就不能被再次使用，我们就说这块内存泄漏了</p>
</li>
<li><p>避免内存泄露的几种方式</p>
<ul>
<li>计数法：使用new或者malloc时，让该数+1，delete或free时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄露</li>
<li>一定要将基类的析构函数声明为虚函数</li>
<li>对象数组的释放一定要用delete []</li>
<li>有new就有delete，有malloc就有free，保证它们一定成对出现</li>
</ul>
</li>
<li><p>检测工具</p>
<ul>
<li>Linux下可以使用Valgrind工具  </li>
<li>Windows下可以使用CRT库</li>
</ul>
</li>
</ul>
<h3 id="1-31-对象复用的了解，零拷贝的了解"><a href="#1-31-对象复用的了解，零拷贝的了解" class="headerlink" title="1.31 对象复用的了解，零拷贝的了解"></a>1.31 对象复用的了解，零拷贝的了解</h3><ul>
<li><p>对象复用：</p>
<ul>
<li>对象复用是指在程序执行过程中，重复使用已经创建的对象，而不是频繁地创建新的对象。通过对象复用，可以减少资源的消耗和提高性能。</li>
<li>对象复用通常适用于那些需要频繁创建和销毁的对象，比如线程池中的线程对象、连接池中的数据库连接等。通过将这些对象创建一次，然后在需要时重复利用，可以避免反复创建对象的开销，提高系统的效率。</li>
</ul>
</li>
<li><p>零拷贝：</p>
<ul>
<li>零拷贝是一种优化技术，用于在数据传输过程中减少或消除不必要的数据拷贝操作。通过零拷贝技术，可以提高数据传输的效率和降低系统的负载。</li>
<li>零拷贝通常应用于文件传输、网络通信等场景中。例如，在网络通信中，零拷贝技术可以避免将数据从用户空间拷贝到内核空间，再从内核空间拷贝到网络缓冲区的过程，而是直接在用户空间和网络缓冲区之间进行数据传输，从而提高了数据传输的效率。</li>
<li>零拷贝的主要实现有mmap() （内存映射）</li>
</ul>
</li>
</ul>
<blockquote>
<p>DMA(Direct Memory Access-直接内存访问)和零拷贝详细介绍 -&gt; <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/360343446">【linux】图文并茂|彻底搞懂零拷贝（Zero-Copy）技术</a></p>
</blockquote>
<h3 id="1-32-C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast"><a href="#1-32-C-的四种强制转换reinterpret-cast-const-cast-static-cast-dynamic-cast" class="headerlink" title="1.32 C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast &#x2F;dynamic_cast"></a>1.32 C++的四种强制转换reinterpret_cast&#x2F;const_cast&#x2F;static_cast &#x2F;dynamic_cast</h3><ul>
<li><p>reinterpret_cast：</p>
<ul>
<li>reinterpret_cast 可以用于将一个指针或引用转换为另一种不同类型的指针或引用。它可以执行任意类型之间的转换，甚至是不兼容的类型。</li>
<li>reinterpret_cast 对转换的类型没有限制，它不进行类型检查，因此需要谨慎使用。</li>
<li>reinterpret_cast 主要用于进行底层的类型转换，如指针之间的转换或者将整数类型转换为指针类型等。</li>
</ul>
</li>
<li><p>const_cast：</p>
<ul>
<li>const_cast 主要用于去除表达式中的 const 或 volatile 修饰符，以便修改被修饰对象的值。</li>
<li>const_cast 只能用于去除 const 或 volatile 限定符，不能进行其他类型的转换。</li>
<li>const_cast 的使用场景通常是在需要对 const 对象进行修改时，或者在调用函数时需要去除函数参数的 const 修饰符。</li>
</ul>
</li>
<li><p>static_cast：</p>
<ul>
<li>static_cast 用于执行静态类型转换，可以在编译时进行类型检查，因此比较安全。</li>
<li>static_cast 可以执行基本类型之间的转换，如整数之间的转换、指针类型之间的转换，以及类之间的上行转换（派生类指针向基类指针的转换）和下行转换（基类指针向派生类指针的转换）。</li>
<li>static_cast 也可以用于显式调用构造函数和转换构造函数进行类型转换。</li>
</ul>
</li>
<li><p>dynamic_cast：</p>
<ul>
<li>dynamic_cast 用于执行动态类型转换，主要用于在运行时进行类型检查和转换，通常用于处理继承关系的类。</li>
<li>dynamic_cast 只能用于类类型之间的转换，并且其中至少一个类必须具有虚函数。它用于在类层次结构中安全地进行上行转换和下行转换，并且在转换失败时返回 nullptr（对于指针类型）或抛出 std::bad_cast 异常（对于引用类型）。</li>
</ul>
</li>
</ul>
<h3 id="1-33-写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？"><a href="#1-33-写C-代码时有一类错误是-coredump-，很常见，你遇到过吗？怎么调试这个错误？" class="headerlink" title="1.33 写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？"></a>1.33 写C++代码时有一类错误是 coredump ，很常见，你遇到过吗？怎么调试这个错误？</h3><p>  coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p>
<p>  如何使用gdb调试coredump：</p>
<ul>
<li>分析core dump：使用调试工具（如gdb）来分析core dump文件。可以通过以下命令来启动gdb并加载core dump文件：  <pre><code class="bash">gdb [可执行文件名] [core文件名]
</code></pre>
</li>
<li>查看崩溃位置：在gdb中可以使用backtrace命令（简写为bt）来查看程序崩溃时的调用栈，这可以帮助你找到崩溃位置。命令如下：<pre><code class="bash">(gdb) bt
</code></pre>
</li>
<li>查看变量状态：通过在崩溃位置设置断点，并使用print命令来查看变量的值，可以帮助你理解程序崩溃的原因。例如：<pre><code class="bash">(gdb) break &lt;line_number&gt;
(gdb) run
(gdb) print &lt;variable_name&gt;
</code></pre>
</li>
</ul>
<h3 id="1-34-说说移动构造函数"><a href="#1-34-说说移动构造函数" class="headerlink" title="1.34 说说移动构造函数"></a>1.34 说说移动构造函数</h3><p>移动构造函数是C++11引入的一个特性，它允许在对象的所有权转移时执行高效的资源移动，而不是传统的拷贝。移动构造函数通常用于实现在不再需要源对象的情况下，将其内容“移动”到新创建的对象中，从而避免不必要的内存分配和数据复制。</p>
<p>移动构造函数的语法如下：</p>
<pre><code class="c++">class MyClass &#123;
public:
    // 移动构造函数
    MyClass(MyClass&amp;&amp; other) noexcept &#123;
        // 在此处执行资源的移动操作
        // 将other对象的资源转移到当前对象中
    &#125;
&#125;;
</code></pre>
<p>在移动构造函数中，参数通常是一个右值引用（通过使用双引号&amp;&amp;），表示将要被移动的对象。关键字<code>noexcept</code>是一个可选的说明符，表示该函数不会抛出异常。这对于某些情况下的优化是有帮助的。</p>
<p>移动构造函数通常用于以下几种情况：</p>
<ol>
<li>当返回临时对象时，避免不必要的拷贝。例如：<pre><code class="c++">MyClass createObject() &#123;
    MyClass temp;
    // 初始化temp对象
    return temp; // 调用移动构造函数而不是拷贝构造函数
&#125;
</code></pre>
</li>
<li>当将一个对象插入容器时，可以使用移动构造函数将对象移入容器中，而不是复制：<pre><code class="c++">std::vector&lt;MyClass&gt; myVector;
MyClass obj;
myVector.push_back(std::move(obj)); // 使用 std::move 将对象移入容器中
</code></pre>
</li>
<li>当需要动态分配内存时，可以使用移动语义来避免额外的内存拷贝。</li>
</ol>
<h3 id="1-35-C-中将临时变量作为返回值时的处理过程"><a href="#1-35-C-中将临时变量作为返回值时的处理过程" class="headerlink" title="1.35 C++中将临时变量作为返回值时的处理过程"></a>1.35 C++中将临时变量作为返回值时的处理过程</h3><p>首先需要明白一件事情，临时变量，在函数调用过程中是被压到程序进程的栈中的，当函数退出时，临时变量出栈，即临时变量已经被销毁，临时变量占用的内存空间没有被清空，但是可以被分配给其他变量，所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了</p>
<p>C语言里规定：16bit程序中，返回值保存在ax寄存器中，32bit程序中，返回值保持在eax寄存器中，如果是64bit返回值，edx寄存器保存高32bit，eax寄存器保存低32bit</p>
<p>由此可见，函数调用结束后，返回值被临时存储到寄存器中，并没有放到堆或栈中，也就是说与内存没有关系了。当退出函数的时候，临时变量可能被销毁，但是返回值却被放到寄存器中与临时变量的生命周期没有关系</p>
<p>如果我们需要返回值，一般使用赋值语句就可以了。</p>
<h3 id="1-36-如何获得结构成员相对于结构开头的字节偏移量"><a href="#1-36-如何获得结构成员相对于结构开头的字节偏移量" class="headerlink" title="1.36 如何获得结构成员相对于结构开头的字节偏移量"></a>1.36 如何获得结构成员相对于结构开头的字节偏移量</h3><p>使用&lt;stddef.h&gt;头文件中的，offsetof宏。</p>
<pre><code class="C++">#include &lt;cstddef&gt;
#include &lt;iostream&gt;

struct MyStruct &#123;
    int a;
    char b;
    double c;
&#125;;

int main() &#123;
    std::cout &lt;&lt; &quot;Offset of &#39;a&#39; in MyStruct: &quot; &lt;&lt; offsetof(MyStruct, a) &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Offset of &#39;b&#39; in MyStruct: &quot; &lt;&lt; offsetof(MyStruct, b) &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Offset of &#39;c&#39; in MyStruct: &quot; &lt;&lt; offsetof(MyStruct, c) &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<p>输出：</p>
<pre><code class="sql">Offset of &#39;a&#39; in MyStruct: 0
Offset of &#39;b&#39; in MyStruct: 4
Offset of &#39;c&#39; in MyStruct: 8
</code></pre>
<h3 id="1-37-怎样判断两个浮点数是否相等？"><a href="#1-37-怎样判断两个浮点数是否相等？" class="headerlink" title="1.37 怎样判断两个浮点数是否相等？"></a>1.37 怎样判断两个浮点数是否相等？</h3><p>对两个浮点数判断大小和是否相等不能直接用&#x3D;&#x3D;来判断，会出错！明明相等的两个数比较反而是不相等！对于两个浮点数比较只能通过<code>相减并与预先设定的精度比较</code>，记得要取绝对值！浮点数与0的比较也应该注意。与浮点数的表示方式有关。</p>
<h3 id="1-38-C-的标准库，STL及std的区别"><a href="#1-38-C-的标准库，STL及std的区别" class="headerlink" title="1.38 C++的标准库，STL及std的区别"></a>1.38 C++的标准库，STL及std的区别</h3><ul>
<li>std（Standard）</li>
<li>STL（Standard Template Library）  </li>
<li>STL是标准模板库，是标准库的子集。主要是容器、算法、迭代器。标准库还包括stream，string等，STL大约占了标准库内容得80%</li>
<li>std是命名空间的名字，目的是为了避免命名空间污染。模板库（包括stl）的设计者，特意在库文件里面加上了命名空间。这样，我们使用者就可以在定义自己的函数时，定义自己的命名空间。然后在自己定义的命名空间作用域范围内，使用我们自己定义的、但可能和标准库里的函数重名的函数。这样就不会有函数冲突了，使用时注意命名空间的作用域就好了！</li>
<li>模板库（包括stl，stream,string）中的所有名字的使用都得通过std::。</li>
</ul>
<h3 id="1-39-C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"><a href="#1-39-C-中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？" class="headerlink" title="1.39 C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？"></a>1.39 C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？</h3><p>在 C++ 中，指针参数传递和引用参数传递都可以用于实现函数之间的参数传递，它们之间有一些区别：</p>
<ol>
<li>指针参数传递：  <ul>
<li>指针参数传递是通过将参数声明为指针类型来实现的。在函数内部，可以通过解引用指针来访问参数所指向的对象。</li>
<li>指针参数传递需要在函数调用时传递指针的地址，因此需要额外的内存空间存储指针地址。（本质上是值传递，它所传递的是一个地址值。）</li>
<li>指针参数可以为空（即指向空指针），因此需要在函数内部进行空指针检查，以防止出现空指针异常。</li>
</ul>
</li>
<li>引用参数传递：  <ul>
<li>引用参数传递是通过将参数声明为引用类型来实现的。在函数内部，引用参数直接绑定到传递给函数的对象上，不需要解引用操作。</li>
<li>引用参数传递不需要额外的内存空间存储地址，因为引用本身就是目标对象的别名。</li>
<li>引用参数不能为空，因为引用必须引用一个有效的对象。</li>
</ul>
</li>
</ol>
<p>底层原理：  </p>
<ul>
<li>指针参数传递的底层原理是将指针的值（即地址）传递给函数，函数内部通过解引用指针来访问所指向的对象。</li>
<li>引用参数传递的底层原理是将引用绑定到传递给函数的对象上，因此在函数内部直接操作引用就相当于操作原始对象。</li>
</ul>
<p>总的来说，引用参数传递更加简洁和安全，因为它不需要对空指针进行检查，并且在函数调用时不会产生额外的开销。但是在某些情况下，指针参数传递可能更加灵活，例如需要允许空指针传递的情况。</p>
<h3 id="1-40-类如何实现只能静态分配和只能动态分配"><a href="#1-40-类如何实现只能静态分配和只能动态分配" class="headerlink" title="1.40 类如何实现只能静态分配和只能动态分配"></a>1.40 类如何实现只能静态分配和只能动态分配</h3><ul>
<li><strong>只能静态分配的类：</strong><br>如果希望类的对象只能在栈上分配，可以通过禁用类的动态内存分配来实现：<ul>
<li>删除<code>new</code>和<code>delete</code>运算符的重载</li>
<li>将它们声明为私有成员，以阻止类的用户使用动态内存分配<pre><code class="cpp">class StaticAllocatedClass &#123;
public:
    // 禁用 new 和 delete 运算符
    void* operator new(std::size_t) = delete;
    void operator delete(void*) = delete;
&#125;;
</code></pre>
</li>
</ul>
</li>
<li><strong>只能动态分配的类：</strong>  <ul>
<li>如果希望类的对象只能在堆上分配，可以在类中重载<code>new</code>和<code>delete</code>运算符，并将它们设置为私有或者保护成员，以防止用户直接调用。<pre><code class="cpp">class DynamicAllocatedClass &#123;
public:
    // 重载 new 和 delete 运算符
    void* operator new(std::size_t size) &#123;
        return ::operator new(size);
    &#125;
    void operator delete(void* ptr) &#123;
        ::operator delete(ptr);
    &#125;
private:
    // 防止直接创建对象
    DynamicAllocatedClass() &#123;&#125;
&#125;;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="1-41-知道C-中的组合吗？它与继承相比有什么优缺点吗？"><a href="#1-41-知道C-中的组合吗？它与继承相比有什么优缺点吗？" class="headerlink" title="1.41 知道C++中的组合吗？它与继承相比有什么优缺点吗？"></a>1.41 知道C++中的组合吗？它与继承相比有什么优缺点吗？</h3><p>在面向对象编程中，组合（Composition）是一种将多个类组合在一起创建新的类的方式。在组合关系中，一个类包含另一个类的实例作为其成员变量，这种关系表达了“具有”的关系，而不是“是一个”的关系。</p>
<p>与继承相比，组合的优缺点如下：</p>
<ul>
<li><p>优点：</p>
<ul>
<li>灵活性： 组合关系更灵活，因为它不会限制子类必须继承特定的行为或属性，而是通过组合已有的类来实现新的功能。</li>
<li>松耦合： 组合关系降低了类之间的耦合度，因为类之间的关系更加简单明确，不会引入不必要的依赖。</li>
<li>封装性： 组合可以带来更好的封装性，因为组合的类可以选择性地暴露其内部成员，对外部隐藏实现细节。</li>
<li>易于维护： 组合关系使得代码结构更清晰，易于理解和维护。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>代码重复： 在组合关系中，如果多个类都需要相同的功能或属性，可能会导致代码重复，增加了代码量和维护成本。</li>
<li>初始化复杂： 当一个类包含多个其他类的实例作为成员变量时，初始化对象可能变得更加复杂。</li>
<li>性能开销： 在运行时，由于需要额外的内存分配和对象构造，组合关系可能会引入一定的性能开销。</li>
</ul>
</li>
</ul>
<p>总的来说，组合关系提供了一种更加灵活和松耦合的方式来构建对象，可以避免继承带来的一些问题，但也需要注意代码重复和初始化复杂性等缺点。选择组合还是继承取决于具体的设计需求和问题领域，需要综合考虑各方面的因素来做出合适的选择。</p>
<h3 id="1-42-函数指针？"><a href="#1-42-函数指针？" class="headerlink" title="1.42 函数指针？"></a>1.42 函数指针？</h3><p>函数指针是指向函数的指针变量，它存储了函数的地址，可以用来间接地调用函数。在 C 和 C++ 中，函数指针的语法如下：</p>
<pre><code class="cpp">return_type (*pointer_name)(parameter_types);
</code></pre>
<p>函数指针在 C 和 C++ 中具有多种用途，包括但不限于以下几个方面：</p>
<ul>
<li><p>回调函数： 函数指针可以作为参数传递给其他函数，从而实现回调函数的机制。通过回调函数，可以在运行时指定需要调用的函数，从而实现灵活的控制流程。这在事件处理、信号处理等场景中非常常见。</p>
</li>
<li><p>动态选择函数： 函数指针可以根据不同的条件动态地选择调用不同的函数，从而实现更灵活的程序逻辑。这种技术常用于状态机、策略模式等场景。</p>
</li>
<li><p>实现多态性： 在 C++ 中，函数指针可以用于实现简单的多态性，虽然它不如虚函数表那样灵活，但可以实现类似的功能。通过函数指针，可以在运行时选择不同的函数实现，从而实现对象的多态行为。</p>
</li>
<li><p>动态加载库函数： 在动态链接库（DLL）和共享对象（SO）中，函数指针可以用于动态加载库函数，从而实现在运行时加载和调用特定库函数的功能。这在插件系统、动态扩展功能等场景中非常有用。</p>
</li>
</ul>
<h3 id="1-43-为什么要进行内存对齐"><a href="#1-43-为什么要进行内存对齐" class="headerlink" title="1.43 为什么要进行内存对齐"></a>1.43 为什么要进行内存对齐</h3><p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度.</p>
<p>现在考虑4字节存取粒度的处理器取int类型变量（32位系统），该处理器只能从地址为4的倍数的内存开始读取数据。</p>
<p>假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的连续四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作.</p>
<h3 id="1-44-内存对齐规则"><a href="#1-44-内存对齐规则" class="headerlink" title="1.44 内存对齐规则"></a>1.44 内存对齐规则</h3><ul>
<li>每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认<code>#pragma pack(4)</code>，可以通过预编译命令#pragma pack(n)，n &#x3D; 1,2,4,8,16来改变这一系数。</li>
</ul>
<p>有效对其值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。</p>
<p>了解了上面的概念后，我们现在可以来看看内存对齐需要遵循的规则：</p>
<ul>
<li><p><strong>基本类型的对齐规则：</strong> 基本数据类型在内存中的存储位置通常要求是其自身大小的整数倍。例如，一个字节大小的字符通常需要对齐到地址为1的位置，一个四字节大小的整数通常需要对齐到地址为4的位置。</p>
</li>
<li><p><strong>结构体和类的对齐规则：</strong> 结构体和类的对齐规则是其成员中大小最大的成员大小的整数倍。这样做的目的是为了保证结构体或类的成员都能够按照其自身的对齐要求存储，从而保证结构体或类的实例的起始地址是合法的。</p>
</li>
<li><p><strong>指针类型的对齐规则：</strong> 指针类型的大小通常与机器的地址长度相等，因此指针类型的对齐规则通常与基本类型的对齐规则相同。</p>
</li>
</ul>
<h3 id="1-45-static变量"><a href="#1-45-static变量" class="headerlink" title="1.45 static变量"></a>1.45 static变量</h3><p>静态变量是在程序执行期间存在且只初始化一次的变量，它的生存周期与程序的运行周期相同。在C和C++中，静态变量可以分为两种类型：</p>
<ul>
<li><p>局部静态变量（Static Local Variable）： 在函数内部声明的静态变量称为局部静态变量。这些变量在函数被调用时被创建，在程序的整个生命周期内保持存在，并且只被初始化一次。局部静态变量的作用域仅限于声明它们的函数内部。</p>
<pre><code class="cpp">void func() &#123;
    static int count = 0; // 局部静态变量
    count++;
    printf(&quot;Count: %d\n&quot;, count);
&#125;
</code></pre>
</li>
<li><p>全局静态变量（Static Global Variable）： 在函数外部声明的静态变量称为全局静态变量。这些变量在程序启动时被创建，在程序的整个生命周期内保持存在，并且只被初始化一次。全局静态变量的作用域为<code>整个文件</code>，对其他文件不可见（除非使用<code>extern</code>关键字进行声明）。</p>
<pre><code class="cpp">static int globalVar = 5; // 全局静态变量
</code></pre>
</li>
<li><p>静态变量的特点包括：</p>
<ul>
<li>在内存中分配固定的存储空间，存储在静态存储区域。</li>
<li>生命周期与程序运行周期相同，程序结束时才被销毁。</li>
<li>未初始化时，默认值为0。</li>
<li>局部静态变量在函数内部可见，全局静态变量在整个文件内可见。</li>
<li>静态变量的值在函数调用之间保持不变。</li>
<li>静态变量在程序中的应用包括：存储全局状态、实现单例模式、记录函数调用次数等。由于静态变量的生存周期和作用域特性，它们通常用于需要持久存储数据的情况。</li>
</ul>
</li>
</ul>
<h3 id="1-46-extern和static"><a href="#1-46-extern和static" class="headerlink" title="1.46 extern和static"></a>1.46 extern和static</h3><p><code>extern</code>和<code>static</code>都是用来限定变量或函数的作用域和链接属性的关键字，但它们的作用方式有所不同。</p>
<ul>
<li><p>extern：</p>
<ul>
<li><p>extern 用于声明变量或函数，表示该变量或函数是在其他源文件中定义的，当前源文件中只是进行了声明，实际定义在其他地方。</p>
</li>
<li><p>当使用 extern 声明变量时，编译器不会为该变量分配存储空间，只是告诉编译器该变量是在其他地方定义的。</p>
</li>
<li><p>extern 声明通常用于在多个源文件中共享全局变量或函数的声明。</p>
</li>
</ul>
<p>例如：</p>
<pre><code class="cpp">// File1.cpp
int globalVar = 5; // 定义全局变量

// File2.cpp
extern int globalVar; // 声明全局变量
</code></pre>
</li>
<li><p>static：</p>
<ul>
<li><p>static 用于声明静态变量或函数，限定其作用域为当前文件，在其他文件中无法访问。</p>
</li>
<li><p>当使用 static 声明变量或函数时，它们的作用域仅限于当前源文件，对其他源文件不可见。</p>
</li>
<li><p>对于全局变量，static 关键字也可以用于限定其链接属性，使其只能在当前文件中访问，称为文件作用域全局变量。</p>
</li>
</ul>
<p>例如：</p>
<pre><code class="cpp">// File1.cpp
static int localVar = 10; // 声明文件作用域的静态变量

// File2.cpp
// 在 File2.cpp 中无法访问 localVar
</code></pre>
</li>
</ul>
<p>总结：</p>
<ul>
<li><p>extern 用于声明外部变量或函数，使得在当前文件中可以引用其他文件中定义的全局变量或函数。</p>
</li>
<li><p>static 用于限定变量或函数的作用域为当前文件，使得它们只能在当前文件中可见，对其他文件不可见。</p>
</li>
</ul>
<h3 id="1-47-如何在不使用额外空间的情况下，交换两个数？你有几种方法"><a href="#1-47-如何在不使用额外空间的情况下，交换两个数？你有几种方法" class="headerlink" title="1.47 如何在不使用额外空间的情况下，交换两个数？你有几种方法"></a>1.47 如何在不使用额外空间的情况下，交换两个数？你有几种方法</h3><ol>
<li>使用加法和减法：<pre><code class="cpp">a = a + b;
b = a - b;
a = a - b;
</code></pre>
</li>
<li>使用异或操作：<pre><code class="cpp">a = a ^ b;
b = a ^ b;
a = a ^ b;
</code></pre>
</li>
<li>使用加法和位移：<pre><code class="cpp">a = a + b;
b = a - b;
a = (a - b) &gt;&gt; 1;
</code></pre>
</li>
<li>使用乘法和除法：<pre><code class="cpp">a = a * b;
b = a / b;
a = a / b;
</code></pre>
</li>
</ol>
<p>这些方法都是在不使用额外空间的情况下，通过数学运算来交换两个数的值。其中，使用异或操作是最常见的方法，因为它既简单又高效。</p>
<h3 id="1-48-strcpy-和-memcpy-的区别"><a href="#1-48-strcpy-和-memcpy-的区别" class="headerlink" title="1.48 strcpy 和 memcpy 的区别"></a>1.48 strcpy 和 memcpy 的区别</h3><ol>
<li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 </li>
<li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 </li>
<li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li>
</ol>
<h3 id="1-49-程序在执行int-main-int-argc-char-argv-时的内存结构"><a href="#1-49-程序在执行int-main-int-argc-char-argv-时的内存结构" class="headerlink" title="1.49 程序在执行int main(int argc, char *argv[])时的内存结构"></a>1.49 程序在执行int main(int argc, char *argv[])时的内存结构</h3><p>参数的含义是程序在命令行下运行的时候，需要输入argc 个参数，每个参数是以char 类型输入的，依次存在数组里面，数组是 argv[]，所有的参数在指针</p>
<p><code>char *</code>指向的内存中，数组的中元素的个数为<code>argc</code>个，第一个参数为<code>程序的名称</code>。</p>
<h3 id="1-50-volatile关键字的作用？"><a href="#1-50-volatile关键字的作用？" class="headerlink" title="1.50 volatile关键字的作用？"></a>1.50 volatile关键字的作用？</h3><p><code>volatile</code>关键字用于告诉编译器，被 volatile 修饰的变量可能会在程序执行过程中被意外修改，因此编译器不应该对这些变量进行优化。</p>
<p>具体来说，volatile 关键字的作用包括：</p>
<ul>
<li><p><code>防止编译器优化</code>： 声明变量为 volatile 后，编译器会将对该变量的访问、赋值等操作视为有可能受到外部因素影响，因此不会对这些操作进行优化，确保编译后的代码与源代码中的操作顺序一致。</p>
</li>
<li><p><code>指示变量可能被多线程或中断处理程序修改</code>： 在多线程或中断处理程序的环境中，某些变量的值可能会被其他线程或中断处理程序修改，而这些修改对于程序的正确执行具有重要影响。通过使用 volatile 关键字，可以告诉编译器这些变量的值可能会在程序执行过程中被修改，因此需要每次访问都重新从内存中读取值，而不是使用缓存中的值。</p>
</li>
</ul>
<p><code>volatile</code>关键字通常在以下情况下使用：</p>
<ol>
<li><p><code>硬件操作或内存映射</code>： 当变量代表硬件寄存器或内存映射的状态时，可能会被外部设备或中断处理程序修改。在这种情况下，将变量声明为 volatile 可以确保编译器不会对其进行优化，以防止意外的行为。</p>
</li>
<li><p><code>多线程环境下共享变量</code>： 在多线程程序中，共享变量可能会被多个线程同时访问和修改。如果这些变量没有使用同步机制进行保护，那么在读取和写入这些变量时可能会发生竞态条件。在这种情况下，将共享变量声明为 volatile 可以告诉编译器不要对其进行优化，以确保每次访问都是从内存中读取最新值。</p>
</li>
<li><p><code>信号处理程序中使用的全局变量</code>： 在信号处理程序中，全局变量的值可能会在程序的正常执行流程之外被修改。为了确保信号处理程序能够正确地读取和修改这些变量，通常会将它们声明为 volatile。</p>
</li>
</ol>
<h3 id="1-51-如果有一个空类，它会默认添加哪些函数？"><a href="#1-51-如果有一个空类，它会默认添加哪些函数？" class="headerlink" title="1.51 如果有一个空类，它会默认添加哪些函数？"></a>1.51 如果有一个空类，它会默认添加哪些函数？</h3><pre><code class="C++">MyClass(); // 缺省构造函数
MyClass( const MyClass&amp; ); // 拷贝构造函数
~MyClass(); // 析构函数
MyClass&amp; operator=( const MyClass&amp; ); // 赋值运算符
</code></pre>
<h3 id="1-52-说一说strcpy、sprintf与memcpy这三个函数的不同之处"><a href="#1-52-说一说strcpy、sprintf与memcpy这三个函数的不同之处" class="headerlink" title="1.52 说一说strcpy、sprintf与memcpy这三个函数的不同之处"></a>1.52 说一说strcpy、sprintf与memcpy这三个函数的不同之处</h3><ol>
<li><strong>操作对象不同</strong></li>
</ol>
<ul>
<li><p>strcpy的两个操作对象均为字符串</p>
</li>
<li><p>sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串</p>
</li>
<li><p>memcpy的两个对象就是两个任意可操作的内存地址，并不限于何种数据类型。</p>
</li>
</ul>
<ol start="2">
<li><p><strong>执行效率不同</strong><br>memcpy最高，strcpy次之，sprintf的效率最低。</p>
</li>
<li><p><strong>实现功能不同</strong></p>
</li>
</ol>
<ul>
<li><p>strcpy主要实现字符串变量间的拷贝</p>
</li>
<li><p>sprintf主要实现其他数据类型格式到字符串的转化</p>
</li>
<li><p>memcpy主要是内存块间的拷贝</p>
</li>
</ul>
<h3 id="1-53-如何阻止一个类被实例化？有哪些方法"><a href="#1-53-如何阻止一个类被实例化？有哪些方法" class="headerlink" title="1.53 如何阻止一个类被实例化？有哪些方法"></a>1.53 如何阻止一个类被实例化？有哪些方法</h3><ol>
<li><code>将构造函数声明为私有（private）</code>： 将类的构造函数声明为私有，这样外部代码就无法直接调用该构造函数实例化对象。但是需要注意的是，类的静态成员函数仍然可以访问私有构造函数，因此可以在类的静态成员函数中实现对象的创建，从而控制对象的实例化。</li>
<li><code>删除构造函数的定义</code>： C++11 引入了删除函数的特性，可以通过将构造函数的定义删除来阻止对象的实例化。删除构造函数的定义后，任何尝试调用该构造函数的操作都会导致编译错误。</li>
<li><code>将构造函数声明为纯虚函数</code>： 将构造函数声明为纯虚函数，这样派生类必须实现自己的构造函数，而基类则无法被实例化。</li>
</ol>
<h3 id="1-54-strcpy函数和strncpy函数的区别？哪个函数更安全？"><a href="#1-54-strcpy函数和strncpy函数的区别？哪个函数更安全？" class="headerlink" title="1.54 strcpy函数和strncpy函数的区别？哪个函数更安全？"></a>1.54 strcpy函数和strncpy函数的区别？哪个函数更安全？</h3><ul>
<li><code>strcpy</code>：<ul>
<li>函数原型：char *strcpy(char *dest, const char *src);  </li>
<li>功能：将源字符串（以空字符结尾）拷贝到目标字符串中，包括空字符。</li>
<li>安全性：strcpy 不检查目标字符串的长度，如果源字符串比目标字符串长，可能会发生缓冲区溢出，导致未定义的行为。</li>
</ul>
</li>
<li><code>strncpy</code>：<ul>
<li>函数原型：char *strncpy(char *dest, const char *src, size_t n);</li>
<li>功能：将源字符串的前 n 个字符拷贝到目标字符串中，如果源字符串长度小于 n，则在目标字符串中用空字符填充剩余部分。</li>
<li>安全性：相比于 strcpy，strncpy 更安全，因为它可以指定拷贝的最大长度，避免了缓冲区溢出的风险。但需要注意，如果源字符串的长度大于 n，则目标字符串不会以空字符结尾，因此可能需要<code>手动添加空字符</code>。</li>
</ul>
</li>
</ul>
<p>因此，从安全性的角度来看，strncpy 更安全一些，但需要确保目标字符串足够大以容纳指定长度的内容。另外，使用 strncpy 时应格外小心，确保目标字符串始终以空字符结尾，以避免字符串操作中出现意外行为。</p>
<h3 id="1-55-写一个比较大小的模板函数"><a href="#1-55-写一个比较大小的模板函数" class="headerlink" title="1.55 写一个比较大小的模板函数"></a>1.55 写一个比较大小的模板函数</h3><pre><code class="C++">template &lt;typename T&gt;
T max(T a, T b)&#123;
  return a &gt; b ? a : b;
&#125;
</code></pre>
<h3 id="1-56-成员函数里memset-this-0-sizeof-this-会发生什么"><a href="#1-56-成员函数里memset-this-0-sizeof-this-会发生什么" class="headerlink" title="1.56 成员函数里memset(this,0,sizeof(*this))会发生什么"></a>1.56 成员函数里memset(this,0,sizeof(*this))会发生什么</h3><p>在成员函数中调用<code>memset(this, 0, sizeof(*this))</code>将会把当前对象所占内存的前<code>sizeof(*this)</code>字节全部设置为零。这样做会将对象的所有成员变量都设置为零值，但这种做法可能会导致一些问题，特别是对于<code>含有虚函数或虚继承的类</code>。</p>
<p>具体来说，<code>memset</code>函数是用来将一段内存块设置为指定的值的，但它只是简单地按字节设置，对于非 POD（Plain Old Data）类型的对象，这种简单的内存设置可能会导致对象中的某些数据结构被破坏，从而导致程序出错。</p>
<p>对于含有虚函数的类，调用<code>memset</code>可能会破坏虚<code>函数表（vtable）指针</code>，导致虚函数调用出错。对于含有虚继承的类，调用<code>memset</code>会破坏<code>虚基类指针（vptr）</code>，同样会导致程序出错。</p>
<p>因此，一般情况下不建议在成员函数中直接使用 memset 来清零对象的内存，而是应该使用更安全的方式来初始化对象的成员变量。</p>
<h3 id="1-57-C-从代码到可执行程序经历了什么"><a href="#1-57-C-从代码到可执行程序经历了什么" class="headerlink" title="1.57 C++从代码到可执行程序经历了什么"></a>1.57 C++从代码到可执行程序经历了什么</h3><ol>
<li><p><strong>编写代码</strong>：首先，程序员编写C++源代码，这些代码通常包含在一个或多个源文件中。</p>
</li>
<li><p><strong>预处理</strong>：在编译之前，源代码经过预处理器处理。预处理器执行诸如<code>宏替换</code>、<code>条件编译</code>等操作，生成经过预处理的源代码文件。</p>
</li>
<li><p><strong>编译</strong>：编译器将预处理后的源代码转换为汇编代码。这个阶段的任务是将高级语言代码转换为机器语言代码，生成相应的目标文件。</p>
</li>
<li><p><strong>汇编</strong>：汇编器将汇编代码转换为机器可执行的二进制代码。它将每条汇编指令翻译成机器指令，并生成目标文件。</p>
</li>
<li><p><strong>链接</strong>：链接器将生成的目标文件与所需的库文件链接在一起，创建一个完整的可执行程序。它解析程序中使用的符号引用，将它们与符号定义关联起来，并解决外部符号的引用。最终，链接器产生一个可执行文件，其中包含程序的所有指令和数据。</p>
</li>
<li><p><strong>优化</strong>：在编译和链接过程中，还可以应用各种优化技术来提高程序的性能和效率。这些优化包括但不限于代码优化、内联函数、循环优化等。</p>
</li>
<li><p><strong>生成可执行文件</strong>：经过链接和优化后，最终生成可执行文件，即可以在特定平台上运行的二进制文件。这个可执行文件包含了程序的所有代码和数据，可以直接在计算机上执行。</p>
</li>
<li><p><strong>运行程序</strong>：最终，用户可以运行生成的可执行程序，执行程序中定义的操作和功能。</p>
</li>
</ol>
<p>这些步骤通常由编译器和链接器自动完成，用户只需要编写和调试源代码即可。</p>
<h3 id="1-58-友元函数和友元类"><a href="#1-58-友元函数和友元类" class="headerlink" title="1.58 友元函数和友元类"></a>1.58 友元函数和友元类</h3><p>在C++中，友元函数和友元类是用来提供对类的私有成员的访问权限的机制，它们可以访问类的私有成员，即使这些成员在类的定义中被声明为私有的也可以。它们的区别在于：</p>
<ul>
<li>友元函数：友元函数是在类的外部声明的普通函数，可以访问类的所有成员。要声明一个函数为类的友元函数，需要在类的定义中使用 friend 关键字来声明。友元函数并不属于类的成员函数，它们可以通过对象或类名来调用。<pre><code class="cpp">class MyClass &#123;
    friend void friendFunction();
private:
    int privateMember;
&#125;;

void friendFunction() &#123;
    MyClass obj;
    obj.privateMember = 10; // 可以访问私有成员
&#125;
</code></pre>
</li>
<li>友元类：友元类是指一个类可以访问另一个类的私有成员。同样地，在类的定义中使用 friend 关键字来声明一个类为友元类。友元类可以访问被声明为友元类的类的所有成员，包括私有成员和保护成员。<pre><code class="cpp">class MyClass &#123;
    friend class FriendClass;
private:
    int privateMember;
&#125;;

class FriendClass &#123;
public:
    void accessPrivateMember(MyClass&amp; obj) &#123;
        obj.privateMember = 10; // 可以访问私有成员
    &#125;
&#125;;
</code></pre>
</li>
</ul>
<p>友元函数和友元类的使用可以提供更灵活的访问控制，但同时也会破坏了类的封装性，因此应该谨慎使用。</p>
<h3 id="1-59-自旋锁"><a href="#1-59-自旋锁" class="headerlink" title="1.59 自旋锁"></a>1.59 自旋锁</h3><p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p>
<h3 id="1-60-为什么C-没有垃圾回收机制？这点跟Java不太一样。"><a href="#1-60-为什么C-没有垃圾回收机制？这点跟Java不太一样。" class="headerlink" title="1.60 为什么C++没有垃圾回收机制？这点跟Java不太一样。"></a>1.60 为什么C++没有垃圾回收机制？这点跟Java不太一样。</h3><ul>
<li>实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。</li>
<li>垃圾回收会使得C++不适合进行很多底层的操作。</li>
</ul>
<h2 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h2><h3 id="2-1-简要说明C-的内存分区"><a href="#2-1-简要说明C-的内存分区" class="headerlink" title="2.1 简要说明C++的内存分区"></a>2.1 简要说明C++的内存分区</h3><p>C++中的内存分区，分别是堆、栈、自由存储区、全局&#x2F;静态存储区、常量存储区和代码区。  </p>
<ul>
<li><p><strong>栈</strong>：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限</p>
</li>
<li><p><strong>堆</strong>：就是那些由 new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个 delete。<code>如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收</code></p>
</li>
<li><p><strong>自由存储区</strong>：如果说堆是操作系统维护的一块内存，那么自由存储区就是C++中通过new和delete动态分配和释放对象的抽象概念。需要注意的是，<code>自由存储区和堆比较像，但不等价</code></p>
</li>
<li><p><strong>全局&#x2F;静态存储区</strong>：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，<code>在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0</code></p>
</li>
<li><p><strong>常量存储区</strong>：这是一块比较特殊的存储区，这里面存放的是常量，<code>不允许修改</code></p>
</li>
<li><p><strong>代码区</strong>：存放函数体的二进制代码</p>
</li>
</ul>
<h3 id="2-2-什么是内存池，如何实现"><a href="#2-2-什么是内存池，如何实现" class="headerlink" title="2.2 什么是内存池，如何实现"></a>2.2 什么是内存池，如何实现</h3><p>内存池（Memory Pool） 是一种内存分配方式。通常我们习惯直接使用new、malloc 等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。</p>
<pre><code class="cpp">// 内存池
#include &quot;list&quot;

class MemoryPool&#123;
private:
    std::list&lt;char*&gt; m_blocks;
    unsigned int m_bloackNum;
public:
    MemoryPool(size_t size, unsigned int num)&#123;
        m_bloackNum = num;
        for(unsigned int i = 0; i &lt; num; ++i)&#123;
            m_blocks.push_back(new char[size]);
        &#125;
    &#125;

    ~MemoryPool()&#123;
        for(auto b : m_blocks)&#123;
            delete[] b;
            b = nullptr;
        &#125;
    &#125;

    char* allocate()&#123;
        if(m_blocks.empty())&#123;
            throw std::bad_alloc();
        &#125;
        char* b = m_blocks.front();
        m_blocks.pop_front();
        return b;
    &#125;

    void deallocate(void* block)&#123;
        m_blocks.push_back(static_cast&lt;char*&gt;(block));
    &#125;
&#125;;
</code></pre>
<h3 id="2-3-几个this指针的易混问题"><a href="#2-3-几个this指针的易混问题" class="headerlink" title="2.3 几个this指针的易混问题"></a>2.3 几个this指针的易混问题</h3><ul>
<li><p><strong>this指针是什么时候创建的？</strong><br>this在成员函数的开始执行前构造，在成员的执行结束后清除。</p>
</li>
<li><p><strong>this指针存放在何处？堆、栈、全局变量，还是其他？</strong><br>this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量。在汇编级别里面，一个值只会以3种形式出现：立即数、寄存器值和内存变量值。不是存放在寄存器就是存放在内存中，它们并不是和高级语言变量对应的。</p>
</li>
<li><p><strong>每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调用函数？</strong><br>普通的类函数（不论是成员函数，还是静态函数）都不会创建一个函数表来保存函数指针。只有虚函数才会被放到函数表中。但是，即使是虚函数，如果编译期就能明确知道调用的是哪个函数，编译器就不会通过函数表中的指针来间接调用，而是会直接调用该函数。正是由于this指针的存在，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰。</p>
</li>
</ul>
<h3 id="2-4-内存泄漏的后果？如何监测？解决方法？"><a href="#2-4-内存泄漏的后果？如何监测？解决方法？" class="headerlink" title="2.4 内存泄漏的后果？如何监测？解决方法？"></a>2.4 内存泄漏的后果？如何监测？解决方法？</h3><ul>
<li>后果<br>只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种症状：性能下降到内存逐渐用完，导致另一个程序失败；  </li>
<li>如何监测<br>使用专门的内存泄漏检测工具，例如Valgrind、AddressSanitizer(ASan)、LeakSanitizer等，这些工具能够帮助检测程序中的内存泄漏问题，并给出详细的报告和堆栈信息。<ul>
<li>使用 -g 编译选项开启符号信息生成，然后使用Valgrind执行测试<br><img src="/2023/01/23/C++%E5%85%AB%E8%82%A1%E6%96%87/debug001.png"></li>
<li>编译时使用<code>-fsanitize=address</code>选项来开启<code>AddressSanitizer</code><pre><code class="bash">g++ -fsanitize=address -g your_code.cpp -o your_executable
</code></pre>
或使用<code>-fsanitize=leak</code>选项来开启<code>LeakSanitizer</code><br><img src="/2023/01/23/C++%E5%85%AB%E8%82%A1%E6%96%87/debug002.png"><br><img src="/2023/01/23/C++%E5%85%AB%E8%82%A1%E6%96%87/debug003.png"></li>
</ul>
</li>
<li>解决方法<br>智能指针。代码审查。</li>
</ul>
<h4 id="2-4-1-使用-g-选项编译程序有什么作用"><a href="#2-4-1-使用-g-选项编译程序有什么作用" class="headerlink" title="2.4.1.使用 -g 选项编译程序有什么作用"></a>2.4.1.使用 -g 选项编译程序有什么作用</h4><p>使用 -g 选项编译程序的作用是生成调试信息（debug information），这些调试信息包含了源代码和目标代码之间的映射关系，以及变量名、函数名等符号信息。具体来说，-g 选项会将调试信息嵌入到可执行文件中，以便在程序执行时能够进行调试和分析。</p>
<p>主要作用包括：</p>
<ol>
<li><p>源代码和目标代码映射关系：调试信息可以帮助调试器将源代码的行号和目标代码的地址进行映射，从而在调试过程中能够准确地定位到源代码的位置。这样可以更方便地进行断点设置、单步调试等操作。</p>
</li>
<li><p>变量名、函数名等符号信息：调试信息中包含了变量名、函数名等符号信息，使得调试器能够识别和显示这些符号，从而更容易地理解程序的结构和逻辑。</p>
</li>
<li><p>错误信息定位：当程序发生错误时，调试信息可以帮助调试器准确地定位到错误的源代码位置，从而更容易地进行错误排查和修复。</p>
</li>
<li><p>内存检测工具支持：一些内存检测工具（如 Valgrind 的 Memcheck）需要在调试信息的基础上进行分析和检测，因此编译时需要使用 -g 选项生成调试信息。</p>
</li>
</ol>
<h3 id="2-5-在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#2-5-在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="2.5 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>2.5 在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h3><p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。</p>
<blockquote>
<p><strong>为什么是不可预期的问题？</strong><br>delete this之后不是释放了类对象的内存空间了么，那么这段内存应该已经还给系统，不再属于这个进程。照这个逻辑来看，应该发生指针错误，无访问权限之类的令系统崩溃的问题才对啊？这个问题牵涉到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。</p>
</blockquote>
<h3 id="2-6-如果在类的析构函数中调用delete-this，会发生什么？"><a href="#2-6-如果在类的析构函数中调用delete-this，会发生什么？" class="headerlink" title="2.6 如果在类的析构函数中调用delete this，会发生什么？"></a>2.6 如果在类的析构函数中调用delete this，会发生什么？</h3><p>可能会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p>
<h3 id="2-7-请说一下以下几种情况下，下面几个类的大小各是多少？"><a href="#2-7-请说一下以下几种情况下，下面几个类的大小各是多少？" class="headerlink" title="2.7 请说一下以下几种情况下，下面几个类的大小各是多少？"></a>2.7 请说一下以下几种情况下，下面几个类的大小各是多少？</h3><pre><code class="cpp">class A &#123;&#125;;
int main()&#123;
  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1;
  A a; 
  cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1;
  return 0;
&#125;
/*空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。

空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。
*/
</code></pre>
<pre><code class="cpp">class A &#123; virtual void Fun()&#123;&#125; &#125;;
int main()&#123;
  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器);
  A a; 
  cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器);
  return 0;
&#125;
// 因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节
</code></pre>
<pre><code class="cpp">class A &#123; static int a; &#125;;
int main()&#123;
  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1;
  A a; 
  cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1;
  return 0;
&#125;
// 静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小
</code></pre>
<pre><code class="cpp">class A &#123; int a; &#125;;
int main()&#123;
  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4;
  A a; 
  cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4;
  return 0;
&#125;
</code></pre>
<h3 id="2-8-类对象的大小受哪些因素影响？"><a href="#2-8-类对象的大小受哪些因素影响？" class="headerlink" title="2.8 类对象的大小受哪些因素影响？"></a>2.8 类对象的大小受哪些因素影响？</h3><ul>
<li><p>类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；</p>
</li>
<li><p>内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的；</p>
</li>
<li><p>虚函数的话，会在类对象插入vptr指针，加上指针大小；</p>
</li>
<li><p>当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展。</p>
</li>
</ul>
<h2 id="三、C-11新标准"><a href="#三、C-11新标准" class="headerlink" title="三、C++11新标准"></a>三、C++11新标准</h2><h3 id="3-1-C-11有哪些新特性？"><a href="#3-1-C-11有哪些新特性？" class="headerlink" title="3.1 C++ 11有哪些新特性？"></a>3.1 C++ 11有哪些新特性？</h3><ul>
<li>nullptr替代 NULL</li>
<li>引入了 auto 和 decltype 这两个关键字实现了类型推导</li>
<li>基于范围的 for 循环for(auto&amp; i : res){}</li>
<li>类和结构体的中初始化列表</li>
<li>Lambda 表达式（匿名函数）</li>
<li>std::forward_list（单向链表）</li>
<li>右值引用和move语义</li>
<li>…</li>
</ul>
<h3 id="3-2-智能指针的原理、常用的智能指针及实现"><a href="#3-2-智能指针的原理、常用的智能指针及实现" class="headerlink" title="3.2 智能指针的原理、常用的智能指针及实现"></a>3.2 智能指针的原理、常用的智能指针及实现</h3><ul>
<li><p><strong>原理</strong><br>智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源</p>
</li>
<li><p><strong>常用的智能指针</strong>  </p>
<ul>
<li><p><strong>unique_ptr</strong><br>它是一种独占所有权的智能指针，即它不能被复制或拷贝。当unique_ptr被销毁时，它所指向的对象会被自动释放。这使得unique_ptr非常适合管理动态分配的单个对象。</p>
</li>
<li><p><strong>shared_ptr</strong><br>它是一种共享所有权的智能指针，可以被多个shared_ptr共享同一个对象。它使用引用计数来跟踪指向对象的指针数量，并在没有指针指向对象时自动释放对象。当最后一个shared_ptr销毁时，对象会被释放。</p>
</li>
<li><p><strong>weak_ptr</strong><br>它是一种弱引用的智能指针，用于解决shared_ptr的循环引用问题。weak_ptr可以从shared_ptr创建，但不会增加引用计数。因此，它不会阻止对象的销毁。通常在需要访问shared_ptr所管理的对象，但又不需要拥有所有权时使用。</p>
</li>
<li><p><strong>auto_ptr（C++11之前）</strong><br>它是早期版本的C++标准中提供的智能指针，类似于unique_ptr，但具有一些缺陷，并在C++11中被std::unique_ptr取代。auto_ptr没有明确定义的行为来处理拷贝和赋值操作，因此容易导致问题。</p>
</li>
</ul>
</li>
<li><p><strong>智能指针shared_ptr代码实现</strong></p>
</li>
</ul>
<pre><code class="cpp">template&lt;typename T&gt;
class SharedPtr
&#123;
public:
    SharedPtr(T* ptr = NULL):_ptr(ptr), _pcount(new int(1))
    &#123;&#125;

    SharedPtr(const SharedPtr&amp; s):_ptr(s._ptr), _pcount(s._pcount)&#123;
        (*_pcount)++;
    &#125;

    SharedPtr&lt;T&gt;&amp; operator=(const SharedPtr&amp; s)&#123;
        if (this != &amp;s)
        &#123;
            if (--(*(this-&gt;_pcount)) == 0)
            &#123;
                delete this-&gt;_ptr;
                delete this-&gt;_pcount;
            &#125;
            _ptr = s._ptr;
            _pcount = s._pcount;
            (*_pcount)++;
        &#125;
        return *this;
    &#125;
    T&amp; operator*()
    &#123;
        return *(this-&gt;_ptr);
    &#125;
    T* operator-&gt;()
    &#123;
        return this-&gt;_ptr;
    &#125;
    ~SharedPtr()
    &#123;
        --(*(this-&gt;_pcount));
        if (*(this-&gt;_pcount) == 0)
        &#123;
            delete _ptr;
            _ptr = NULL;
            delete _pcount;
            _pcount = NULL;
        &#125;
    &#125;
private:
    T* _ptr;
    int* _pcount;//指向引用计数的指针
&#125;;
</code></pre>
<h3 id="3-3-lambda函数"><a href="#3-3-lambda函数" class="headerlink" title="3.3 lambda函数"></a>3.3 lambda函数</h3><pre><code class="cpp">[capture-list] (parameter-list) -&gt; return-type &#123;
    // 函数体
&#125;
</code></pre>
<ul>
<li>capture-list：捕获列表，用于捕获外部变量。可以是值传递方式（[var]）或引用传递方式（[&amp;var]）。还可以使用[&#x3D;]表示以值传递方式捕获所有外部变量，或使用[&amp;]表示以引用传递方式捕获所有外部变量。</li>
<li>parameter-list：参数列表，与普通函数的参数列表类似。</li>
<li>return-type：返回类型，可以省略，编译器会根据返回语句自动推断返回类型。</li>
<li>{}：函数体，与普通函数的函数体类似。</li>
</ul>
<pre><code class="cpp">#include &lt;iostream&gt;

int main() &#123;
    // Lambda表达式求两个数的和
    auto sum = [](int a, int b) -&gt; int &#123;
        return a + b;
    &#125;;

    // 调用lambda表达式
    int result = sum(3, 4);
    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; result &lt;&lt; std::endl;

    return 0;
&#125;
</code></pre>
<h3 id="3-4-shared-ptr的循环引用问题"><a href="#3-4-shared-ptr的循环引用问题" class="headerlink" title="3.4 shared_ptr的循环引用问题"></a>3.4 shared_ptr的循环引用问题</h3><p>当两个对象相互引用并使用<code>shared_ptr</code>时，就会形成循环引用。例如，考虑一个简单的场景：</p>
<pre><code class="cpp">#include &lt;memory&gt;
#include &lt;iostream&gt;

class B; // 前置声明

class A &#123;
public:
    std::shared_ptr&lt;B&gt; b_ptr;
    A() &#123; std::cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; std::endl; &#125;
    ~A() &#123; std::cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; std::endl; &#125;
&#125;;

class B &#123;
public:
    std::shared_ptr&lt;A&gt; a_ptr;
    B() &#123; std::cout &lt;&lt; &quot;B constructor&quot; &lt;&lt; std::endl; &#125;
    ~B() &#123; std::cout &lt;&lt; &quot;B destructor&quot; &lt;&lt; std::endl; &#125;
&#125;;

int main() &#123;
    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;();
    std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;();
    
    a-&gt;b_ptr = b;
    b-&gt;a_ptr = a;

    return 0;
&#125;
</code></pre>
<p>在这个例子中，类 <code>A</code> 拥有一个指向类 <code>B</code> 的 <code>shared_ptr</code>，而类 <code>B</code> 拥有一个指向类 <code>A</code> 的 <code>shared_ptr</code>。这样就形成了循环引用。</p>
<p>为了避免循环引用，我们可以改用 <code>weak_ptr</code> 来解决这个问题：</p>
<pre><code class="cpp">#include &lt;memory&gt;
#include &lt;iostream&gt;

class B; // 前置声明

class A &#123;
public:
    std::shared_ptr&lt;B&gt; b_ptr;
    A() &#123; std::cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; std::endl; &#125;
    ~A() &#123; std::cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; std::endl; &#125;
&#125;;

class B &#123;
public:
    std::weak_ptr&lt;A&gt; a_weak_ptr;  // 使用 weak_ptr
    B() &#123; std::cout &lt;&lt; &quot;B constructor&quot; &lt;&lt; std::endl; &#125;
    ~B() &#123; std::cout &lt;&lt; &quot;B destructor&quot; &lt;&lt; std::endl; &#125;
&#125;;

int main() &#123;
    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;();
    std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;();
    
    a-&gt;b_ptr = b;
    b-&gt;a_weak_ptr = a;  // 使用 weak_ptr

    return 0;
&#125;
</code></pre>
<p>通过将类 <code>B</code> 中指向类 <code>A</code> 的指针改为 <code>weak_ptr</code>，我们成功地避免了循环引用问题。</p>
<h2 id="四、STL"><a href="#四、STL" class="headerlink" title="四、STL"></a>四、STL</h2><h3 id="4-1-什么是STL"><a href="#4-1-什么是STL" class="headerlink" title="4.1 什么是STL"></a>4.1 什么是STL</h3><p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p>
<ul>
<li>算法包括排序，复制等常用算法，以及不同容器特定的算法。</li>
<li>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</li>
<li>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。</li>
</ul>
<h3 id="4-2-使用智能指针管理内存资源，RAII是怎么回事？"><a href="#4-2-使用智能指针管理内存资源，RAII是怎么回事？" class="headerlink" title="4.2 使用智能指针管理内存资源，RAII是怎么回事？"></a>4.2 使用智能指针管理内存资源，RAII是怎么回事？</h3><p>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。<br>因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</p>
<p>智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。<br>毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。</p>
<h3 id="4-3-迭代器：-it、it-哪个好，为什么"><a href="#4-3-迭代器：-it、it-哪个好，为什么" class="headerlink" title="4.3 迭代器：++it、it++哪个好，为什么"></a>4.3 迭代器：++it、it++哪个好，为什么</h3><p>前置返回一个引用，后置返回一个对象</p>
<ul>
<li>++i实现代码为：</li>
</ul>
<pre><code class="cpp">int&amp; operator++()
&#123;
  *this += 1;
  return *this;
&#125; 
</code></pre>
<p>前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低</p>
<ul>
<li>i++实现代码为：</li>
</ul>
<pre><code class="cpp">int operator++(int)                 
&#123;
  int temp = *this;                   
  ++*this;                       
  return temp;                  
&#125; 
</code></pre>
<p>对于大多数现代编译器来说，在合适的情况下，它们可能会对代码进行优化，包括将后置自增 it++ 转换为前置自增 ++it。但是，这种优化是否发生取决于编译器的实现以及优化级别。</p>
<h3 id="4-4-右值"><a href="#4-4-右值" class="headerlink" title="4.4 右值"></a>4.4 右值</h3><p>C++11引入了右值引用，用来支持移动语义和完美转发。</p>
<ol>
<li>移动语义：传统的复制操作需要额外的时间和空间，而有了移动语义后，可以直接将资源（如内存）从一个对象转移到另一个对象，而不必创建并删除临时对象。这对于大对象或者拥有独占所有权资源的对象特别有用。例如，unique_ptr和std::vector等STL容器就利用了移动语义实现了高效的操作。</li>
<li>完美转发：在函数模板中，我们想把参数原封不动地传递给其他函数。由于传参可能存在值传递、左值引用、常量左值引用、右值引用等情况，为了保证参数的属性和类型不发生变化，我们需要使用std::forward实现完美转发。</li>
</ol>
<p>右值引用主要用于两种场景：一是对象的移动（Move），二是万能引用（Forwarding Reference）。对于第一种情况，它是为了解决对象的复制效率问题；对于第二种情况，则是为了实现参数的完美传递，避免不必要的拷贝。</p>
<h3 id="4-5-简单说一下traits技法"><a href="#4-5-简单说一下traits技法" class="headerlink" title="4.5 简单说一下traits技法"></a>4.5 简单说一下traits技法</h3><p>Traits 技法是一种在编程中使用的模式，用于实现泛型编程和类型参数化。它的基本思想是将类型的某些特性（或特征）提取出来，并将其定义为独立的类或结构体，然后通过模板或泛型编程技术将这些特性与具体的类型进行关联。</p>
<p>Traits 技法的主要目的是将类型的行为和属性与类型本身解耦，使得代码更具灵活性和可重用性。通过定义一组通用的接口或函数，可以将这些接口或函数应用于不同的类型，而无需对每种类型都进行单独的实现。</p>
<p>在 C++ 中，Traits 技法通常通过模板编程来实现。可以定义一组模板类或结构体，用于描述类型的特性，然后在模板函数或模板类中使用这些特性。通过特化或偏特化，可以针对不同类型提供不同的实现，从而实现更高级的泛型编程。</p>
<p>例如，在 C++ 中，STL 中的迭代器就是一种典型的 Traits 技法的应用。迭代器通过一组接口描述了迭代器的特性，然后通过模板函数和模板类来处理不同类型的迭代器，而无需知道具体的迭代器类型。这种设计使得算法可以与任何支持相应接口的迭代器一起使用，从而提高了代码的灵活性和可重用性。</p>
<h3 id="4-6-STL的两级空间配置器"><a href="#4-6-STL的两级空间配置器" class="headerlink" title="4.6 STL的两级空间配置器"></a>4.6 STL的两级空间配置器</h3><p>STL（Standard Template Library）的空间配置器是用于在堆上分配内存的组件，它们被用来支持STL容器（如vector、list、map等）的内存管理。STL中的空间配置器通常包括单级空间配置器和双级空间配置器。</p>
<p>双级空间配置器由两部分组成：</p>
<ol>
<li><p>第一级空间配置器（第一级分配器）：使用malloc和free等全局内存分配函数来分配内存。这一级的分配器适用于大块内存的分配，它通过调用全局的malloc和free函数来分配和释放内存，通常是通过模板参数指定的分配策略来实现。</p>
</li>
<li><p>第二级空间配置器（第二级分配器）：由于第一级空间配置器在处理小块内存时效率较低，因此第二级空间配置器通常会对小块内存进行优化，它通常使用内存池等技术来管理和分配小块内存，以提高内存分配和释放的效率。</p>
</li>
</ol>
<p>双级空间配置器的设计可以在大块内存和小块内存之间取得平衡，从而在不同大小的内存分配场景中提供更好的性能和效率。这种设计使得STL容器在不同的内存分配场景下都能够有效地工作，并且具有较好的性能表现。</p>
<h3 id="4-7-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"><a href="#4-7-vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素" class="headerlink" title="4.7 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素"></a>4.7 vector与list的区别与应用？怎么找某vector或者list的倒数第二个元素</h3><ul>
<li><p><strong>vector数据结构</strong>  </p>
<ul>
<li>vector和<code>数组</code>类似，拥有一段连续的内存空间，并且起始地址不变。因此能高效的进行随机存取，时间复杂度为o(1);但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。</li>
<li>当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。连续存储结构：vector是可以实现动态增长的对象数组，支持对数组高效率的访问和在数组尾端的删除和插入操作，在中间和头部删除和插入相对不易，需要挪动大量的数据。</li>
<li>它与数组最大的区别就是vector不需程序员自己去考虑容量问题，库里面本身已经实现了容量的动态增长，而数组需要程序员手动写入扩容函数进形扩容。</li>
</ul>
</li>
<li><p><strong>list数据结构</strong>  </p>
<ul>
<li>list是由<code>双向链表</code>实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);但由于链表的特点，能高效地进行插入和删除。非连续存储结构：list是一个双链表结构，支持对链表的双向遍历。每个节点包括三个信息：元素本身，指向前一个元素的节点（prev）和指向下一个元素的节点（next）。因此list可以高效率的对数据元素任意位置进行访问和插入删除等操作。由于涉及对额外指针的维护，所以开销比较大。<br>区别：</li>
</ul>
</li>
</ul>
<p>vector的随机访问效率高，但在插入和删除时（不包括尾部）需要挪动数据，不易操作。<br>list的访问要遍历整个链表，它的随机访问效率低。但对数据的插入和删除操作等都比较方便，改变指针的指向即可。</p>
<p>从遍历上来说，list是单向的，vector是双向的。<br>vector中的迭代器在使用后就失效了，而list的迭代器在使用之后还可以继续使用。<br>int mySize &#x3D; vec.size();vec.at(mySize -2);</p>
<p>list不提供随机访问，所以不能用下标直接访问到某个位置的元素，要访问list里的元素只能遍历，不过你要是只需要访问list的最后N个元素的话，可以用<code>反向迭代器</code>来遍历</p>
<h3 id="4-8-reserve与resize"><a href="#4-8-reserve与resize" class="headerlink" title="4.8 reserve与resize"></a>4.8 reserve与resize</h3><p>在 C++ 中，reserve() 和 resize() 是与标准库中的容器（例如 vector、list、deque 等）相关的两个重要函数，它们的作用如下：</p>
<ul>
<li><p><strong>reserve():</strong><br>这个函数用于预留容器的存储空间，但不改变容器的大小。预留的存储空间可以用来避免容器在添加新元素时频繁地重新分配内存，从而提高性能。reserve() 函数的参数是要预留的元素个数。如果当前容器的容量小于指定的元素个数，reserve() 函数会分配额外的内存空间以容纳指定数量的元素。</p>
</li>
<li><p><strong>resize():</strong><br>这个函数用于更改容器中元素的数量。当调用 resize() 时，如果指定的大小比当前大小小，则容器中的元素数量会减少到指定大小；如果指定的大小比当前大小大，则容器会扩展以容纳额外的元素。如果容器扩展，新添加的元素将以容器元素的默认值进行初始化。</p>
</li>
</ul>
<blockquote>
<p>在调用 reserve() 函数之后，如果你直接访问预留的空间，将会导致未定义行为，因为这些空间并没有被初始化为有效的元素。</p>
</blockquote>
<h3 id="4-9-STL迭代器如何实现"><a href="#4-9-STL迭代器如何实现" class="headerlink" title="4.9 STL迭代器如何实现"></a>4.9 STL迭代器如何实现</h3><ol>
<li><p>迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原理的情况下遍历容器，除此之外，STL中迭代器一个最重要的作用就是作为容器与STL算法的粘合剂。</p>
</li>
<li><p>迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的是*运算符与-&gt;运算符，以及++、–等可能需要重载的运算符重载。这和C++中的智能指针很像，智能指针也是将一个指针封装，然后通过引用计数或是其他方法完成自动释放内存的功能。</p>
</li>
<li><p>最常用的迭代器的相应型别有五种：value type、difference type、pointer、reference、iterator catagoly;</p>
</li>
</ol>
<h3 id="4-10-map插入方式有哪几种？"><a href="#4-10-map插入方式有哪几种？" class="headerlink" title="4.10 map插入方式有哪几种？"></a>4.10 map插入方式有哪几种？</h3><ol>
<li>用insert函数插入pair数据：</li>
</ol>
<pre><code class="cpp">mapStudent.insert(pair&lt;int, string&gt;(1, &quot;student_one&quot;)); 
</code></pre>
<ol start="2">
<li>用insert函数插入value_type数据：</li>
</ol>
<pre><code class="cpp">mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;));
</code></pre>
<ol start="3">
<li>在insert函数中使用make_pair()函数：</li>
</ol>
<pre><code class="cpp">mapStudent.insert(make_pair(1, &quot;student_one&quot;)); 
</code></pre>
<ol start="4">
<li>用数组方式插入数据：</li>
</ol>
<pre><code class="cpp">mapStudent[1] = &quot;student_one&quot;; 
</code></pre>
<h3 id="4-20-map中-与find的区别？"><a href="#4-20-map中-与find的区别？" class="headerlink" title="4.20 map中[]与find的区别？"></a>4.20 map中[]与find的区别？</h3><ul>
<li><p>map的下标运算符[]的作用是：将关键码作为下标去执行查找，并返回对应的值；如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入这个map。</p>
</li>
<li><p>map的find函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。</p>
</li>
</ul>
<h3 id="4-21-STL中list与deque之间的区别"><a href="#4-21-STL中list与deque之间的区别" class="headerlink" title="4.21 STL中list与deque之间的区别"></a>4.21 STL中list与deque之间的区别</h3><p>STL（标准模板库）中的list（双向链表）和deque（双端队列）是两种不同的容器，它们有以下区别：</p>
<ul>
<li><p>底层数据结构：</p>
<ul>
<li>list：<br>采用双向链表作为底层数据结构。每个节点包含数据以及指向前驱节点和后继节点的指针。</li>
<li>deque：<br>采用分段数组（双端队列）作为底层数据结构。它由多个较小的数组块组成，每个数组块都包含一定数量的元素，并通过指针连接起来，形成一个逻辑上的双端队列。</li>
</ul>
</li>
<li><p>访问元素的效率：</p>
<ul>
<li>list：<br>由于采用链表结构，list在任意位置插入或删除元素的效率都很高，为O(1)。但是，随机访问元素的效率较低，为O(n)，因为需要遍历链表找到指定位置的元素。</li>
<li>deque：<br>由于采用分段数组结构，deque支持高效的随机访问，其时间复杂度为O(1)。同时，deque还支持在两端进行快速插入和删除操作，时间复杂度也为O(1)。</li>
</ul>
</li>
<li><p>内存分配方式：</p>
<ul>
<li>list：<br>由于采用链表结构，每次插入或删除元素时都需要动态分配内存，因此在频繁插入或删除大量元素时，可能会产生较多的内存分配和释放操作，导致性能下降。</li>
<li>deque：<br>由于采用分段数组结构，内存是分块预先分配的，因此在插入或删除元素时不需要频繁进行内存分配和释放操作，性能相对较好。</li>
</ul>
</li>
<li><p>空间占用：</p>
<ul>
<li>list：<br>由于每个节点都需要额外的指针来指向前驱节点和后继节点，因此相比于deque，list的空间占用通常更大。</li>
<li>deque：<br>由于采用分段数组结构，每个数组块的大小是固定的，因此deque的空间占用更为灵活，不会产生额外的指针开销。</li>
</ul>
</li>
</ul>
<p>根据以上区别，选择使用list还是deque取决于你的具体需求。如果需要频繁进行插入和删除操作，且不关心随机访问的效率，可以选择list；如果需要支持高效的随机访问，并且在两端进行快速插入和删除操作，可以选择deque。</p>
<h3 id="4-22-STL中的allocator、deallocator"><a href="#4-22-STL中的allocator、deallocator" class="headerlink" title="4.22 STL中的allocator、deallocator"></a>4.22 STL中的allocator、deallocator</h3><p>第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器；</p>
<p>第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块；</p>
<p>空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间；</p>
<p>空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存。</p>
<h3 id="4-23-常见容器性质总结？"><a href="#4-23-常见容器性质总结？" class="headerlink" title="4.23 常见容器性质总结？"></a>4.23 常见容器性质总结？</h3><p>1.vector 底层数据结构为数组 ，支持快速随机访问</p>
<p>2.list 底层数据结构为双向链表，支持快速增删</p>
<p>3.deque 底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问</p>
<p>deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:</p>
<p>[堆1] –&gt; [堆2] –&gt;[堆3] –&gt; …</p>
<p>每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.</p>
<p>4.stack 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时</p>
<p>5.queue 底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）</p>
<p>6.priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现</p>
<p>7.set 底层数据结构为红黑树，有序，不重复</p>
<p>8.multiset 底层数据结构为红黑树，有序，可重复</p>
<p>9.map 底层数据结构为红黑树，有序，不重复</p>
<p>10.multimap 底层数据结构为红黑树，有序，可重复</p>
<p>11.unordered_set 底层数据结构为hash表，无序，不重复</p>
<p>12.unordered_multiset 底层数据结构为hash表，无序，可重复</p>
<p>13.unordered_map 底层数据结构为hash表，无序，不重复</p>
<p>14.unordered_multimap 底层数据结构为hash表，无序，可重复</p>
<h3 id="4-24-说一下STL每种容器对应的迭代器"><a href="#4-24-说一下STL每种容器对应的迭代器" class="headerlink" title="4.24 说一下STL每种容器对应的迭代器"></a>4.24 说一下STL每种容器对应的迭代器</h3><p>| 容器    |	迭代器 |<br>| —     |	—   |<br>| vector、deque  | 随机访问迭代器 |<br>| stack、queue、priority_queue  | 无 |<br>| list、(multi)set&#x2F;map  | 双向迭代器 |<br>| unordered_(multi)set&#x2F;map、forward_list  | 前向迭代器 |</p>
<h3 id="4-25-STL中迭代器失效的情况有哪些？"><a href="#4-25-STL中迭代器失效的情况有哪些？" class="headerlink" title="4.25 STL中迭代器失效的情况有哪些？"></a>4.25 STL中迭代器失效的情况有哪些？</h3><p>以vector为例：</p>
<p>插入元素：</p>
<ol>
<li><p>尾后插入：size &lt; capacity时，首迭代器不失效尾迭代失效（未重新分配空间），size &#x3D;&#x3D; capacity时，所有迭代器均失效（需要重新分配空间）。</p>
</li>
<li><p>中间插入：中间插入：size &lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size &#x3D;&#x3D; capacity时，所有迭代器均失效。</p>
</li>
</ol>
<p>删除元素：</p>
<ol>
<li><p>尾后删除：只有尾迭代失效。</p>
</li>
<li><p>中间删除：删除位置之后所有迭代失效。</p>
</li>
</ol>
<p>deque 和 vector 的情况类似,</p>
<p>而list双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器;</p>
<p>map&#x2F;set等关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器 mmp.erase(iter++);</p>
<p>unordered_(hash) 迭代器意义不大, rehash之后, 迭代器应该也是全部失效.</p>
<h3 id="4-26-hashtable中解决冲突有哪些方法？"><a href="#4-26-hashtable中解决冲突有哪些方法？" class="headerlink" title="4.26 hashtable中解决冲突有哪些方法？"></a>4.26 hashtable中解决冲突有哪些方法？</h3><p><strong>记住前三个：</strong></p>
<ul>
<li><p>线性探测<br>使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位</p>
</li>
<li><p>开链<br>每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中</p>
</li>
<li><p>再散列<br>发生冲突时使用另一种hash函数再计算一个地址，直到不冲突</p>
</li>
<li><p>二次探测<br>使用hash函数计算出的位置如果已经有元素占用了，按照$1^2$、$2^2$、$3^2$…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测</p>
</li>
<li><p>公共溢出区<br>一旦hash函数计算的结果相同，就放入公共溢出区</p>
</li>
</ul>
<h2 id="五、其余问题"><a href="#五、其余问题" class="headerlink" title="五、其余问题"></a>五、其余问题</h2><h3 id="5-1-C-多态"><a href="#5-1-C-多态" class="headerlink" title="5.1 C++多态"></a>5.1 C++多态</h3><p>C++中，多态性主要通过两种方式实现：编译时多态（静态多态）和运行时多态（动态多态）。这两种多态的机制、特点和用途有所不同。</p>
<ul>
<li>编译时多态（静态多态）:<br>编译时多态是在程序编译阶段实现的多态性。主要通过函数重载、运算符重载和模板来实现。</li>
</ul>
<p>函数重载: 同一个作用域内存在多个同名函数，但它们的参数类型或数量不同。根据调用时实际传递的参数类型和数量，编译器决定调用哪个函数。<br>运算符重载: 允许定义或重新定义大部分C++内置的运算符，使得它们可以根据操作数的类型执行不同的操作。<br>编译时多态的决策是在编译时做出的，因此它不支持在运行时根据对象的实际类型来选择相应的成员函数。</p>
<ul>
<li>运行时多态（动态多态）: 运行时多态是在程序运行阶段实现的多态性。它主要通过虚函数和继承来实现。</li>
</ul>
<p>虚函数: 通过在基类中声明虚函数，允许派生类中重写该函数。当通过基类的指针或引用调用虚函数时，实际执行的是与指针或引用所指对象的实际类型相对应的函数版本。<br>抽象类和纯虚函数: 抽象类至少包含一个纯虚函数。纯虚函数在基类中没有实现，派生类必须重写这个函数。抽象类不能被实例化。</p>
<h3 id="5-2-什么时候的析构函数必须写成虚函数"><a href="#5-2-什么时候的析构函数必须写成虚函数" class="headerlink" title="5.2 什么时候的析构函数必须写成虚函数"></a>5.2 什么时候的析构函数必须写成虚函数</h3><p>一般情况下类的析构函数里面都是释放内存资源，而析构函数不被调用的话就会造成内存泄漏。这样做是为了当<code>用一个基类的指针删除一个派生类的对象时</code>，派生类的析构函数会被调用。 </p>
<p>当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有<code>当一个类被用来作为基类的时候</code>，才把析构函数写成虚函数。</p>
<h3 id="5-3-构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"><a href="#5-3-构造函数能否声明为虚函数或者纯虚函数，析构函数呢？" class="headerlink" title="5.3 构造函数能否声明为虚函数或者纯虚函数，析构函数呢？"></a>5.3 构造函数能否声明为虚函数或者纯虚函数，析构函数呢？</h3><ul>
<li>析构函数：  <ul>
<li>析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。<br>只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。</li>
<li>析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。</li>
</ul>
</li>
<li>构造函数：  <ul>
<li>根据《effective C++》的条款09：绝不在构造和析构过程中调用虚函数可知，在构造函数中虽然可以调用虚函数，但是强烈建议不要这样做。因为基类的构造的过程中，虚函数不能算作是虚函数。若构造函数中调用虚函数，可能会导致不确定行为的发生.</li>
<li>虚函数对应一个vtable(虚函数表)，类中存储一个vptr指向这个vtable。如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数。</li>
</ul>
</li>
</ul>
<h3 id="5-4-目标文件存储结构"><a href="#5-4-目标文件存储结构" class="headerlink" title="5.4 目标文件存储结构"></a>5.4 目标文件存储结构</h3><table>
<thead>
<tr>
<th>段</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>File Header</td>
<td>文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）</td>
</tr>
<tr>
<td>.text section</td>
<td>代码段，执行语句编译成的机器代码</td>
</tr>
<tr>
<td>.data section</td>
<td>数据段，已初始化的全局变量和局部静态变量</td>
</tr>
<tr>
<td>.bss section</td>
<td>BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）</td>
</tr>
<tr>
<td>.rodata section</td>
<td>只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量</td>
</tr>
<tr>
<td>.comment section</td>
<td>注释信息段，存放编译器版本信息</td>
</tr>
<tr>
<td>.note.GNU-stack section</td>
<td>堆栈提示段</td>
</tr>
</tbody></table>
<blockquote>
<p>其他段略</p>
</blockquote>
<h3 id="5-5-基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#5-5-基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="5.5 基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>5.5 基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h3><ul>
<li>C++中<code>虚函数表</code>位于<code>只读数据段（.rodata）</code>，也就是C++内存模型中的<code>常量区</code></li>
<li>而<code>虚函数</code>则位于<code>代码段（.text）</code>，也就是C++内存模型中的<code>代码区</code>。</li>
<li>在构造函数执行时会对虚表指针进行初始化，并且存在对象<code>内存布局的最前面</code>。</li>
</ul>
<h3 id="5-6-模板函数和模板类的特例化"><a href="#5-6-模板函数和模板类的特例化" class="headerlink" title="5.6 模板函数和模板类的特例化"></a>5.6 模板函数和模板类的特例化</h3><ul>
<li><p>引入原因：<br>编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化</p>
</li>
<li><p>定义：<br>对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上</p>
</li>
</ul>
<p>（1）模板函数特例化</p>
<p>必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对&lt;&gt;，表明将原模板的所有模板参数提供实参，举例如下：</p>
<pre><code class="cpp">template&lt;typename T&gt; //模板函数
int compare(const T &amp;v1,const T &amp;v2)
&#123;
    if(v1 &gt; v2) return -1;
    if(v2 &gt; v1) return 1;
    return 0;
&#125;
//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T
template&lt;&gt; 
int compare(const char* const &amp;v1,const char* const &amp;v2)
&#123;
    return strcmp(p1,p2);
&#125;
</code></pre>
<ul>
<li><p>本质<br>特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配。参数匹配都以最佳匹配为原则。例如，此处如果是compare(3,5)，则调用普通的模板，若为compare(“hi”,”haha”)则调用特例化版本（因为这个cosnt char*相对于T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能。</p>
</li>
<li><p>注意<br>模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。</p>
</li>
</ul>
<p>（2）类模板特例化</p>
<p>原理类似函数模板，<strong>不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。</strong>对类进行特例化时，仍然用template&lt;&gt;表示是一个特例化版本，例如：</p>
<pre><code class="cpp">template&lt;&gt;
class hash&lt;sales_data&gt;
&#123;
    size_t operator()(sales_data&amp; s);
    //里面所有T都换成特例化类型版本sales_data
    //按照最佳匹配原则，若T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。
&#125;;
</code></pre>
<p>类模板的部分特例化</p>
<p>不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)</p>
<p>特例化类中的部分成员</p>
<p>可以特例化类中的部分成员函数而不是整个类，举个例子：</p>
<pre><code class="cpp">template&lt;typename T&gt;
class Foo
&#123;
    void Bar();
    void Barst(T a)();
&#125;;

template&lt;&gt;
void Foo&lt;int&gt;::Bar()
&#123;
    //进行int类型的特例化处理
    cout &lt;&lt; &quot;我是int型特例化&quot; &lt;&lt; endl;
&#125;

Foo&lt;string&gt; fs;
Foo&lt;int&gt; fi;//使用特例化
fs.Bar();//使用的是普通模板，即Foo&lt;string&gt;::Bar()
fi.Bar();//特例化版本，执行Foo&lt;int&gt;::Bar()
//Foo&lt;string&gt;::Bar()和Foo&lt;int&gt;::Bar()功能不同
</code></pre>
<h3 id="5-7-模板定义和实现可不可以不写在一个文件里面？为什么？"><a href="#5-7-模板定义和实现可不可以不写在一个文件里面？为什么？" class="headerlink" title="5.7 模板定义和实现可不可以不写在一个文件里面？为什么？"></a>5.7 模板定义和实现可不可以不写在一个文件里面？为什么？</h3><p>模板定义很特殊。由template&lt;…&gt;处理的任何东西都意味着**编译器在当时不为它分配存储空间(没有具体的函数时不会对模板实例化)**，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p>
<p>定义一个类一般都是在头文件中进行类声明，在cpp文件中实现，但使用模板时应注意目前的C++编译器还无法分离编译，最好将实现代码和声明代码均放在头文件中。如：</p>
<pre><code class="cpp">// test.h
template &lt;class T&gt;
class CTest
&#123;  
public:        
  T&amp; GetValue();        
protected:
  T m_Value;
&#125;;
 
// test.cpp
template &lt;class T&gt;
T&amp; CTest&lt;T&gt;::GetValue()
&#123;    
   return m_Value;  
&#125;
</code></pre>
<p>在这儿test.cpp中的内容应放在test.h中，否则在生成最终可执行程序时就会出现错误(在链接时会出错)。因为<code>在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现</code>，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了。</p>
<h3 id="5-8-构造函数、析构函数、虚函数可否声明为内联函数"><a href="#5-8-构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="5.8 构造函数、析构函数、虚函数可否声明为内联函数"></a>5.8 构造函数、析构函数、虚函数可否声明为内联函数</h3><p>首先，将这些函数声明为内联函数，在语法上没有错误。因为inline同register一样，只是个建议，编译器并不一定真正的内联。</p>
<blockquote>
<p>register关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率</p>
</blockquote>
<p>构造函数和析构函数声明为内联函数是没有意义的</p>
<p>《Effective C++》中所阐述的是：将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请&#x2F;释放内存，构造&#x2F;析构对象等），致使构造函数&#x2F;析构函数并不像看上去的那么精简。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。</p>
<p>将虚函数声明为inline，要分情况讨论</p>
<p>有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联呢？</p>
<p>上述观点看似正确，其实不然，如果虚函数在编译器就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当用对象调用虚函数（此时不具有多态性）时，就内联展开</p>
<p>综上，当是<code>指向派生类的指针（多态性）</code>调用声明为inline的虚函数时，不会内联展开；当是<code>对象本身调用虚函数</code>时，会内联展开，当然前提依然是函数并不复杂的情况下。</p>
<h3 id="5-9-C-模板是什么，你知道底层怎么实现的？"><a href="#5-9-C-模板是什么，你知道底层怎么实现的？" class="headerlink" title="5.9 C++模板是什么，你知道底层怎么实现的？"></a>5.9 C++模板是什么，你知道底层怎么实现的？</h3><ul>
<li><p>编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</p>
</li>
<li><p>这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</p>
</li>
</ul>
<h3 id="5-10-构造函数和析构函数可以调用虚函数吗，为什么"><a href="#5-10-构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="5.10 构造函数和析构函数可以调用虚函数吗，为什么"></a>5.10 构造函数和析构函数可以调用虚函数吗，为什么</h3><p>在C++中，提倡不在构造函数和析构函数中调用虚函数；</p>
<p>构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；</p>
<p>因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；</p>
<p>析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</p>
<h3 id="5-11-如何解决菱形继承"><a href="#5-11-如何解决菱形继承" class="headerlink" title="5.11 如何解决菱形继承"></a>5.11 如何解决菱形继承</h3><p>使用虚继承：</p>
<p>虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。 如:类D继承自类B1、B2，而类B1、B2都继 承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为虚拟继承，而A就成了虚拟基类,虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。</p>
<p>虚继承的特点是，在任何派生类中的virtual基类总用同一个（共享）对象表示，</p>
<h3 id="5-12-将字符串“hello-world”从开始到打印到屏幕上的全过程"><a href="#5-12-将字符串“hello-world”从开始到打印到屏幕上的全过程" class="headerlink" title="5.12 将字符串“hello world”从开始到打印到屏幕上的全过程?"></a>5.12 将字符串“hello world”从开始到打印到屏幕上的全过程?</h3><ol>
<li><p>用户告诉操作系统执行HelloWorld程序（通过键盘输入等）</p>
</li>
<li><p>操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。</p>
</li>
<li><p>操作系统：创建一个新进程，将HelloWorld可执行文件映射到该进程结构，表示由该进程执行helloworld程序。</p>
</li>
<li><p>操作系统：为helloworld程序设置cpu上下文环境，并跳到程序开始处。</p>
</li>
<li><p>执行helloworld程序的第一条指令，发生缺页异常</p>
</li>
<li><p>操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序</p>
</li>
<li><p>helloword程序执行puts函数（系统调用），在显示器上写一字符串</p>
</li>
<li><p>操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程</p>
</li>
<li><p>操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区</p>
</li>
<li><p>视频硬件将像素转换成显示器可接收和一组控制数据信号</p>
</li>
<li><p>显示器解释信号，激发液晶屏</p>
</li>
<li><p>OK，我们在屏幕上看到了HelloWorld</p>
</li>
</ol>
<h3 id="5-13-为什么拷贝构造函数必须传引用不能传值？"><a href="#5-13-为什么拷贝构造函数必须传引用不能传值？" class="headerlink" title="5.13 为什么拷贝构造函数必须传引用不能传值？"></a>5.13 为什么拷贝构造函数必须传引用不能传值？</h3><p>拷贝构造函数用来初始化一个非引用类类型对象，如果用传值的方式进行传参数，那么构造实参需要调用拷贝构造函数，而拷贝构造函数需要传递实参，所以会一直递归。</p>
<h3 id="5-14-虚函数的调用关系"><a href="#5-14-虚函数的调用关系" class="headerlink" title="5.14 虚函数的调用关系"></a>5.14 虚函数的调用关系</h3><p>this -&gt; vptr -&gt; vtable -&gt;virtual function</p>
<h3 id="5-15-说一说你了解到的移动构造函数？"><a href="#5-15-说一说你了解到的移动构造函数？" class="headerlink" title="5.15 说一说你了解到的移动构造函数？"></a>5.15 说一说你了解到的移动构造函数？</h3><ol>
<li><p>有时候我们会遇到这样一种情况，我们用对象a初始化对象b后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；</p>
</li>
<li><p>拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制；</p>
</li>
<li><p>C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；</p>
</li>
<li><p>与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作；</p>
</li>
</ol>
<pre><code class="cpp">Example6 (Example6&amp;&amp; x) : ptr(x.ptr) 
  &#123;
    x.ptr = nullptr;
  &#125;

  // move assignment
  Example6&amp; operator= (Example6&amp;&amp; x) 
  &#123;
   delete ptr; 
   ptr = x.ptr;
   x.ptr=nullptr;
    return *this;
&#125;
</code></pre>
<h3 id="5-16-哪些函数不能是虚函数？把你知道的都说一说"><a href="#5-16-哪些函数不能是虚函数？把你知道的都说一说" class="headerlink" title="5.16 哪些函数不能是虚函数？把你知道的都说一说"></a>5.16 哪些函数不能是虚函数？把你知道的都说一说</h3><ol>
<li><p>构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；</p>
</li>
<li><p>内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；</p>
</li>
<li><p>静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。</p>
</li>
<li><p>友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。</p>
</li>
<li><p>普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。</p>
</li>
</ol>
<h3 id="5-17-什么是纯虚函数，与虚函数的区别"><a href="#5-17-什么是纯虚函数，与虚函数的区别" class="headerlink" title="5.17 什么是纯虚函数，与虚函数的区别"></a>5.17 什么是纯虚函数，与虚函数的区别</h3><ul>
<li><p>虚函数和纯虚函数区别？<br>虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。</p>
</li>
<li><p>纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。</p>
</li>
<li><p>纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“&#x3D;0”。</p>
</li>
<li><p>既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。</p>
</li>
<li><p>一个类中如果有纯虚函数的话，称其为抽象类。抽象类不能用于实例化对象，否则会报错。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象。</p>
</li>
</ul>
<h3 id="5-18-DLL劫持"><a href="#5-18-DLL劫持" class="headerlink" title="5.18 DLL劫持"></a>5.18 DLL劫持</h3><p>DLL 劫持（DLL hijacking）是一种安全漏洞，利用该漏洞，攻击者可以将恶意 DLL 文件伪装成系统或应用程序所需的 DLL 文件，并放置在系统搜索路径中，以便在程序运行时被加载并执行恶意代码。</p>
<p>攻击者通常利用以下几种方法进行 DLL 劫持：</p>
<ol>
<li><strong>将恶意 DLL 放置在可被系统搜索到的目录中</strong>：攻击者可以将恶意 DLL 文件放置在系统搜索路径中的一个或多个目录中，例如程序所在目录、当前工作目录、系统目录（如 System32）或者应用程序目录等。当程序启动时，系统会按照一定的搜索顺序查找并加载所需的 DLL 文件，如果发现了恶意 DLL，就会加载并执行其中的恶意代码。</li>
<li><strong>利用缺陷的搜索顺序</strong>：有些程序在加载 DLL 文件时存在搜索顺序上的缺陷，例如优先从当前工作目录加载 DLL 文件而不是系统目录。攻击者可以利用这种缺陷，将恶意 DLL 文件放置在当前工作目录下，并等待程序启动时被加载执行。</li>
<li><strong>利用自定义环境变量</strong>：攻击者可以利用自定义的环境变量来修改程序的搜索路径，从而加载恶意 DLL 文件。例如，攻击者可以通过修改 PATH 环境变量，将恶意 DLL 文件所在的目录添加到系统搜索路径中。</li>
</ol>
<p>为了防止 DLL 劫持攻击，可以采取以下几种措施：</p>
<ol>
<li><strong>使用绝对路径加载 DLL 文件</strong>：在程序中明确指定 DLL 文件的绝对路径，而不是依赖系统搜索路径。这样可以确保程序只加载所需的 DLL 文件，并避免加载恶意 DLL 文件。</li>
<li><strong>加强权限控制</strong>：限制用户对系统目录和应用程序目录的写入权限，防止恶意 DLL 文件被放置在系统搜索路径中。<br>更新程序：及时更新程序，修复可能存在的 DLL 劫持漏洞。一些程序已经针对 DLL 劫持进行了修复，并提供了安全更新。</li>
<li><strong>使用数字签名</strong>：对 DLL 文件进行数字签名，确保文件的完整性和来源可信。程序在加载 DLL 文件时可以验证其数字签名，以确保文件未被篡改。<br>启用安全策略：在操作系统和应用程序中启用相应的安全策略，限制恶意代码的执行。例如，使用应用程序白名单、启用应用程序沙盒等。</li>
</ol>
<p>通过采取以上措施，可以有效地防止 DLL 劫持攻击，并保护系统和应用程序的安全。</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1430797759@qq.com </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>C++八股文</p>
    <p><span class="copy-title">字数:</span><span class="post-count">30.8k</span></p>
    <p><span class="copy-title">本文作者:</span><a  title="花落阁">花落阁</a></p>
    <p><span class="copy-title">发布时间:</span>2023-01-23, 17:48:51</p>
    <p><span class="copy-title">最后更新:</span>2024-04-26, 14:52:23</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2023/01/23/C++%E5%85%AB%E8%82%A1%E6%96%87/" title="C++八股文">https://hualog.dns.navy/2023/01/23/C++%E5%85%AB%E8%82%A1%E6%96%87/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">&#34;署名-非商用-相同方式共享 4.0&#34;</a> 转载请保留原文链接及作者。
    </p>
</div>



    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '53b33c5626275dc09dfa',
            clientSecret: '285946a68f8f1bafc052f02fded36467fea269c2',
            repo: 'xuanxuan000.github.io',
            owner: 'xuanxuan000',
            admin: ['xuanxuan000'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2024-2034 Aze
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    #post .pjax article .article-entry>ol, #post .pjax article .article-entry>ul, #post .pjax article>ol, #post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    #post .pjax article .article-entry li>ol, #post .pjax article .article-entry li>ul,#post .pjax article li>ol, #post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    #post .pjax article .article-entry>ol>li, #post .pjax article .article-entry>ul>li,#post .pjax article>ol>li, #post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    #post .pjax article .article-entry li>ol>li, #post .pjax article .article-entry li>ul>li,#post .pjax article li>ol>li, #post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
