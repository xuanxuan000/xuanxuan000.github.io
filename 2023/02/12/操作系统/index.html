<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>操作系统 | 花落阁</title>
  <meta name="keywords" content=" 编程语言 ">
  <meta name="description" content="操作系统 | 花落阁">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="最近面试被问到了写时复制（cow）的概念，顺便在这里整理一下，简单说说写时复制的设计理念和使用场景，暂时不会太深入技术实现，技术部分的介绍有机会再去单开一章。 需求和目标本质上写时复制是一个针对内存资源管理的技术，用以提高内存的使用效率和响应速度。当一个或多个程序单元使用另一个程序单元进行初始化时，一个简单的方式就是对每个单元都做一份完全拷贝，保证内存的互相独立，使用起来互不干扰。但是某些情况下，">
<meta property="og:type" content="article">
<meta property="og:title" content="写时复制（Copy-on-write）">
<meta property="og:url" content="https://hualog.dns.navy/2024/05/21/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%EF%BC%88Copy-on-write%EF%BC%89/index.html">
<meta property="og:site_name" content="花落阁">
<meta property="og:description" content="最近面试被问到了写时复制（cow）的概念，顺便在这里整理一下，简单说说写时复制的设计理念和使用场景，暂时不会太深入技术实现，技术部分的介绍有机会再去单开一章。 需求和目标本质上写时复制是一个针对内存资源管理的技术，用以提高内存的使用效率和响应速度。当一个或多个程序单元使用另一个程序单元进行初始化时，一个简单的方式就是对每个单元都做一份完全拷贝，保证内存的互相独立，使用起来互不干扰。但是某些情况下，">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-05-21T06:20:06.000Z">
<meta property="article:modified_time" content="2024-05-21T06:26:45.265Z">
<meta property="article:author" content="花落阁">
<meta property="article:tag" content="编程语言">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 7.1.1"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>花落阁</span>
</div>

<div class="icon">
    
        
            <a title="rss"
               href="/atom.xml"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-rss"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="github"
               href="https://github.com/xuanxuan000"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
            <a title="email"
               href="mailto:aze0917@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=1430797759&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
        
    
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(25)</small>
            
        </div>
    </li>
    
        
            
                
    <li>
        <div data-rel="工具">
            <i class="fold iconfont icon-right"></i>
            工具
            <small>(8)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="工具&lt;---&gt;tools">
            
            tools
            <small>(7)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
                
    <li>
        <div data-rel="编程语言">
            <i class="fold iconfont icon-right"></i>
            编程语言
            <small>(8)</small>
        </div>
        
            <ul class="sub hide">
                
                    
    <li>
        <div data-rel="编程语言&lt;---&gt;常识类">
            
            常识类
            <small>(6)</small>
        </div>
        
    </li>

                
                    
    <li>
        <div data-rel="编程语言&lt;---&gt;Golang">
            
            Golang
            <small>(2)</small>
        </div>
        
    </li>

                
            </ul>
        
    </li>

            
        
    
        
            
        
    
        
            
                
    <li>
        <div data-rel="音视频">
            
            音视频
            <small>(8)</small>
        </div>
        
    </li>

            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">关于</a>
        
        <a style="width: 50%"
                
                                           class="friends">友链</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="25">
<input type="hidden" id="yelog_site_word_count" value="121.7k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>编程语言</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>编码</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>程序构建</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>传输协议</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>C++</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>cmake</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>docker</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ffmpeg</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>gdb</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>git</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>golang</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>make</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>markdown</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>md</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>SRS</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>zlmediakit</a>
            </li>
        
    </div>

</div>

    
    <div id="local-search-result">

    </div>
    
    <nav id="title-list-nav">
        
        
        <a  class="全部文章 编程语言 常识类 "
           href="/2024/05/21/%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%EF%BC%88Copy-on-write%EF%BC%89/"
           data-tag="编程语言"
           data-author="" >
            <span class="post-title" title="写时复制（Copy-on-write）">写时复制（Copy-on-write）</span>
            <span class="post-date" title="2024-05-21 14:20:06">2024/05/21</span>
        </a>
        
        
        <a  class="全部文章 工具 tools "
           href="/2024/05/11/Makefile%E8%AF%AD%E6%B3%95/"
           data-tag="cmake,make,程序构建"
           data-author="" >
            <span class="post-title" title="Makefile语法">Makefile语法</span>
            <span class="post-date" title="2024-05-11 10:51:48">2024/05/11</span>
        </a>
        
        
        <a  class="全部文章 编程语言 Golang "
           href="/2024/05/07/Golang-GMP%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B/"
           data-tag="编程语言,golang"
           data-author="" >
            <span class="post-title" title="Golang-GMP调度模型">Golang-GMP调度模型</span>
            <span class="post-date" title="2024-05-07 17:53:36">2024/05/07</span>
        </a>
        
        
        <a  class="全部文章 编程语言 常识类 "
           href="/2024/05/06/C++%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag="编程语言,C++"
           data-author="" >
            <span class="post-title" title="C++设计模式">C++设计模式</span>
            <span class="post-date" title="2024-05-06 09:55:06">2024/05/06</span>
        </a>
        
        
        <a  class="全部文章 "
           href="/2024/05/05/QT%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="QT多线程与线程池">QT多线程与线程池</span>
            <span class="post-date" title="2024-05-05 23:13:13">2024/05/05</span>
        </a>
        
        
        <a  class="全部文章 工具 tools "
           href="/2024/05/05/GDB%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"
           data-tag="gdb"
           data-author="" >
            <span class="post-title" title="GDB使用说明">GDB使用说明</span>
            <span class="post-date" title="2024-05-05 19:55:40">2024/05/05</span>
        </a>
        
        
        <a  class="全部文章 编程语言 Golang "
           href="/2024/05/04/Golang%E5%85%AB%E8%82%A1%E6%96%87/"
           data-tag="编程语言,golang"
           data-author="" >
            <span class="post-title" title="Golang八股文">Golang八股文</span>
            <span class="post-date" title="2024-05-04 15:55:19">2024/05/04</span>
        </a>
        
        
        <a  class="全部文章 音视频 "
           href="/2024/05/02/H-264%E7%BC%96%E7%A0%81/"
           data-tag="编码"
           data-author="" >
            <span class="post-title" title="H.264编码">H.264编码</span>
            <span class="post-date" title="2024-05-02 10:32:43">2024/05/02</span>
        </a>
        
        
        <a  class="全部文章 音视频 "
           href="/2024/05/02/WebRTC-%E4%B8%80%E5%AF%B9%E4%B8%80%E9%80%9A%E8%AF%9D/"
           data-tag="传输协议"
           data-author="" >
            <span class="post-title" title="WebRTC-一对一通话">WebRTC-一对一通话</span>
            <span class="post-date" title="2024-05-02 10:04:15">2024/05/02</span>
        </a>
        
        
        <a  class="全部文章 音视频 "
           href="/2024/05/01/ZLMediaKit%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"
           data-tag="zlmediakit"
           data-author="" >
            <span class="post-title" title="ZLMediaKit使用说明">ZLMediaKit使用说明</span>
            <span class="post-date" title="2024-05-01 11:43:30">2024/05/01</span>
        </a>
        
        
        <a  class="全部文章 音视频 "
           href="/2024/04/28/SRS%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"
           data-tag="SRS"
           data-author="" >
            <span class="post-title" title="SRS使用说明">SRS使用说明</span>
            <span class="post-date" title="2024-04-28 15:25:10">2024/04/28</span>
        </a>
        
        
        <a  class="全部文章 工具 "
           href="/2024/04/17/%E6%88%91%E9%81%87%E5%88%B0%E8%BF%87%E7%9A%84%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="我遇到过的疑难杂症">我遇到过的疑难杂症</span>
            <span class="post-date" title="2024-04-17 18:00:55">2024/04/17</span>
        </a>
        
        
        <a  class="全部文章 音视频 "
           href="/2023/12/25/WebRTC/"
           data-tag="传输协议"
           data-author="" >
            <span class="post-title" title="WebRTC">WebRTC</span>
            <span class="post-date" title="2023-12-25 11:28:29">2023/12/25</span>
        </a>
        
        
        <a  class="全部文章 音视频 "
           href="/2023/11/26/GB28181/"
           data-tag="传输协议"
           data-author="" >
            <span class="post-title" title="GB28181">GB28181</span>
            <span class="post-date" title="2023-11-26 11:19:05">2023/11/26</span>
        </a>
        
        
        <a  class="全部文章 工具 tools "
           href="/2023/11/26/%E6%8A%93%E5%8C%85/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="抓包">抓包</span>
            <span class="post-date" title="2023-11-26 10:20:36">2023/11/26</span>
        </a>
        
        
        <a  class="全部文章 音视频 "
           href="/2023/11/20/%E9%9F%B3%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/"
           data-tag="传输协议"
           data-author="" >
            <span class="post-title" title="音视频传输协议">音视频传输协议</span>
            <span class="post-date" title="2023-11-20 10:53:43">2023/11/20</span>
        </a>
        
        
        <a  class="全部文章 音视频 "
           href="/2023/10/14/FFmpeg%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"
           data-tag="ffmpeg"
           data-author="" >
            <span class="post-title" title="FFmpeg使用说明">FFmpeg使用说明</span>
            <span class="post-date" title="2023-10-14 15:28:34">2023/10/14</span>
        </a>
        
        
        <a  class="全部文章 工具 tools "
           href="/2023/04/29/Docker%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"
           data-tag="docker"
           data-author="" >
            <span class="post-title" title="Docker使用说明">Docker使用说明</span>
            <span class="post-date" title="2023-04-29 10:16:08">2023/04/29</span>
        </a>
        
        
        <a  class="全部文章 工具 tools "
           href="/2023/04/14/Git%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"
           data-tag="git"
           data-author="" >
            <span class="post-title" title="Git使用说明">Git使用说明</span>
            <span class="post-date" title="2023-04-14 14:57:56">2023/04/14</span>
        </a>
        
        
        <a  class="全部文章 编程语言 常识类 "
           href="/2023/04/13/MySQL/"
           data-tag="编程语言"
           data-author="" >
            <span class="post-title" title="MySQL">MySQL</span>
            <span class="post-date" title="2023-04-13 23:58:34">2023/04/13</span>
        </a>
        
        
        <a  class="全部文章 工具 tools "
           href="/2023/02/28/CMake%E8%AF%AD%E6%B3%95/"
           data-tag="cmake,make,程序构建"
           data-author="" >
            <span class="post-title" title="CMake语法">CMake语法</span>
            <span class="post-date" title="2023-02-28 17:01:34">2023/02/28</span>
        </a>
        
        
        <a  class="全部文章 编程语言 常识类 "
           href="/2023/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"
           data-tag="编程语言"
           data-author="" >
            <span class="post-title" title="计算机网络">计算机网络</span>
            <span class="post-date" title="2023-02-13 17:27:49">2023/02/13</span>
        </a>
        
        
        <a  class="全部文章 编程语言 常识类 "
           href="/2023/02/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
           data-tag="编程语言"
           data-author="" >
            <span class="post-title" title="操作系统">操作系统</span>
            <span class="post-date" title="2023-02-12 10:54:34">2023/02/12</span>
        </a>
        
        
        <a  class="全部文章 编程语言 常识类 "
           href="/2023/01/23/C++%E5%85%AB%E8%82%A1%E6%96%87/"
           data-tag="编程语言,C++"
           data-author="" >
            <span class="post-title" title="C++八股文">C++八股文</span>
            <span class="post-date" title="2023-01-23 17:48:51">2023/01/23</span>
        </a>
        
        
        <a  class="全部文章 工具 tools "
           href="/2022/08/22/Markdown%E8%AF%AD%E6%B3%95/"
           data-tag="markdown,md"
           data-author="" >
            <span class="post-title" title="Markdown语法">Markdown语法</span>
            <span class="post-date" title="2022-08-22 11:24:12">2022/08/22</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-操作系统" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">操作系统</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="编程语言">编程语言</a> > 
            
            <a  data-rel="编程语言&lt;---&gt;常识类">常识类</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">编程语言</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2024-05-06 09:56:34'>2023-02-12 10:54</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:12.9k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                评论:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-text">1.进程、线程和协程的区别和联系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%A4%96%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">2.外中断和异常有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">3.进程调度算法你了解多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Linux%E4%B8%8B%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">4.Linux下进程间通信方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A6%82%E6%9E%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E5%90%8E%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90%E4%BB%80%E4%B9%88%E6%A0%B7%E4%BA%86%EF%BC%9F"><span class="toc-text">5.如果系统中具有快表后，那么地址的转换过程变成什么样了？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F%E5%8F%AF%E4%BB%A5%E5%88%86%E5%88%AB%E8%AF%B4%E8%AF%B4%E5%90%97%EF%BC%9F"><span class="toc-text">6.动态分区分配算法有哪几种？可以分别说说吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-text">7.虚拟技术你了解吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">8.虚拟内存的目的是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E4%B8%80%E4%B8%AAC-C-%E7%A8%8B%E5%BA%8F%E4%BB%8E%E5%BC%80%E5%A7%8B%E7%BC%96%E8%AF%91%E5%88%B0%E7%94%9F%E6%88%90%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%BD%A0%E8%83%BD%E8%AF%B4%E5%87%BA%E6%9D%A5%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-text">9.一个C&#x2F;C++程序从开始编译到生成可执行文件的完整过程，你能说出来多少？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E8%AE%B2%E8%A7%A3%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="toc-text">10.讲解逻辑地址转换为物理地址的基本过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">11.进程同步的四种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">12.进程通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%87%A0%E7%A7%8D%E5%85%B8%E5%9E%8B%E7%9A%84%E9%94%81%EF%BC%9F"><span class="toc-text">13.介绍一下几种典型的锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80VS%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-text">14.逻辑地址VS物理地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2"><span class="toc-text">15.内存交换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E5%A6%82%E4%BD%95%E8%AE%A9%E8%BF%9B%E7%A8%8B%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C"><span class="toc-text">16.如何让进程后台运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E5%BF%AB%E8%A1%A8%E5%9C%A8%E4%BB%80%E4%B9%88%E4%BD%8D%E7%BD%AE"><span class="toc-text">17.快表在什么位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-text">18.守护进程、僵尸进程和孤儿进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-text">19.如何避免僵尸进程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-Linux%E4%B8%AD%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">20.Linux中异常和中断的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%E5%9C%A8Linux-windows%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%A0%88%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-text">21.一般情况下在Linux&#x2F;windows平台下栈空间的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">22.交换空间是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E7%A7%8D%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-text">23.常见的几种磁盘调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E6%8A%96%E5%8A%A8%E4%BD%A0%E7%9F%A5%E9%81%93%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%97%EF%BC%9F%E5%AE%83%E4%B9%9F%E5%8F%AB%E9%A2%A0%E7%B0%B8%E7%8E%B0%E8%B1%A1"><span class="toc-text">24.抖动你知道是什么吗？它也叫颠簸现象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E4%B8%AD%EF%BC%8C%E8%A2%AB%E6%8D%A2%E5%87%BA%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-text">25.内存交换中，被换出的进程保存在哪里？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-ASCII%E3%80%81Unicode%E5%92%8CUTF-8%E7%BC%96%E7%A0%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">26.ASCII、Unicode和UTF-8编码的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">27.页面置换算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-Belady%E5%BC%82%E5%B8%B8"><span class="toc-text">28.Belady异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="toc-text">29.死锁产生原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-text">30.银行家算法</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-进程、线程和协程的区别和联系"><a href="#1-进程、线程和协程的区别和联系" class="headerlink" title="1.进程、线程和协程的区别和联系"></a>1.进程、线程和协程的区别和联系</h2><table>
<thead>
<tr>
<th></th>
<th>进程</th>
<th>线程</th>
<th>协程</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>资源分配和拥有的基本单位</td>
<td>程序执行的基本单位</td>
<td>用户态的轻量级线程，线程内部调度的基本单位</td>
</tr>
<tr>
<td>切换情况</td>
<td>进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置</td>
<td>保存和设置程序计数器、少量寄存器和栈的内容</td>
<td>先将寄存器上下文和栈保存，等切换回来的时候再进行恢复</td>
</tr>
<tr>
<td>切换者</td>
<td>操作系统</td>
<td>操作系统</td>
<td>用户</td>
</tr>
<tr>
<td>切换过程</td>
<td>用户态-&gt;内核态-&gt;用户态</td>
<td>用户态-&gt;内核态-&gt;用户态</td>
<td>用户态(没有陷入内核)</td>
</tr>
<tr>
<td>调用栈</td>
<td>内核栈</td>
<td>内核栈</td>
<td>用户栈</td>
</tr>
<tr>
<td>拥有资源</td>
<td>CPU资源、内存资源、文件资源和句柄等</td>
<td>程序计数器、寄存器、栈和状态字</td>
<td>拥有自己的寄存器上下文和栈</td>
</tr>
<tr>
<td>并发性</td>
<td>不同进程之间切换实现并发，各自占有CPU实现并行</td>
<td>一个进程内部的多个线程并发执行</td>
<td>同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理</td>
</tr>
<tr>
<td>系统开销</td>
<td>切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大</td>
<td>切换时只需保存和设置少量寄存器内容，因此开销很小</td>
<td>直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快</td>
</tr>
<tr>
<td>通信方面</td>
<td>进程间通信需要借助操作系统</td>
<td>线程间可以直接读写进程数据段(如全局变量)来进行通信</td>
<td>共享内存、消息队列</td>
</tr>
</tbody></table>
<h2 id="2-外中断和异常有什么区别？"><a href="#2-外中断和异常有什么区别？" class="headerlink" title="2.外中断和异常有什么区别？"></a>2.外中断和异常有什么区别？</h2><p>外中断（Interrupt）和异常（Exception）是计算机体系结构中两种不同的概念，它们有以下区别：</p>
<ol>
<li>来源：<br>外中断是由外部设备（如键盘、鼠标、定时器等）触发的中断，通常用于与计算机外部设备进行通信和交互。<br>异常是由于程序执行过程中出现了某种错误或不正常情况而触发的事件，例如除零、访问非法内存、非法指令等。</li>
<li>触发时机：<br>外中断是在 CPU 执行指令的过程中由外部设备发出的中断请求，可以在任何时候发生，甚至在指令执行的中间。<br>异常是在指令执行过程中出现了错误或不正常情况时发生的，通常是由当前指令执行的结果导致的。</li>
<li>处理方式：<br>外中断通常由操作系统的中断处理程序进行处理，它会保存当前进程的状态，切换到相应的中断处理程序，并在处理完成后返回到原进程继续执行。<br>异常通常由异常处理机制（如操作系统或硬件）进行处理，它会根据异常类型执行相应的处理逻辑，可能包括异常处理程序的调用、异常信息的记录等。</li>
<li>举例：<br>外中断的例子包括定时器中断、IO 设备中断等。<br>异常的例子包括除零异常、内存访问异常、非法指令异常等。</li>
</ol>
<p>总的来说，外中断和异常都是计算机体系结构中的重要概念，它们分别用于处理外部设备的中断请求和程序执行过程中的错误或异常情况，但在触发时机、处理方式等方面有所不同。</p>
<h2 id="3-进程调度算法你了解多少？"><a href="#3-进程调度算法你了解多少？" class="headerlink" title="3.进程调度算法你了解多少？"></a>3.进程调度算法你了解多少？</h2><ol>
<li><p><strong>先来先服务 first-come first-serverd（FCFS）</strong><br> 非抢占式的调度算法，按照请求的顺序进行调度。</p>
<p> 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
</li>
<li><p><strong>短作业优先 shortest job first（SJF）</strong><br> 非抢占式的调度算法，按估计运行时间最短的顺序进行调度。</p>
<p> 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
</li>
<li><p><strong>最短剩余时间优先 shortest remaining time next（SRTN）</strong><br> 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。</p>
<p> 如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
</li>
<li><p><strong>时间片轮转</strong><br> 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。</p>
<p> 当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。</p>
<p> 时间片轮转算法的效率和时间片的大小有很大关系：</p>
<p> 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。而如果时间片过长，那么实时性就不能得到保证。</p>
</li>
<li><p><strong>优先级调度</strong><br> 为每个进程分配一个优先级，按优先级进行调度。</p>
<p> 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
</li>
<li><p><strong>多级反馈队列</strong><br> 一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。</p>
<p> 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。</p>
<p> 这种方式下，之前的进程只需要交换 7 次。每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。</p>
<p> 可以将这种调度算法看成是<code>时间片轮转调度算法和优先级调度算法的结合</code>。</p>
</li>
</ol>
<h2 id="4-Linux下进程间通信方式？"><a href="#4-Linux下进程间通信方式？" class="headerlink" title="4.Linux下进程间通信方式？"></a>4.Linux下进程间通信方式？</h2><ul>
<li><p>管道：</p>
<ul>
<li><p>无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。</p>
</li>
<li><p>有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</p>
</li>
</ul>
</li>
<li><p>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。</p>
</li>
<li><p>消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
</li>
<li><p>套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</p>
</li>
<li><p>信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</p>
</li>
<li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。</p>
</li>
</ul>
<h2 id="5-如果系统中具有快表后，那么地址的转换过程变成什么样了？"><a href="#5-如果系统中具有快表后，那么地址的转换过程变成什么样了？" class="headerlink" title="5.如果系统中具有快表后，那么地址的转换过程变成什么样了？"></a>5.如果系统中具有快表后，那么地址的转换过程变成什么样了？</h2><ol>
<li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。  </li>
<li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。  </li>
<li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)</li>
</ol>
<p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。 因为局部性原理，–般来说快表的命中率可以达到90%以上。</p>
<ul>
<li><p>局部性原理:<br>局部性原理是计算机系统设计中的一个重要概念，它指的是在程序执行过程中，访问内存的趋势是倾向于集中在一小部分地址范围内。局部性原理分为两种类型：时间局部性和空间局部性。</p>
<ul>
<li>时间局部性（Temporal Locality）：</li>
</ul>
</li>
</ul>
<p>时间局部性指的是，如果在程序的某个时间点访问了某个存储单元，那么在不久之后的时间内，很可能会再次访问相同的存储单元。这意味着程序倾向于重复使用最近使用过的数据或指令。时间局部性的主要原因是程序中存在循环、子程序调用等结构，导致某些数据被反复使用。</p>
<pre><code>* 空间局部性（Spatial Locality）：
</code></pre>
<p>空间局部性指的是，如果程序访问了某个存储单元，那么在不久之后的时间内，很可能会访问与该存储单元相邻的存储单元。这意味着程序倾向于顺序地访问相邻的内存位置，例如数组、矩阵等数据结构。空间局部性的主要原因是计算机系统中的缓存机制，通常会将相邻的内存位置加载到缓存中，以提高访问效率。</p>
<h2 id="6-动态分区分配算法有哪几种？可以分别说说吗？"><a href="#6-动态分区分配算法有哪几种？可以分别说说吗？" class="headerlink" title="6.动态分区分配算法有哪几种？可以分别说说吗？"></a>6.动态分区分配算法有哪几种？可以分别说说吗？</h2><table>
<thead>
<tr>
<th>算法</th>
<th>算法思想</th>
<th>分区排列顺序</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>首次适应</td>
<td>从头到尾找适合的分区</td>
<td>空闲分区以地址递增次序排列</td>
<td>综合看性能最好。算法开销小，回收分区后一.般不需要对空闲分区队列重新排序</td>
<td></td>
</tr>
<tr>
<td>最佳适应</td>
<td>优先使用更小的分区，以保留更多大分区</td>
<td>空闲分区以容量递增次序排列</td>
<td>会有更多的大分区被保留下来，更能满足大进程需求</td>
<td>会产生很多太小的、难以利用的碎片;算法开销大，回收分区后可能需要对空闲分区队列重新排序</td>
</tr>
<tr>
<td>最坏适应</td>
<td>优先使用更大的分区，以防止产生太小的不可用的碎片</td>
<td>空闲分区以容量递减次序排列</td>
<td>可以减少难以利用的小碎片</td>
<td>大分区容易被用完，不利于大进程;算法开销大(原因同上)</td>
</tr>
<tr>
<td>邻近适应</td>
<td>由首次适应演变而来，每次从上次查找结束位置开始查找</td>
<td>空闲分区以地址递增次序排列(可排列成循环链表)	不</td>
<td>用每次都从低地址的小分区开始检索。算法开销小(原因同首次适应算法)</td>
<td>会使高地址的大分区也被用完</td>
</tr>
</tbody></table>
<h2 id="7-虚拟技术你了解吗？"><a href="#7-虚拟技术你了解吗？" class="headerlink" title="7.虚拟技术你了解吗？"></a>7.虚拟技术你了解吗？</h2><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：<code>时（时间）分复用技术</code>和<code>空（空间）分复用技术</code>。</p>
<ul>
<li><p>多进程与多线程：多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。</p>
</li>
<li><p>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>
</li>
</ul>
<h2 id="8-虚拟内存的目的是什么？"><a href="#8-虚拟内存的目的是什么？" class="headerlink" title="8.虚拟内存的目的是什么？"></a>8.虚拟内存的目的是什么？</h2><p><strong>空分复用:</strong></p>
<p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。</p>
<p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。</p>
<p>这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p>
<p>例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。</p>
<h2 id="9-一个C-C-程序从开始编译到生成可执行文件的完整过程，你能说出来多少？"><a href="#9-一个C-C-程序从开始编译到生成可执行文件的完整过程，你能说出来多少？" class="headerlink" title="9.一个C&#x2F;C++程序从开始编译到生成可执行文件的完整过程，你能说出来多少？"></a>9.一个C&#x2F;C++程序从开始编译到生成可执行文件的完整过程，你能说出来多少？</h2><p>四个过程：</p>
<p>（1）预编译 主要处理源代码文件中的以“#”开头的预编译指令。处理规则见下</p>
<ol>
<li><p>删除所有的#define，展开所有的宏定义。</p>
</li>
<li><p>处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。</p>
</li>
<li><p>处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他 文件。</p>
</li>
<li><p>删除所有的注释，“&#x2F;&#x2F;”和“&#x2F;**&#x2F;”。</p>
</li>
<li><p>保留所有的#pragma 编译器指令，编译器需要用到他们，如：#pragma once 是为了防止有文件被重 复引用。</p>
</li>
<li><p>添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是 能够显示行号。</p>
</li>
</ol>
<p>（2）编译 把预编译之后生成的xxx.i或xxx.ii文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码文件。</p>
<ol>
<li><p>词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。</p>
</li>
<li><p>语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。</p>
</li>
<li><p>语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。</p>
</li>
<li><p>优化：源代码级别的一个优化过程。</p>
</li>
<li><p>目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。</p>
</li>
<li><p>目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。</p>
</li>
</ol>
<p>（3）汇编</p>
<p>将汇编代码转变成机器可以执行的指令(机器码文件)。 汇编器的汇编过程相对于编译器来说更简单，没有复杂的语法，也没有语义，更不需要做指令优化，只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。</p>
<p>经汇编之后，产生目标文件(与可执行文件格式几乎一样)xxx.o(Linux下)、xxx.obj(Windows下)。</p>
<p>（4）链接</p>
<p>将不同的源文件产生的目标文件进行链接，从而形成一个可以执行的程序。链接分为静态链接和动态链接：</p>
<ol>
<li><p>静态链接： 函数和数据被编译进一个二进制文件。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。</p>
<ul>
<li>运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。</li>
</ul>
</li>
<li><p>动态链接： 动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</p>
<ul>
<li><p>共享库：就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本；</p>
</li>
<li><p>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。</p>
</li>
<li><p>性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。</p>
</li>
</ul>
</li>
</ol>
<h2 id="10-讲解逻辑地址转换为物理地址的基本过程"><a href="#10-讲解逻辑地址转换为物理地址的基本过程" class="headerlink" title="10.讲解逻辑地址转换为物理地址的基本过程"></a>10.讲解逻辑地址转换为物理地址的基本过程</h2><p><img src="/2023/02/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/addressing.png"></p>
<h2 id="11-进程同步的四种方法"><a href="#11-进程同步的四种方法" class="headerlink" title="11.进程同步的四种方法"></a>11.进程同步的四种方法</h2><ol>
<li><p>临界区  </p>
<p> 对临界资源进行访问的那段代码称为临界区。</p>
<p> 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
</li>
<li><p>同步与互斥  </p>
<p> 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。  </p>
<p> 互斥：多个进程在同一时刻只有一个进程能进入临界区。</p>
</li>
<li><p>信号量  </p>
<p> 信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
</li>
<li><p>管程  </p>
<p> 管程是一种高级的同步机制，它将数据结构和操作封装在一起，提供了对共享资源的访问和控制。只有通过管程提供的操作才能访问共享资源，从而确保了对共享资源的互斥访问。</p>
<p> 管程（Monitor）实质上可以看作是一个类或者一个抽象数据类型（ADT）。它封装了共享资源以及对该资源的访问和控制方法，提供了一种高级的同步机制。</p>
</li>
</ol>
<h2 id="12-进程通信方式"><a href="#12-进程通信方式" class="headerlink" title="12.进程通信方式"></a>12.进程通信方式</h2><ul>
<li><p>管道(pipe)：允许一个进程和另一个与它有共同祖先的进程之间进行通信</p>
</li>
<li><p>命名管道(FIFO)：类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建</p>
</li>
<li><p>消息队列(MQ)：消息队列是消息的连接表，包括POSIX消息对和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点；</p>
</li>
<li><p>信号量(semaphore)：信号量主要作为进程间以及同进程不同线程之间的同步手段；</p>
</li>
<li><p>共享内存(shared memory)：它使得多个进程可以访问同一块内存空间，<strong>是最快的可用IPC形式。</strong>这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥</p>
</li>
<li><p>信号(signal)：信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身<br>内存映射(mapped memory)：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它</p>
</li>
<li><p>Socket：它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信</p>
</li>
</ul>
<h2 id="13-介绍一下几种典型的锁？"><a href="#13-介绍一下几种典型的锁？" class="headerlink" title="13.介绍一下几种典型的锁？"></a>13.介绍一下几种典型的锁？</h2><ul>
<li><p>读写锁  </p>
<ul>
<li>多个读者可以同时进行读</li>
<li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li>
<li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li>
</ul>
</li>
<li><p>互斥锁</p>
<ul>
<li><p>一次只能一个线程拥有互斥锁，其他线程只有等待</p>
</li>
<li><p>互斥锁是在抢锁失败的情况下<strong>主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度</strong>，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p>
</li>
</ul>
</li>
<li><p>条件变量</p>
<ul>
<li>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。</li>
</ul>
</li>
<li><p>自旋锁</p>
<ul>
<li>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</li>
</ul>
</li>
</ul>
<h2 id="14-逻辑地址VS物理地址"><a href="#14-逻辑地址VS物理地址" class="headerlink" title="14.逻辑地址VS物理地址"></a>14.逻辑地址VS物理地址</h2><blockquote>
<p>注意：物理地址指的是程序在内存中的地址，而不是程序在硬盘中的地址。</p>
</blockquote>
<p>逻辑地址（Logical Address）和物理地址（Physical Address）是在计算机系统中用于访问内存的两种不同的地址类型，它们之间存在着映射关系。下面是它们的区别：</p>
<ol>
<li><p>逻辑地址：</p>
<ul>
<li>逻辑地址是由CPU产生的地址，用于访问内存中的数据和指令。它是一个虚拟地址，与实际的硬件内存地址无关。</li>
<li>在多道程序设计环境下，每个进程都有自己的逻辑地址空间。逻辑地址是相对于进程而言的，它从0开始，通常是一个连续的地址空间。</li>
<li>逻辑地址的映射是由操作系统的内存管理单元来完成的，包括地址翻译、分页机制、分段机制等。</li>
</ul>
</li>
<li><p>物理地址：</p>
<ul>
<li>物理地址是实际存储在计算机硬件中的地址，用于在内存中定位数据和指令的位置。它是相对于物理内存模块而言的，是真实存在的硬件地址。</li>
<li>物理地址是由内存管理单元（Memory Management Unit，MMU）根据逻辑地址的映射关系转换得到的。MMU负责将逻辑地址映射到相应的物理地址上，以便CPU可以正确地访问内存中的数据。</li>
</ul>
</li>
<li><p>映射关系：</p>
<ul>
<li>逻辑地址和物理地址之间存在着映射关系，这个映射关系由操作系统的内存管理单元来管理和维护。</li>
<li>当CPU发出一个逻辑地址时，MMU会根据逻辑地址的映射关系将其转换为相应的物理地址，然后用于实际的内存访问。</li>
</ul>
</li>
</ol>
<p>总的来说，逻辑地址是虚拟的地址空间，是由CPU产生的相对地址；而物理地址是真实的硬件地址，是内存中实际存储数据和指令的位置。通过逻辑地址和物理地址之间的映射关系，CPU可以正确地访问内存中的数据和指令。</p>
<h2 id="15-内存交换"><a href="#15-内存交换" class="headerlink" title="15.内存交换"></a>15.内存交换</h2><ol>
<li><p>内存覆盖（Memory Overlay）：</p>
<ul>
<li>内存覆盖是一种技术，用于在内存有限的情况下运行较大的程序。当程序的内存需求超过了系统的物理内存时，操作系统会将程序的一部分加载到内存中运行，然后根据需要逐步覆盖、替换加载的程序段。</li>
<li>内存覆盖通常用于早期的计算机系统，特别是在内存容量受限的环境下。它可以让大型程序在较小的内存空间中运行，但需要手动管理内存的分段和覆盖过程。</li>
</ul>
</li>
<li><p>内存交换（Memory Swapping）：</p>
<ul>
<li>内存交换是一种技术，用于在系统的物理内存不足时将部分内存中的数据和程序暂时移到辅助存储设备（如硬盘）中。这样可以腾出内存空间供其他程序使用。</li>
<li>当操作系统检测到物理内存不足时，它会将部分不活动的进程或者数据交换到硬盘上，以释放内存空间。当需要访问这些被交换出去的数据时，操作系统会将其再次交换回内存中，以满足程序的需求。</li>
<li>内存交换是一种动态的内存管理技术，操作系统可以根据系统的内存需求自动进行内存交换，无需用户干预。</li>
</ul>
</li>
</ol>
<p>总的来说，内存覆盖和内存交换都是用于解决内存有限的情况下运行大型程序的技术，但它们的实现方式和应用场景略有不同。<strong>内存覆盖主要用于早期计算机系统中，而内存交换则是现代操作系统中常用的内存管理技术之一</strong>。</p>
<h2 id="16-如何让进程后台运行"><a href="#16-如何让进程后台运行" class="headerlink" title="16.如何让进程后台运行"></a>16.如何让进程后台运行</h2><ol>
<li><p>使用后台运行命令：</p>
<ul>
<li>在 Unix&#x2F;Linux 系统中，可以使用 &amp; 符号将命令放置在后台运行。例如：.&#x2F;my_program &amp;。</li>
<li>实际上，这样是将命令放入到一个作业队列中了。这样可以使得该进程在后台运行，不会阻塞当前终端的使用。</li>
</ul>
</li>
<li><p>使用 nohup 命令：</p>
<ul>
<li>nohup 命令可以让进程在后台运行，并且不受终端关闭的影响。例如：nohup .&#x2F;my_program &amp;。</li>
<li>使用 nohup 后，即使关闭终端或者注销用户，进程仍然会继续在后台运行。</li>
</ul>
</li>
<li><p>使用 screen 或者 tmux：</p>
<ul>
<li>screen 或者 tmux 是终端复用工具，可以创建一个或多个终端窗口，并在其中运行进程。即使关闭了当前终端窗口，进程仍然会继续在后台运行。</li>
<li>具体使用方法请参考 screen 或者 tmux 的文档。</li>
</ul>
</li>
<li><p>使用后台运行守护进程：</p>
<ul>
<li>将需要后台运行的程序设计为守护进程，并使用系统服务管理工具（如 systemd、init.d 等）启动该守护进程。</li>
<li>守护进程是一种在后台运行的长期运行的进程，通常用于执行系统任务或服务。</li>
</ul>
</li>
</ol>
<h2 id="17-快表在什么位置"><a href="#17-快表在什么位置" class="headerlink" title="17.快表在什么位置"></a>17.快表在什么位置</h2><p>TLB（Translation Lookaside Buffer，快表）通常位于处理器的内部，是一个高速缓存结构，用于存储最近使用的逻辑地址到物理地址的映射关系。TLB的设计旨在加速逻辑地址到物理地址的转换过程，提高系统的性能和响应速度。</p>
<h2 id="18-守护进程、僵尸进程和孤儿进程"><a href="#18-守护进程、僵尸进程和孤儿进程" class="headerlink" title="18.守护进程、僵尸进程和孤儿进程"></a>18.守护进程、僵尸进程和孤儿进程</h2><ol>
<li><p>守护进程（Daemon Process）：</p>
<ul>
<li>守护进程是在后台运行的一种特殊进程，通常是由操作系统启动并且在后台运行的进程。它通常不与任何用户交互，而是执行一些系统任务或服务，例如网络服务、日志服务等。</li>
<li>守护进程通常在系统启动时被初始化，并且一直运行直到系统关闭。它们通常不会终止，除非出现严重的错误或者手动停止。</li>
</ul>
</li>
<li><p>僵尸进程（Zombie Process）：</p>
<ul>
<li>僵尸进程是已经完成执行但是其父进程尚未调用 <code>wait()</code> 或 <code>waitpid()</code> 函数来获取其终止状态的进程。在这种情况下，操作系统会将僵尸进程保留在进程表中，直到其父进程获取其终止状态。</li>
<li>僵尸进程不会占用系统资源，但是如果太多的僵尸进程积累，会导致系统的进程表被占满，从而影响系统的正常运行。</li>
</ul>
</li>
<li><p>孤儿进程（Orphan Process）：</p>
<ul>
<li>孤儿进程是指其父进程提前终止或者意外终止，而导致子进程成为没有父进程的进程。在这种情况下，子进程会被 <code>init</code> 进程（进程号为1）接管。</li>
<li>孤儿进程会继续在系统中运行，直到其自己终止或者被 <code>init</code> 进程接管。这样可以确保孤儿进程不会成为僵尸进程，因为 <code>init</code> 进程会及时调用 <code>wait()</code> 函数获取其终止状态。</li>
</ul>
</li>
</ol>
<h2 id="19-如何避免僵尸进程？"><a href="#19-如何避免僵尸进程？" class="headerlink" title="19.如何避免僵尸进程？"></a>19.如何避免僵尸进程？</h2><ol>
<li><p>父进程调用 wait() 或 waitpid() 函数：</p>
<ul>
<li>父进程可以通过调用 wait() 或 waitpid() 函数来等待子进程的退出，并获取子进程的终止状态。这样可以及时回收子进程的资源，并避免其成为僵尸进程。</li>
<li>在父进程中定期调用 wait() 或 waitpid() 函数可以确保及时处理子进程的退出。</li>
</ul>
</li>
<li><p>使用信号处理函数：</p>
<ul>
<li>父进程可以注册 <code>SIGCHLD</code> 信号的处理函数，在收到该信号时调用 <code>wait()</code> 或 <code>waitpid()</code> 函数来处理子进程的退出。</li>
<li>当子进程退出时，操作系统会向父进程发送 SIGCHLD 信号，父进程可以在信号处理函数中获取子进程的终止状态。</li>
</ul>
</li>
<li><p>设置信号处理方式为忽略（SIG_IGN）：</p>
<ul>
<li>父进程可以将 <code>SIGCHLD</code> 信号的处理方式设置为忽略，这样子进程退出时可让内核把僵尸子进程转交给init进程去处理，不会产生僵尸进程。</li>
<li>但是需要注意的是，这种方式下无法获取子进程的终止状态，可能会导致资源泄漏或者无法正确处理异常情况。</li>
</ul>
</li>
</ol>
<h2 id="20-Linux中异常和中断的区别"><a href="#20-Linux中异常和中断的区别" class="headerlink" title="20.Linux中异常和中断的区别"></a>20.Linux中异常和中断的区别</h2><p>在Linux系统中，异常（Exception）和中断（Interrupt）是两种不同的事件，它们的触发方式、处理方式以及产生的原因有所不同。</p>
<ol>
<li><p>异常（Exception）：</p>
<ul>
<li>异常是指在程序执行过程中发生的意外事件或错误情况，例如除零错误、内存访问越界等。异常通常是由CPU在执行指令过程中检测到的，它是指令执行的结果与预期不符导致的。</li>
<li>在Linux系统中，异常由CPU直接检测并触发，然后将控制权转移给操作系统内核。操作系统内核会根据异常的类型和原因采取相应的处理措施，例如向用户进程发送信号、终止异常进程等。</li>
</ul>
</li>
<li><p>中断（Interrupt）：</p>
<ul>
<li>中断是指外部设备或者硬件组件发送的信号，用于通知CPU需要处理某个事件或者执行某个操作。中断可以是来自硬件设备的信号（硬件中断），也可以是来自软件的信号（软件中断）。</li>
<li>在Linux系统中，中断通常由硬件设备发送给CPU，例如定时器中断、键盘输入中断等。当CPU接收到中断信号时，会暂停当前的执行流程，并转移到中断处理程序（中断服务程序）中执行。中断处理程序负责处理中断事件，并进行相应的处理，例如读取设备数据、响应用户输入等。</li>
</ul>
</li>
</ol>
<p>总的来说，异常是程序执行过程中的错误情况，由CPU直接检测并触发；而中断是外部设备发送的信号，用于通知CPU需要处理某个事件或者执行某个操作。异常和中断在触发方式、处理方式以及产生原因上有着明显的区别。</p>
<h2 id="21-一般情况下在Linux-windows平台下栈空间的大小"><a href="#21-一般情况下在Linux-windows平台下栈空间的大小" class="headerlink" title="21.一般情况下在Linux&#x2F;windows平台下栈空间的大小"></a>21.一般情况下在Linux&#x2F;windows平台下栈空间的大小</h2><ul>
<li><p>Linux环境下有操作系统决定，一般是8MB，8192KB，通过<code>ulimit</code>命令查看以及修改</p>
</li>
<li><p>Windows环境下由编译器决定，VC++6.0一般是1M</p>
</li>
</ul>
<h2 id="22-交换空间是什么"><a href="#22-交换空间是什么" class="headerlink" title="22.交换空间是什么"></a>22.交换空间是什么</h2><p>交换空间（Swap Space）是指操作系统用于扩展虚拟内存的一种技术，它将部分内存数据临时存储到磁盘上以释放物理内存空间。交换空间通常用于以下几种情况：</p>
<ol>
<li><p>内存不足：当系统的物理内存不足以容纳所有的进程和数据时，操作系统会将部分不经常使用的数据存储到交换空间中，以释放物理内存空间给更重要的进程使用。</p>
</li>
<li><p>内存回收：操作系统可以使用交换空间来回收不活动的内存页面，以便将其分配给其他进程使用。这有助于优化内存的使用效率和系统的性能。</p>
</li>
<li><p>休眠和恢复：在某些情况下，操作系统可以使用交换空间来存储休眠进程的状态，以便在系统重新启动或恢复时能够快速恢复进程的状态。</p>
</li>
</ol>
<p>交换空间通常由操作系统预先分配，并且可以是一个专门的交换分区，也可以是一个交换文件。交换空间的大小可以根据系统的配置和需求进行调整，但是过度使用交换空间可能会影响系统的性能，因为磁盘访问速度远远低于内存访问速度。因此，合理配置交换空间是系统性能优化的重要一环。</p>
<h2 id="23-常见的几种磁盘调度算法"><a href="#23-常见的几种磁盘调度算法" class="headerlink" title="23.常见的几种磁盘调度算法"></a>23.常见的几种磁盘调度算法</h2><ol>
<li><p>先来先服务（First-Come, First-Served，FCFS）：</p>
<ul>
<li>FCFS 是最简单的磁盘调度算法，按照请求到达的顺序依次处理磁盘访问请求。</li>
<li>这种算法的优点是公平性，即所有的请求都能够得到处理。但是它可能会导致磁盘头在磁盘上来回移动，造成平均响应时间较长。</li>
</ul>
</li>
<li><p>最短寻道时间优先（Shortest Seek Time First，SSTF）：</p>
<ul>
<li>SSTF 算法会优先处理与磁头当前位置最接近的磁盘访问请求。</li>
<li>这种算法能够减少磁盘头的移动距离，从而缩短平均响应时间。但是它可能会导致部分请求长时间等待，造成请求饥饿现象。</li>
</ul>
</li>
<li><p>电梯算法（Elevator Algorithm）：</p>
<ul>
<li>电梯算法模拟了电梯在多层楼间上下运动的过程，磁盘头会沿着一个方向移动，直到该方向上没有未处理的请求，然后改变方向。</li>
<li>这种算法能够有效地减少磁盘头的移动次数，从而提高磁盘访问的效率。但是它可能会导致一些请求长时间等待，特别是当磁盘请求集中在一个方向时。</li>
</ul>
</li>
<li><p>扫描算法（SCAN）：</p>
<ul>
<li>扫描算法（也称为电梯算法的变种）从磁盘上的一个端点开始沿着一个方向移动，处理所有的请求，直到达到另一个端点，然后返回，继续处理另一侧的请求。</li>
<li>这种算法能够平衡磁盘头的移动，避免了某些请求长时间等待的情况，但是可能会导致磁盘头在两端之间频繁切换，造成磁盘头的忙碌。</li>
</ul>
</li>
</ol>
<h2 id="24-抖动你知道是什么吗？它也叫颠簸现象"><a href="#24-抖动你知道是什么吗？它也叫颠簸现象" class="headerlink" title="24.抖动你知道是什么吗？它也叫颠簸现象"></a>24.抖动你知道是什么吗？它也叫颠簸现象</h2><p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)</p>
<h2 id="25-内存交换中，被换出的进程保存在哪里？"><a href="#25-内存交换中，被换出的进程保存在哪里？" class="headerlink" title="25.内存交换中，被换出的进程保存在哪里？"></a>25.内存交换中，被换出的进程保存在哪里？</h2><p>保存在磁盘中，也就是外存中。具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解)。总之，对换区的I&#x2F;O速度比文件区的更快。</p>
<h2 id="26-ASCII、Unicode和UTF-8编码的区别？"><a href="#26-ASCII、Unicode和UTF-8编码的区别？" class="headerlink" title="26.ASCII、Unicode和UTF-8编码的区别？"></a>26.ASCII、Unicode和UTF-8编码的区别？</h2><ul>
<li><p>ASCII<br>  ASCII 只有127个字符，表示英文字母的大小写、数字和一些符号，但由于其他语言用ASCII 编码表示字节不够，例如：常用中文需要两个字节，且不能和ASCII冲突，中国定制了GB2312编码格式，相同的，其他国家的语言也有属于自己的编码格式。</p>
</li>
<li><p>Unicode<br>  由于每个国家的语言都有属于自己的编码格式，在多语言编辑文本中会出现乱码，这样Unicode应运而生，Unicode就是将这些语言统一到一套编码格式中，通常两个字节表示一个字符，而ASCII是一个字节表示一个字符，这样如果你编译的文本是全英文的，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>
</li>
<li><p>UTF-8<br>  为了解决上述问题，又出现了把Unicode编码转化为<code>可变长编码</code>UTF-8编码，UTF-8编码将Unicode字符按数字大小编码为1-6个字节，英文字母被编码成一个字节，常用汉字被编码成三个字节，如果你编译的文本是纯英文的，那么用UTF-8就会非常节省空间，并且ASCII码也是UTF-8的一部分。</p>
</li>
<li><p>三者之间的联系<br>  搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p>
<ol>
<li><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码:</p>
</li>
<li><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。如下图<br>  <img src="/2023/02/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/code1.png"></p>
</li>
<li><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：<br>  <img src="/2023/02/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/code2.png"></p>
</li>
</ol>
</li>
</ul>
<h2 id="27-页面置换算法"><a href="#27-页面置换算法" class="headerlink" title="27.页面置换算法"></a>27.页面置换算法</h2><ol>
<li><p>最佳置换法(OPT)</p>
<ul>
<li>最佳置换算法(OPT，Optimal) :每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。</li>
<li>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的</li>
</ul>
</li>
<li><p>先进先出置换算法(FIFO)</p>
<ul>
<li><p>先进先出置换算法(FIFO) :每次选择淘汰的页面是最早进入内存的页面 实现方法:把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面队列的最大长度取决于系统为进程分配了多少个内存块。</p>
</li>
<li><p><strong>Belady异常—当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</strong></p>
</li>
<li><p>只有FIFO算法会产生Belady异常，而LRU和OPT算法永远不会出现Belady异常。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，算法性能差</p>
</li>
<li><p>FIFO的性能较差，因为较早调入的页往往是经常被访问的页，这些页在FIFO算法下被反复调入和调出，并且有Belady现象。所谓Belady现象是指：采用FIFO算法时，如果对—个进程未分配它所要求的全部页面，有时就会出现分配的页面数增多但缺页率反而提高的异常现象。</p>
</li>
</ul>
</li>
<li><p>最近最久未使用置换算法(LRU)</p>
<ul>
<li><p>最近最久未使用置换算法(LRU，least recently used) :每次淘汰的页面是最近最久未使用的页面 实现方法:赋予每个页面对应的页表项中，用访问字段记录该页面自.上次被访问以来所经历的时间t(该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大)。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。</p>
</li>
<li><p>LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类算法，理论上可以证明，堆栈类算法不可能出现Belady异常。</p>
</li>
</ul>
</li>
<li><p>时钟置换算法(CLOCK)</p>
<ul>
<li><p>最佳置换算法性OPT能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。</p>
</li>
<li><p>所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体，因为算法要循环扫描缓冲区像时钟一样转动。所以叫clock算法。</p>
</li>
<li><p>时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used)</p>
</li>
<li><p>简单的CLOCK算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰-一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第- - ~轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择–个淘汰页面最多会经过两轮扫描)</p>
</li>
</ul>
</li>
<li><p>改进型的时钟置换算法</p>
<ul>
<li><p>简单的时钟置换算法仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过,就不需要执行I&#x2F;O操作写回外存。只有被淘汰的页面被修改过时，才需要写回外存。</p>
</li>
<li><p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I&#x2F;O操作。这就是改进型的时钟置换算法的思想。修改位&#x3D;0，表示页面没有被修改过;修改位&#x3D;1，表示页面被修改过。</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>总结</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>算法规则</th>
<th>优缺点</th>
</tr>
</thead>
<tbody><tr>
<td>OPT</td>
<td>优先淘汰最长时间内不会被访问的页面</td>
<td>缺页率最小，性能最好;但无法实现</td>
</tr>
<tr>
<td>FIFO</td>
<td>优先淘汰最先进入内存的页面</td>
<td>实现简单;但性能很差，可能出现Belady异常</td>
</tr>
<tr>
<td>LRU</td>
<td>优先淘汰最近最久没访问的页面</td>
<td>性能很好;但需要硬件支持，算法开销大</td>
</tr>
<tr>
<td>CLOCK (NRU)</td>
<td>循环扫描各页面 第一轮淘汰访问位&#x3D;0的，并将扫描过的页面访问位改为1。若第-轮没选中，则进行第二轮扫描。</td>
<td>实现简单，算法开销小;但未考虑页面是否被修改过。</td>
</tr>
<tr>
<td>改进型CLOCK (改进型NRU)</td>
<td>若用(访问位，修改位)的形式表述，则 第一轮:淘汰(0,0) 第二轮:淘汰(O,1)，并将扫描过的页面访问位都置为0 第三轮:淘汰(O, 0) 第四轮:淘汰(0, 1)</td>
<td>算法开销较小，性能也不错</td>
</tr>
</tbody></table>
<h2 id="28-Belady异常"><a href="#28-Belady异常" class="headerlink" title="28.Belady异常"></a>28.Belady异常</h2><ol>
<li><p>LRU为什么不会发生Belady异常？  </p>
<ul>
<li><p>实页数增加 —&gt; 能贮存的页数增加 —&gt; 哪些页？—&gt; 访问频率高的页</p>
</li>
<li><p>LRU当中替换的是使用频率最低的页，留下的都是使用频率高的页。当实页数增加，能够留下的高频访问的页也就更多，这直接关系到命中率的增加。</p>
</li>
</ul>
</li>
<li><p>FIFO为什么会发生Belady异常？</p>
<ul>
<li><p>实页数增加 —&gt; 能贮存的页数增加 —&gt; 哪些页？—&gt; 后面来的页</p>
</li>
<li><p>先进先出的替换算法，完全不考虑使用频率，即使增加了实页数，多贮存的部分接下来常访问可能性也不一定大（看运气），也就并不一定能增加命中率。</p>
</li>
</ul>
</li>
</ol>
<h2 id="29-死锁产生原因"><a href="#29-死锁产生原因" class="headerlink" title="29.死锁产生原因"></a>29.死锁产生原因</h2><p>举个例子：两个线程A和B，两个数据1和2。线程A在执行过程中，首先对资源1加锁，然后再去给资源2加锁，但是由于线程的切换，导致线程A没能给资源2加锁。线程切换到B后，线程B先对资源2加锁，然后再去给资源1加锁，由于资源1已经被线程A加锁，因此线程B无法加锁成功，当线程切换为A时，A也无法成功对资源2加锁，由此就造成了线程AB双方相互对一个已加锁资源的等待，死锁产生。</p>
<p>理论上认为死锁产生有以下四个必要条件，缺一不可：</p>
<ul>
<li><p>互斥条件：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。</p>
</li>
<li><p>不剥夺条件：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。</p>
</li>
<li><p>请求和保持条件：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。</p>
</li>
<li><p>循环等待条件：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</p>
</li>
</ul>
<h2 id="30-银行家算法"><a href="#30-银行家算法" class="headerlink" title="30.银行家算法"></a>30.银行家算法</h2><p>银行家算法是一种用于避免死锁（Deadlock）的资源分配和调度算法，最初由Dijkstra在1965年提出。它通过合理地分配和释放资源，避免了进程之间因争夺资源而导致的死锁问题。银行家算法主要用于操作系统中的进程管理和资源分配。</p>
<p>银行家算法的基本思想是通过检查分配资源的安全性来决定是否允许进程继续运行。它通过维护一个系统资源分配的最大需求矩阵、可用资源向量和已分配资源矩阵，来判断系统当前是否处于安全状态。</p>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 1430797759@qq.com </span>
    </div>
</article>



<div class="article_copyright">
    <p><span class="copy-title">文章标题:</span>操作系统</p>
    <p><span class="copy-title">字数:</span><span class="post-count">12.9k</span></p>
    <p><span class="copy-title">本文作者:</span><a  title="花落阁">花落阁</a></p>
    <p><span class="copy-title">发布时间:</span>2023-02-12, 10:54:34</p>
    <p><span class="copy-title">最后更新:</span>2024-05-06, 09:56:34</p>
    <span class="copy-title">原始链接:</span><a class="post-url" href="/2023/02/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统">https://hualog.dns.navy/2023/02/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a>
    <p>
        <span class="copy-title">版权声明:</span><i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">&#34;署名-非商用-相同方式共享 4.0&#34;</a> 转载请保留原文链接及作者。
    </p>
</div>



    <div id="comments"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

<script type="text/javascript">
    $.getScript('/js/gitalk.js', function () {
        var gitalk = new Gitalk({
            clientID: '53b33c5626275dc09dfa',
            clientSecret: '285946a68f8f1bafc052f02fded36467fea269c2',
            repo: 'xuanxuan000.github.io',
            owner: 'xuanxuan000',
            admin: ['xuanxuan000'],
            id: decodeURI(location.pathname),
            distractionFreeMode: 'true',
            language: 'zh-CN',
            perPage: parseInt('10',10)
        })
        gitalk.render('comments')
    })
</script>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2024-2034 Aze
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    
    #post .pjax article .article-entry>ol, #post .pjax article .article-entry>ul, #post .pjax article>ol, #post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    #post .pjax article .article-entry li>ol, #post .pjax article .article-entry li>ul,#post .pjax article li>ol, #post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    #post .pjax article .article-entry>ol>li, #post .pjax article .article-entry>ul>li,#post .pjax article>ol>li, #post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    #post .pjax article .article-entry li>ol>li, #post .pjax article .article-entry li>ul>li,#post .pjax article li>ol>li, #post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
